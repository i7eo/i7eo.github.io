<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Solitude is freedom</title>
  
  <subtitle>Articles on front-end development by George Tan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://i7eo.com/"/>
  <updated>2021-06-24T12:28:42.635Z</updated>
  <id>https://i7eo.com/</id>
  
  <author>
    <name>George Tan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webpack4.0 学习笔记（下）</title>
    <link href="https://i7eo.com/2020/03/10/Webpack4-0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8B.html"/>
    <id>https://i7eo.com/2020/03/10/Webpack4-0-学习笔记-下.html</id>
    <published>2020-03-10T13:04:45.000Z</published>
    <updated>2021-06-24T12:28:42.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Webpack4-0-学习笔记"><a href="#Webpack4-0-学习笔记" class="headerlink" title="Webpack4.0 学习笔记"></a>Webpack4.0 学习笔记</h3><h3 id="浏览器-Caching"><a href="#浏览器-Caching" class="headerlink" title="浏览器 Caching"></a>浏览器 Caching</h3><p>当我们在打包资源的时候资源名以文件名命名，修改资源，接着普通刷新资源是不会改变的（其实是浏览器将上一次的资源缓存了）。解决方法就是在资源命名处加上 <code>[contenthash]</code> 来解决这个问题。先来看几个概念:</p><ol><li><p>runtime:<br>在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。它包含：在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。在未使用 <code>optimization: { runtimeChunk: { name: &#39;runtime&#39; } }</code> 时，runtime 被存放在入口的 main.js 中，只有使用后才会被单独打包出来。</p></li><li><p>manifest:<br>存在于 runtime 中，当 webpack compiler 开始执行、解析和映射应用程序时，manifest 会保留形如 index.html 文件、各个 bundle 和各种资源模块的详细要点，这个数据集合称为 “manifest”，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。无论你选择哪种 模块语法，那些 import 或 require 语句现在都已经转换为 <code>__webpack_require__</code> 方法，此方法指向模块标识符(module identifier)。通过使用 manifest 中的数据，runtime 将能够检索这些标识符，找出每个标识符背后对应的模块。</p></li></ol><p>在稍低版本的 webpack 中加上了 contenthash 即使内容没变化，contenthash 也会改变。那这又是为什么呢？原因是因为在 webpack 中每个资源都是 chunk，每个 chunk 都会有对应的 chunk id(模块标识符 module identifier)，chunk id 的顺序是排列好的，新创建一个 js 资源然后在 index.js 中引用都会引起 chunk id 的顺序变化，顺序变化了就会导致 manifest 文件的变化，又因为 runtime 包含 manifest，所以  runtime 变化。 具体事例请参考: <a href="https://webpack.docschina.org/guides/caching" target="_blank" rel="noopener">https://webpack.docschina.org/guides/caching</a> 只需要将 runtime 提出即可解决该问题：<code>optimization: { runtimeChunk: { name: &#39;runtime&#39; } }</code></p><a id="more"></a><h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><p><code>描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和 export。</code> 这里注意只支持 es module 的语法，commonjs 不支持。具体原因请参考：<a href="https://segmentfault.com/a/1190000017878394" target="_blank" rel="noopener">深入 CommonJs 与 ES6 Module</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    devtools: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        usedExports: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sideEffects: <span class="literal">false</span> <span class="comment">// 这里指全部文件都要进行 tree-shaking</span></span><br><span class="line">    <span class="comment">// sideEffects: ["@babel/polyfill", "*.css"] // 指除了 polyfill css文件其他都进行 tree-shaking</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发环境中即使配置了 optimization 但是在打包后的 js 中代码还是保持原状，因为在开发环境中我们需要经常调试，如果直接使用 tree-shaking 会导致一些难以追踪的问题，所以 webpack 中在生产环境即使不配置 optimization 也会自动开启 tree-shaking，默认的 <code>sideEffects: false</code> , 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,</span><br><span class="line">    devtools: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sideEffects: <span class="literal">false</span> <span class="comment">// 这里指全部文件都要进行 tree-shaking</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code-Splitting"><a href="#Code-Splitting" class="headerlink" title="Code Splitting"></a>Code Splitting</h3><p>代码分割这个概念很早就出现了，只不过都是我们人为的拆分、分离代码。这并不是 webpack 独有的。</p><p>常用的代码分离方法有三种：</p><ul><li>入口起点：使用 entry 配置手动地分离代码。</li><li>静态导入：使用 SplitChunksPlugin 去重和分离 chunk。</li><li>动态导入：通过模块中的内联函数调用来分离代码。</li></ul><h4 id="配置多入口，会将入口处的文件依次放入-index-html-中"><a href="#配置多入口，会将入口处的文件依次放入-index-html-中" class="headerlink" title="配置多入口，会将入口处的文件依次放入 index.html 中"></a>配置多入口，会将入口处的文件依次放入 index.html 中</h4><h4 id="通过在文件头部-import-from-39-lodash-39-我们可以在-webpack-配置中添加-optimization-splitChunks-chunks-39-all-39-即可"><a href="#通过在文件头部-import-from-39-lodash-39-我们可以在-webpack-配置中添加-optimization-splitChunks-chunks-39-all-39-即可" class="headerlink" title="通过在文件头部 import _ from &#39;lodash&#39; 我们可以在 webpack 配置中添加 optimization: {splitChunks: { chunks: &#39;all&#39; }} 即可"></a>通过在文件头部 <code>import _ from &#39;lodash&#39;</code> 我们可以在 webpack 配置中添加 <code>optimization: {splitChunks: { chunks: &#39;all&#39; }}</code> 即可</h4><h4 id="异步代码（动态导入）文件无需配置-webpack-文件，webpack-会自动进行代码分离"><a href="#异步代码（动态导入）文件无需配置-webpack-文件，webpack-会自动进行代码分离" class="headerlink" title="异步代码（动态导入）文件无需配置 webpack 文件，webpack 会自动进行代码分离"></a>异步代码（动态导入）文件无需配置 webpack 文件，webpack 会自动进行代码分离</h4><h4 id="split-chunks"><a href="#split-chunks" class="headerlink" title="split chunks"></a>split chunks</h4><p>当我们在 <code>optimization: { splitChunks: {} }</code> 没有配置任何参数的时候这里其实执行了 webpack 的默认配置，配置如下：（具体请参考 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">SplitChunksPlugin</a>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 默认配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1 chunks: all | async | initial , 当为 async 时只支持异步引入的资源打包，当为 all 时异步、同步资源均可被打包。需要注意的是当为 all 时 cacheGroups 必须配置，不设置其中的属性 filename 的话打包出来的资源名为 vendors~main.js 意思是在 vendors 组下，资源入口为 main.js 我们可以设置 filename: ‘vendors.js’</p><p>2 minSize 是指当资源大于该值才向下执行，小于则不执行</p><p>3 maxSize 是指当资源大于该值时 webpack 尝试将资源用该值来分割为多份，一般不配置或为0即可</p><p>4 minChunks 是指当一个资源(jquery lodash…)被用了至少几次后才分割</p><p>5 maxAsyncRequests 是指同时加载资源的个数，假如这里设置5，当 webpack 分割第5块资源完毕后剩下的资源不会再分割</p><p>6 maxInitialRequests 指网站首页（入口文件）最多分割模块数</p><p>7 automaticNameDelimiter 指的是当没配置 filename 时打包出来的文件 <code>vendors~lodash.js</code> 中的～连接符</p><p>8 name 指的是是否让 cacheGroups 中配置的 filename 生效</p><p>9 cacheGroups 顾名思义是缓存组的意思，假设此时我同步导入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br></pre></td></tr></table></figure></p><p>如果没有这一项则会打包出来俩个 vendor 文件，有了该项后先打包 lodash 放入 vendros 组中，在打包 jquery 发现满足配置，再放入 vendors 中，生成一个 vendors 文件。那么 default 是干什么的呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./Header.js'</span></span><br></pre></td></tr></table></figure><p>lodash 与 jquery 均放入 vendors 组中，而 Header 并不在 node_modules 中所以放入 default 组中。如果此时没有 default 选项那么 Header 并不会被分割出来。<br>这里需要注意的是 vendors 中的 test 并不是只能匹配 node_modules，default 同理。</p><p>10 priority 指打包优先级，在上面的默认配置代码中 default 并没有配置 test，所以此时如果我们引入 <code>import _ from &#39;lodash&#39;</code> 是既满足 vendors 组又满足 default 组，那么 lodash 该去哪呢？此时比较 priority 的大小，放入数值大的组中。</p><p>11 reuseExistingChunk 指的是如果出现资源互相的情况那么如果被引用资源已经被打包过就直接使用，避免重复打包</p><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>1 在进行代码分割后打包文件会出现 <code>vendors~lodash.js</code> 这样的 vendor 前缀，如果想要去掉的话需要配置 <code>vendors: false, default: false</code></p><p>2 ⚠️ 处理同步引入资源打包（即 chunks 为 all 或者 innital）时不配置 cacheGroups 是不会将符合 cacheGroups 之前条件的资源分割打包出来</p><h3 id="lazy-loadinng"><a href="#lazy-loadinng" class="headerlink" title="lazy loadinng"></a>lazy loadinng</h3><p>先看俩段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> el = $(<span class="string">'&lt;div&gt;i7eo&lt;/div&gt;'</span>)</span><br><span class="line">$(<span class="string">'body'</span>).append(el)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">const</span> getJquery = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "jquery" */</span> <span class="string">'jquery'</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: $ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> $</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    getJquery().then(<span class="function"><span class="params">$</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> el = $(<span class="string">'&lt;div&gt;i7eo&lt;/div&gt;'</span>)</span><br><span class="line">        $(<span class="string">'body'</span>).append(el)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一段代码是同步执行，而第二段我们使用了异步加载的方式，虽然打包的时候 jquery 也被打包了出来但是进入页面第一时间并不会加载，只有当单击页面时才会加载，这就是异步加载（lazy loading）的好处。三大框架中动态路由也是运用了这样的技巧。第二段代码可以使用 async await 改写具体如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJquery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">default</span>: $ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "jquery" */</span> <span class="string">'jquery'</span>)</span><br><span class="line">    <span class="keyword">return</span> $</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    getJquery().then(<span class="function"><span class="params">$</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> el = $(<span class="string">'&lt;div&gt;i7eo&lt;/div&gt;'</span>)</span><br><span class="line">        $(<span class="string">'body'</span>).append(el)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="pre-fetch-pre-loading"><a href="#pre-fetch-pre-loading" class="headerlink" title="pre-fetch/pre-loading"></a>pre-fetch/pre-loading</h3><p>除了利用缓存来提高页面加载速度，那有什么办法在代码层面还提高呢？我们可以在 chrome 查看 coverage（<kbd>commande</kbd>+<kbd>shift</kbd>+<kbd>p</kbd>），观察代码使用率的情况从而找出未使用的代码做成异步加载来实现。</p><h5 id="思考这样一个场景，有一个管理后台，右上角有一个登陆按钮，单击后出现一个弹窗。"><a href="#思考这样一个场景，有一个管理后台，右上角有一个登陆按钮，单击后出现一个弹窗。" class="headerlink" title="思考这样一个场景，有一个管理后台，右上角有一个登陆按钮，单击后出现一个弹窗。"></a>思考这样一个场景，有一个管理后台，右上角有一个登陆按钮，单击后出现一个弹窗。</h5><p>这个时候我们可以把单击事件中的弹窗逻辑使用 import 改为异步代码，首次进入页面不加载，单击时再加载。但是如果逻辑较多或网络不稳定就会出现单击后弹窗延迟出现的可能。那么这个时候我们就可以使用 pre-fetch/pre-loading 来解决这个问题。实现方式也很简单，在 <code>import(/* webpackPrefetch:true */ &#39;./Popup.js&#39;)</code> 改写魔法注释就可以实现。<br>pre-fetch/pre-loading 的区别在于 fetch 是在页面加载完毕后加载，loading 是与页面的主逻辑资源一同加载。（注意浏览器对这二者的兼容性）</p><h3 id="shimming"><a href="#shimming" class="headerlink" title="shimming"></a>shimming</h3><p>根据官网的解释来看 shimming 是依赖预置的意思。举个例子：</p><h5 id="试想现在有一个老项目，里面有上千个页面，每个页面都得用到-juqery，现在我们要对该项目利用-webpack-改造，那么-juqery-的依赖应该怎么处理"><a href="#试想现在有一个老项目，里面有上千个页面，每个页面都得用到-juqery，现在我们要对该项目利用-webpack-改造，那么-juqery-的依赖应该怎么处理" class="headerlink" title="试想现在有一个老项目，里面有上千个页面，每个页面都得用到 juqery，现在我们要对该项目利用 webpack 改造，那么 juqery 的依赖应该怎么处理?"></a>试想现在有一个老项目，里面有上千个页面，每个页面都得用到 juqery，现在我们要对该项目利用 webpack 改造，那么 juqery 的依赖应该怎么处理?</h5><p>方法1: 在入口文件处将 jquery 挂载到 window 上。<code>window.$ = $</code><br>方法2: 配置 shimming，具体如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">            $: <span class="string">'jquery'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>官方推荐的方式是方法后2，具体可参考 <a href="https://webpack.docschina.org/guides/shimming/" target="_blank" rel="noopener">https://webpack.docschina.org/guides/shimming/</a><br>方法2中对 webpack 配置后其实也是在需要使用 $ 的文件头部自动注入 <code>import $ from &#39;jquery&#39;</code>。配合 split code 使用效果更佳</p><h4 id="在-es-module-文件中-this-是指向当前文件（module）的，如何使-this-指向-window-？"><a href="#在-es-module-文件中-this-是指向当前文件（module）的，如何使-this-指向-window-？" class="headerlink" title="在 es module 文件中 this 是指向当前文件（module）的，如何使 this 指向 window ？"></a>在 es module 文件中 this 是指向当前文件（module）的，如何使 this 指向 window ？</h4><p>1 安装 <code>npm i imports-loader -D</code></p><p>2 配置 loader<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;<span class="attr">loader</span>: <span class="string">'babel-loader'</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">loader</span>: <span class="string">'imports-loader?this=&gt;window'</span>&#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">// loader: 'babel-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h4><pre><code>1. import 中注释的写法称作 magic comment，具体请参考 [magic comment](https://webpack.docschina.org/api/module-methods/#magic-comments)，这里想使注释生效的话请安装 `@babel/plugin-syntax-dynamic-import`2. chunk 就是指的就是 dist 下的 js 资源3. 前端性能的提升从缓存角度来看提升是很有限的，着重还是要从代码角度来考虑。提一个点，对资源缓存只是针对非首次访问提速，那么第一次放访问应该怎么办？还是要从代码的角度多考虑</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Webpack4-0-学习笔记&quot;&gt;&lt;a href=&quot;#Webpack4-0-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Webpack4.0 学习笔记&quot;&gt;&lt;/a&gt;Webpack4.0 学习笔记&lt;/h3&gt;&lt;h3 id=&quot;浏览器-Caching&quot;&gt;&lt;a href=&quot;#浏览器-Caching&quot; class=&quot;headerlink&quot; title=&quot;浏览器 Caching&quot;&gt;&lt;/a&gt;浏览器 Caching&lt;/h3&gt;&lt;p&gt;当我们在打包资源的时候资源名以文件名命名，修改资源，接着普通刷新资源是不会改变的（其实是浏览器将上一次的资源缓存了）。解决方法就是在资源命名处加上 &lt;code&gt;[contenthash]&lt;/code&gt; 来解决这个问题。先来看几个概念:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;runtime:&lt;br&gt;在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。它包含：在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。在未使用 &lt;code&gt;optimization: { runtimeChunk: { name: &amp;#39;runtime&amp;#39; } }&lt;/code&gt; 时，runtime 被存放在入口的 main.js 中，只有使用后才会被单独打包出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;manifest:&lt;br&gt;存在于 runtime 中，当 webpack compiler 开始执行、解析和映射应用程序时，manifest 会保留形如 index.html 文件、各个 bundle 和各种资源模块的详细要点，这个数据集合称为 “manifest”，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。无论你选择哪种 模块语法，那些 import 或 require 语句现在都已经转换为 &lt;code&gt;__webpack_require__&lt;/code&gt; 方法，此方法指向模块标识符(module identifier)。通过使用 manifest 中的数据，runtime 将能够检索这些标识符，找出每个标识符背后对应的模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在稍低版本的 webpack 中加上了 contenthash 即使内容没变化，contenthash 也会改变。那这又是为什么呢？原因是因为在 webpack 中每个资源都是 chunk，每个 chunk 都会有对应的 chunk id(模块标识符 module identifier)，chunk id 的顺序是排列好的，新创建一个 js 资源然后在 index.js 中引用都会引起 chunk id 的顺序变化，顺序变化了就会导致 manifest 文件的变化，又因为 runtime 包含 manifest，所以  runtime 变化。 具体事例请参考: &lt;a href=&quot;https://webpack.docschina.org/guides/caching&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://webpack.docschina.org/guides/caching&lt;/a&gt; 只需要将 runtime 提出即可解决该问题：&lt;code&gt;optimization: { runtimeChunk: { name: &amp;#39;runtime&amp;#39; } }&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="webpack" scheme="https://i7eo.com/tags/webpack/"/>
    
      <category term="webpack4.0" scheme="https://i7eo.com/tags/webpack4-0/"/>
    
  </entry>
  
  <entry>
    <title>Webpack4.0 学习笔记（上）</title>
    <link href="https://i7eo.com/2020/03/03/Webpack4-0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8A.html"/>
    <id>https://i7eo.com/2020/03/03/Webpack4-0-学习笔记-上.html</id>
    <published>2020-03-03T15:04:45.000Z</published>
    <updated>2021-06-24T12:28:34.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Webpack4-0-学习笔记"><a href="#Webpack4-0-学习笔记" class="headerlink" title="Webpack4.0 学习笔记"></a>Webpack4.0 学习笔记</h3><h4 id="webpack是什么？"><a href="#webpack是什么？" class="headerlink" title="webpack是什么？"></a>webpack是什么？</h4><p>webpack 是模块打包工具，底层的文件处理逻辑全部由 node 完成</p><h3 id="支持的模块的规范"><a href="#支持的模块的规范" class="headerlink" title="支持的模块的规范"></a>支持的模块的规范</h3><p>webpack 支持多种模块规范，es6: import/export default | common.js: reuqire/moudle.export | AMD: define/require | styles file: @import | resource file: <code>&lt;img src=...&gt;</code>。在 webpack 发展初期只是打包 js，但随着发展后现在可以打包 js/css 等文章</p><a id="more"></a><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><h4 id="loader-就是-webpack-除-js-文件外帮助其识别、处理对应资源的-js-文件"><a href="#loader-就是-webpack-除-js-文件外帮助其识别、处理对应资源的-js-文件" class="headerlink" title="loader 就是 webpack 除 js 文件外帮助其识别、处理对应资源的 js 文件"></a>loader 就是 webpack 除 js 文件外帮助其识别、处理对应资源的 js 文件</h4><pre><code>1. file-loader 就是将图片资源复制粘贴进你配置的打包文件路径中，并将最新的符合你配置规则的图片名称（路径）返回，供代码使用2. [&apos;style-loader&apos;, &apos;css-loader&apos;] 先执行 css-loader 分析清楚 css 间的关系，并将其整合为一个 css 文件；style-loader 则将这个 css 文件挂载到 html 的 head 底部。3. css-loader 的 options 中设置 `importLoaders: 2` 指的是 index.scss 中 @import 了 a.scss，a.scss 中 @import 了 b.scss，如果不加这一项就会导致 b.scss 无法走 scss-loader 设置这个的目的就是为了确保 b.scss 先走 postcss-loader =》scss-loader 再走 css-loader =》style-loader4. css moudle 的配置需要在 css-loader 的 option 中设置 `modules: true` 即可使用 `style.xxx`</code></pre><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><h4 id="plugin-是-webpack-的插件接口，这个插件接口使-webpack-变得极其灵活。原理就是可以在-webpack-运行到某一时刻的时候，帮你做一些事情。（类比生命周期的钩子函数）"><a href="#plugin-是-webpack-的插件接口，这个插件接口使-webpack-变得极其灵活。原理就是可以在-webpack-运行到某一时刻的时候，帮你做一些事情。（类比生命周期的钩子函数）" class="headerlink" title="plugin 是 webpack 的插件接口，这个插件接口使 webpack 变得极其灵活。原理就是可以在 webpack 运行到某一时刻的时候，帮你做一些事情。（类比生命周期的钩子函数）"></a>plugin 是 webpack 的插件接口，这个插件接口使 webpack 变得极其灵活。原理就是可以在 webpack 运行到某一时刻的时候，帮你做一些事情。（类比生命周期的钩子函数）</h4><pre><code>1. html-webpack-plugin: 该插件将为你生成一个 HTML5 文件， 并将打包生成的 js 自动插入到这个 html 中。当 webpack 打包资源结束这个时刻开始工作2. clean-webpack-plugin: 该插件当 webpack 打包前这个时刻先删除之前的打包文件（dist）3. webpack.HotMoudleReplacementPlugin() HMR 指的是在不刷新 .html 文件下只更新（保留当前页面的状态包括js结果）变动的代码（样式等）对应的在 devserver 中需要开启 hot/hotOnly </code></pre><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><h4 id="devServer-是-webpack-在本地的开发环境下利用-http-proxy-middleware-amp-node-开启的一个服务器"><a href="#devServer-是-webpack-在本地的开发环境下利用-http-proxy-middleware-amp-node-开启的一个服务器" class="headerlink" title="devServer 是 webpack 在本地的开发环境下利用 http-proxy-middleware &amp; node 开启的一个服务器"></a>devServer 是 webpack 在本地的开发环境下利用 http-proxy-middleware &amp; node 开启的一个服务器</h4><p>这里主要说一下 proxy 的配置，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8080</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        hotOnly: <span class="literal">true</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'https://www.xxx.com'</span>,</span><br><span class="line">                secure: <span class="literal">false</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'info.json'</span>: <span class="string">'demo.json'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    cookie: <span class="string">'xxx'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>target 指接口转发的目标地址，如果目标使用了 https 协议，那么必须带上 secure: false，如果是 http，则可以不配置 secure 或者使其为 true</li><li>pathRewrite 常用应用场景是后台正在开发接口，但是你这边需要数据，后端给了一个 mock 数据的接口，但是在业务代码中你又不想修改 info.json 为 demo.json，所以在这里进行配置后期注释掉即可</li><li>changeOrigin 是修改发起请求的头信息，主要是为了防止转发的目标地址会对头信息做限制，导致拿不到数据</li><li>headers 中设置一些头信息、cookie 主要用来模拟登陆状态</li></ol><h3 id="webpack-执行方式"><a href="#webpack-执行方式" class="headerlink" title="webpack 执行方式"></a>webpack 执行方式</h3><ol><li>命令行执行：<a href="https://webpack.docschina.org/api/cli/" target="_blank" rel="noopener">https://webpack.docschina.org/api/cli/</a></li><li>node 中执行：<a href="https://webpack.docschina.org/api/node/" target="_blank" rel="noopener">https://webpack.docschina.org/api/node/</a></li></ol><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>1 npx 想要解决的主要问题，就是调用项目内部安装的模块</p><p>2 npx create-react-app my-react-app 避免全局安装模块</p><p>3 url-loader 中包含 file-loader 这俩者都能处理资源（图片、字体等）但是 url-loader 的好处就是可以转换将图片自动转为 base64 </p><p>4 output 中配置 cdn/oss 地址需要配置 publicPath 可以使用相关的 plugin 进行上传</p><p>5 sourcemap 是一个映射 src 到 dist 中代码的映射关系</p><p>6 需要注意的点是 babel:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方案只针对于业务代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// npm install --save-dev babel-loader @babel/core</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常情况下我们是这样配置 babel 的，但如果在代码中使用了低版本浏览器不兼容的 promise、map 等方法该怎么办？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// npm install --save @babel/polyfill</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        presets: [[<span class="string">'@babel/preset-env'</span>, &#123;</span><br><span class="line">            targets: &#123;</span><br><span class="line">                chrome: <span class="string">'67'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            useBuiltIns: <span class="string">'usage'</span></span><br><span class="line">        &#125;]]</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样配置后只需要在使用 es6 语法的地方 import "@babel/polyfill" 即可，但这</span></span><br><span class="line"><span class="comment">// 样的问题是原本可能只有10多k大小的文件引入polyfill后变成上百k，但其实代码里只用</span></span><br><span class="line"><span class="comment">// 到了 promise，这个时候就需要配置 useBuiltIns: 'usage' 这样就只会引入 </span></span><br><span class="line"><span class="comment">// promise 相关的 polyfill，targets 的作用是当浏览器小于某个版本时才进行 </span></span><br><span class="line"><span class="comment">// babel 的转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack4 中不用在文件中 import "@babel/polyfill" 配置 useBuiltIns: 'usage' 后 babel 自动加上 polyfill</span></span><br></pre></td></tr></table></figure></p><p>详情请参考：<a href="https://babeljs.io/docs/en/babel-preset-env#usebuiltins" target="_blank" rel="noopener">https://babeljs.io/docs/en/babel-preset-env#usebuiltins</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方案只针对于与业务无关的插件、类库等三方代码</span></span><br><span class="line"><span class="comment">// 为什么这样做？因为 polyfill 会将方法注入至全局，污染全局环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// npm install --save-dev babel-loader @babel/core</span></span><br><span class="line"><span class="comment">// npm install --save-dev @babel/plugin-transform-runtime</span></span><br><span class="line"><span class="comment">// npm install --save @babel/runtime-corejs</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">       plugins: [[<span class="string">'@babel/plugin-transform-runtime'</span>, &#123;</span><br><span class="line">           corejs: <span class="number">2</span>,</span><br><span class="line">           helper: <span class="literal">true</span>,</span><br><span class="line">           regenerator: <span class="literal">true</span>,</span><br><span class="line">           useESModules: <span class="literal">false</span></span><br><span class="line">       &#125;]]</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉代码中的 import "@babel/polyfill" 然后执行即可</span></span><br><span class="line"><span class="comment">// 如果 options 中配置参数较多可以将 options 对象直接提出放至项目根目录的 .babelrc 中即可</span></span><br></pre></td></tr></table></figure><p>详情请参考：<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">https://babeljs.io/docs/en/babel-plugin-transform-runtime</a></p><p>7 所有 loader 或者 loader 中的 options 配置执行顺序都是从下往上、从右往左</p><p>8 开启了 hotOnly: true 后局部更新后页面不会自动刷新</p><p>9 开启 devserver 后打包文件存在于内存中，想查看的话可以通 <code>npx webpack --config webpack.dev.config</code> 来避开 <code>webpack-dev-server --config webpack.dev.config</code> </p><p>10 前端spa路由需要注意的一个点是要配置 <code>historyApiFallback: true</code> 这样才能保证在地址栏输入路径后不被 devServer 的代理当作接口转发走</p><p>11 resolve 的配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        <span class="comment">// 配置 extensions 可以免去写文件后缀名，但是尽量不要也将资源类文件的后缀配进来（因为每次查找文件会使用node的fs模块，性能会受影响）</span></span><br><span class="line">        extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>],</span><br><span class="line">        <span class="comment">// 配置 mainFiles 可以在引入时只写目录 eg: `import Child from './src/child'`，这样 webpack 会先找 child 目录下的 indexjs 没有的话会找 childjs</span></span><br><span class="line">        mainFiles: [<span class="string">'index'</span>, <span class="string">'child'</span>],</span><br><span class="line">        <span class="comment">// 配置 alias 就可以使用别名</span></span><br><span class="line">        alias: &#123;</span><br><span class="line">            i7eo: path.resolve(__dirname, <span class="string">'./src/child'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Webpack4-0-学习笔记&quot;&gt;&lt;a href=&quot;#Webpack4-0-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Webpack4.0 学习笔记&quot;&gt;&lt;/a&gt;Webpack4.0 学习笔记&lt;/h3&gt;&lt;h4 id=&quot;webpack是什么？&quot;&gt;&lt;a href=&quot;#webpack是什么？&quot; class=&quot;headerlink&quot; title=&quot;webpack是什么？&quot;&gt;&lt;/a&gt;webpack是什么？&lt;/h4&gt;&lt;p&gt;webpack 是模块打包工具，底层的文件处理逻辑全部由 node 完成&lt;/p&gt;
&lt;h3 id=&quot;支持的模块的规范&quot;&gt;&lt;a href=&quot;#支持的模块的规范&quot; class=&quot;headerlink&quot; title=&quot;支持的模块的规范&quot;&gt;&lt;/a&gt;支持的模块的规范&lt;/h3&gt;&lt;p&gt;webpack 支持多种模块规范，es6: import/export default | common.js: reuqire/moudle.export | AMD: define/require | styles file: @import | resource file: &lt;code&gt;&amp;lt;img src=...&amp;gt;&lt;/code&gt;。在 webpack 发展初期只是打包 js，但随着发展后现在可以打包 js/css 等文章&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="webpack" scheme="https://i7eo.com/tags/webpack/"/>
    
      <category term="webpack4.0" scheme="https://i7eo.com/tags/webpack4-0/"/>
    
  </entry>
  
  <entry>
    <title>译文: Virtual DOM is pure overhead</title>
    <link href="https://i7eo.com/2019/08/10/%E8%AF%91%E6%96%87-Virtual-DOM-is-pure-overhead.html"/>
    <id>https://i7eo.com/2019/08/10/译文-Virtual-DOM-is-pure-overhead.html</id>
    <published>2019-08-10T08:29:09.000Z</published>
    <updated>2021-02-27T04:27:36.912Z</updated>
    
    <content type="html"><![CDATA[<p>本文为译文，原文地址：</p><blockquote><p><a href="https://www.sveltejs.cn/blog/virtual-dom-is-pure-overhead" target="_blank" rel="noopener">Virtual DOM is pure overhead</a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您在最近几年中使用过JavaScript框架，那么您可能已经听说过“虚拟DOM很快”这一短语，通常被说来意味着它比真实DOM快。这是一个令人惊讶的前端技术概念。例如，人们问Svelte在不使用虚拟DOM时如何更快。（作者在反讽🤔）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是时候让我们仔细揣摩揣摩了。</p><h3 id="什么是虚拟-dom-？"><a href="#什么是虚拟-dom-？" class="headerlink" title="什么是虚拟 dom ？"></a>什么是虚拟 dom ？</h3><a id="more"></a><p>在许多框架中，你可以通过 <code>render</code> 来构建一个应用，下面用 react 来当作示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloMessage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">      Hello &#123;props.name&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>你也可以不使用 jsx 来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloMessage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">'greeting'</span> &#125;,</span><br><span class="line">    <span class="string">'Hello '</span>,</span><br><span class="line">    props.name</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是相同的，在这其中有一个对象会向我们展示当前的页面长什么样，而这个对象就是虚拟DOM。每一次你的应用中的状态更新（例如：name），框架都会创建一个新的状态。框架的任务就是将新状态与旧状态仔细对比，找到变化并将他们输出为真实的DOM。</p><h3 id="虚拟-dom-更快这个概念是怎么开始的-？"><a href="#虚拟-dom-更快这个概念是怎么开始的-？" class="headerlink" title="虚拟 dom 更快这个概念是怎么开始的 ？"></a>虚拟 dom 更快这个概念是怎么开始的 ？</h3><p>关于虚拟DOM性能的误解可追溯到React的发布。在<a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">反思最佳实践</a>开创性的2013通话由原阵营的核心团队成员皮特·亨特，我们学到以下几点：</p><blockquote><p>这实际上是非常快的，主要是因为大多数DOM操作往往很慢。DOM上有很多性能工作，但是大多数DOM操作往往会丢帧。</p></blockquote><p>但是等一下！如果将其与效率较低的框架比较那肯定是快的。与其如此，不如这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onEveryStateChange(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerHTML = renderMyApp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（疯狂吐槽 🤔 ，总结一下作者认为虚拟DOM的快可以用上述代码概括，那就是状态变化，将重新编译好的jsx完全赋值给 innerHTML …）</p><p>皮特在不久后澄清…</p><blockquote><p>React 并不是魔术，就像将 c 写入汇编后击败 c 编译器一样。你也可以在你需要的情况下使用原生DOM和 API 进行操作从而击败 react。使用C或Java或JavaScript可以将性能提高一个数量级，因此您不必在意平台的细节。使用 react 你甚至可以不考虑性能而构建应用，因为它默认是快速的。</p></blockquote><p>…但这个解释我并不买账</p><h3 id="因此…-虚拟DOM是慢的么？"><a href="#因此…-虚拟DOM是慢的么？" class="headerlink" title="因此… 虚拟DOM是慢的么？"></a>因此… 虚拟DOM是慢的么？</h3><p>也不能这么说。只能说 虚拟DOM在通常情况下足够快 ，但有一些注意事项。</p><p>React 最初的承诺是当你修改状态重新渲染整个应用时不用担心性能。我认为这并不正确，如果真如此，那为什么还会提供 <code>shouldComponentUpdate</code> 这样的函数还跳过对组件的更新。</p><p>即使有了 <code>shouldComponentUpdate</code> ，一次完成更新整个应用程序的虚拟DOM的工作量仍然很大。不久前，React团队推出了一种叫做React Fiber的东西，它可以将更新分成较小的块。这意味着（除其他事项外）更新不会长时间阻塞主线程，尽管它不会减少工作总量或更新所花费的时间。</p><h3 id="开销在哪里？"><a href="#开销在哪里？" class="headerlink" title="开销在哪里？"></a>开销在哪里？</h3><p>重点在于 <code>diff</code> 。您必须先将新的虚拟DOM与先前的快照进行比较，然后才能对真实DOM应用更改。以前面的HelloMessage 示例为例，假设 <code>name</code> 从 world 改为 everybody。</p><ol><li>两个快照都包含一个元素。在两种情况下都是 <code>&lt;div&gt;</code> ，这意味着我们可以保留相同的DOM节点</li><li>我们列举了新旧属性上的所有属性， <code>&lt;div&gt;</code> 以查看是否需要更改，添加或删除任何属性。在这两种情况下，我们都有一个属性 className 的值为”greeting”</li><li>到元素中，我们看到文本已更改，因此我们需要更新真实的DOM。</li></ol><p>在这三步中，只有第3步对于 DOM 是有影响的。而这些都可以用下面这个代码代替：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed.name) &#123;</span><br><span class="line">  text.data = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这几乎完全是Svelte生成的更新代码。与传统的UI框架不同，Svelte是一个编译器，它在构建时就知道应用程序中的情况如何发生变化，而不必等着在运行时进行工作。）</p><h3 id="为什么框架要使用虚拟DOM？"><a href="#为什么框架要使用虚拟DOM？" class="headerlink" title="为什么框架要使用虚拟DOM？"></a>为什么框架要使用虚拟DOM？</h3><p>重要的是要了解虚拟DOM不是功能。这是达到目的的一种手段，最终是声明性的，状态驱动的UI开发。虚拟DOM非常有价值，因为它使您无需考虑状态转换即可构建应用程序，并且性能通常足够好。这意味着更少的错误代码，而将更多的时间花费在创造性的任务上，而不是乏味的工作上。</p><p>但事实证明，我们无需使用虚拟DOM就可以实现类似的编程模型-这就是Svelte的用武之地。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>虚拟DOM不是功能。这是达到目的的一种手段</li><li>场景不同需求不同</li></ol><p>尤大的回答也差不多，具体可见：<a href="https://www.zhihu.com/question/31809713/answer/1735884666" target="_blank" rel="noopener">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为译文，原文地址：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sveltejs.cn/blog/virtual-dom-is-pure-overhead&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Virtual DOM is pure overhead&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果您在最近几年中使用过JavaScript框架，那么您可能已经听说过“虚拟DOM很快”这一短语，通常被说来意味着它比真实DOM快。这是一个令人惊讶的前端技术概念。例如，人们问Svelte在不使用虚拟DOM时如何更快。（作者在反讽🤔）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;是时候让我们仔细揣摩揣摩了。&lt;/p&gt;
&lt;h3 id=&quot;什么是虚拟-dom-？&quot;&gt;&lt;a href=&quot;#什么是虚拟-dom-？&quot; class=&quot;headerlink&quot; title=&quot;什么是虚拟 dom ？&quot;&gt;&lt;/a&gt;什么是虚拟 dom ？&lt;/h3&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="虚拟Dom" scheme="https://i7eo.com/tags/%E8%99%9A%E6%8B%9FDom/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出react&amp;redux笔记</title>
    <link href="https://i7eo.com/2019/06/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAreact-redux%E7%AC%94%E8%AE%B0.html"/>
    <id>https://i7eo.com/2019/06/11/深入浅出react-redux笔记.html</id>
    <published>2019-06-11T11:01:06.000Z</published>
    <updated>2021-02-01T07:09:23.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深入浅出react-amp-redux笔记"><a href="#深入浅出react-amp-redux笔记" class="headerlink" title="深入浅出react&amp;redux笔记"></a>深入浅出react&amp;redux笔记</h3><ol><li>高内聚（js、jsx、css） 低耦合（弱化不同组件间的关系）</li><li><p>react组件数据</p><ol><li><p>生命周期 (执行顺序如序号顺序)</p><ul><li>装载过程<ol><li>constructor (初始化state，绑定this。当然也可以不绑定，在class中使用声明变量&amp;尖头函数的写法)</li><li>getlnitialState (React.createClass中使用)</li><li>getDefaultProps (React.createClass中使用)</li><li>componentWillMount (这个时候没有任何渲染出来的结果，即使调用this.setState 修改状态也不会引发重新绘制换句话说，所有可以在这个 component­WillMount 中做的事情，都可以提前到 constructor 中间去做)</li><li>render (完全根据 this.state 和 this.props 来决定返回的结果，而且不要产生任何副作用。在 render 函数中去调用 this.setState 毫无疑问是错误的，因为一个纯函数不应该引起状态的改变)</li><li>componentDidMount (组件已经被装载到 DOM 树上了,这个时候我们可以通过请求来填充组件的内容、使用三方代码获取dom, 需要注意的是该生命周期不会在一个render后立即执行，而是在所有子组件render结束后执行，这是因为render只返回jsx对象并不往dom树上装载内容，具体的内容装载是react经过vm后才决定的)</li></ol></li><li>更新过程<ol><li>shouldComponentUpdate (如果这个函数返回 true，那就会继续更新过程，接下来调用 render 函数;反之，如果得到 一个 false，那就立刻停止更新过程，也就不会引发后续的渲染了)</li><li>componentWillReceiveProps (只要是父组件的 render 函数被调用，在 render 函数里面被谊染的子组件就会经历更新过程，不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps 函数, 子组件中的 setstate 不会调用该方法)</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol></li><li>卸载过程<ol><li>componentWillUnmount (通常解绑事件、定时器等)</li></ol></li></ul><a id="more"></a></li><li><p>propTypes 建议在开发环境可加，生产环境通过babel-react-optimize去掉</p></li><li><p>初始化state：</p><ol><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: props.initValue || <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: props.initValue</span><br><span class="line">&#125;</span><br><span class="line">xxx.defaultProps = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>prop&amp;state的对比：</p><ol><li>prop 用于定义外部接口， state 用于记录内部状态;</li><li>prop 的赋值在外部世界使用组件时， state 的赋值在组件内部;</li><li>组件绝不应该改变 prop 的值（要严格遵守单向数据流原则，保证 ui=render(data) 这个函数无任何副作用），而 state存在的目的就是让组件来改变的 。</li></ol></li></ol></li><li><p>模块化<br> 用 React和 Redux来构建前端网页应用，这两者都奉 行这样一个公式 UI=render(state) 来产生用户界面。 React才适合于视图层面的东西，但是不能指望靠React来管理应用的状态， Redux才适合担当应用状态的管理工作。</p><ul><li><p>从架构出发，当我们开始一个新的应用的时候，有几件事情是一定要考虑清楚的：</p><ol><li><p>代码文件的组织结构</p><ul><li><p>按角色组织：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reducers/</span><br><span class="line">  todoReducer.js</span><br><span class="line">  filterReducer.js</span><br><span class="line">actions/ </span><br><span class="line">  todoActions.js</span><br><span class="line">  filterActions.js</span><br><span class="line">components/</span><br><span class="line">  todoList.js</span><br><span class="line">  todoItem.js</span><br><span class="line">  filter.js</span><br><span class="line">containers/</span><br><span class="line">  todoListContainer.js</span><br><span class="line">  todoiternContainer.js</span><br><span class="line">  filterContainer.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唯一的缺点是新增功能需要在不同的文件夹下切换并且创建新文件</span></span><br></pre></td></tr></table></figure></li><li><p>接功能组织：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">todoList/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br><span class="line">filter/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模块接口</p><ul><li><p>常规导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> ’ .. /todoList/actions ’;</span><br><span class="line"><span class="keyword">import</span> container <span class="keyword">as</span> TodoList <span class="keyword">from</span> ’../todoList/views/container’;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种写法当然能够完成功能，但是却非常不合理，因为这让 filter模块依赖于 todoList模块的内部结构，而且直接伸手到 todoList 内部去导人想要的部分</span></span><br></pre></td></tr></table></figure></li><li><p>统一入口导入 (index.js)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> ’. /actions.js ’;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> ’. /reducer.js’;</span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> ’./views/container.js ’;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;actions, reducer, view&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用如下</span></span><br><span class="line"><span class="keyword">import</span> &#123;actions , reducer, view <span class="keyword">as</span> TodoList&#125; <span class="keyword">from</span> ’../todoList’</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Store 的状态树设计</p><ul><li>一个模块控制一个状态节点</li><li>避免冗余数据 (数据一致性)</li><li>树形结构扁平，避免出现以下情况：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = state.A &amp;&amp; state.A.B &amp;&amp; state.A.B.C &amp;&amp; state.A.B.C.D;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li><li><p>组件性能优化</p><ol><li>容器组件与傻瓜组件 (让一个组件只专注做一件事，容器组件进行数据处理然后将数据传入傻瓜组件，傻瓜组件只负责渲染)</li><li>使用 shouldcomponentupdate 来避免不必要的组件更新（重新渲染）</li><li>那么如何查看 chrome 中 react 性能表现？参考资料如下：<ul><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization" target="_blank" rel="noopener">Profiling React Performance with React 16 and Chrome DevTools.</a></li><li><a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab" target="_blank" rel="noopener">使用 Chrome Performance 标签分析组件</a></li></ul></li></ol></li><li><p>高阶组件<br> |  | 特点 | 区别 |<br> | :—–| :—-: | :—-: |<br> | 代理方式的高阶组件 | 操纵 prop / 访问 ref / 抽取状态 / 包装组件 | 新组件、参数组件都要经历各自的生命周期 |<br> | 继承方式的高阶组件 | 操纵 prop / 操纵生命周期函数 | 只有一个生命周期（super.render()） |</p></li><li><p>redux</p><ol><li>redux基本原则：<ul><li>唯一数据源(Single Source ofTruth)</li><li>保持状态只读( State is read-only)</li><li>数据改变只能通过纯函数完成( Changes are made with pure functions)</li></ul></li><li>保持数据的唯一性 (context &amp; react-redux)</li><li>react-redux 两个最主要功能:<ul><li>connect: 连接容器组件和傻瓜组件;</li><li>Provider: 提供包含 store 的 context (context 完全可以实现 provider 但是 react-redux 中的 provider 包含三个函数：subscribe、dispatch、getState。react-redux 定义了 Provider 的 componentWillReceiveProps 函数，在 React组件的生命周期中， componentWillReceiveProps 函数在每次重新渲染时都会调用到，react­ redux 在 componentWillReceiveProps 函数中会检查这一次渲染时代表 store 的 prop 和上 一次的是否一样。 如果不一样，就会给出警告，这样做是为了避免多次渲染用了不同的 Redux Store。 每个 Redux 应用只能有一个 Redux Store，在整个 Redux 的生命周期中都应该保持 Store 的唯一性)</li></ul></li></ol></li></ol><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol><li>在 jsx 用直接把匿名函数赋值的方法，看起来非常简洁而且方便，其实并不是值得提倡的方法。因为每次渲染都会创造一个新的匿名方法对象 ，而且有可能引发子组件不必要的重新渲染。</li><li>render 和 shouldComponentUpdate 函数，也是 React 生命周期函数中唯二两个要求有返回结果的函数。 render 函数的返回结果将用于构造 DOM 对象，而 shouldComponent­Update 函数返回一个布尔值，告诉 React 库这个组件在这次更新过程中是否要继续。</li><li>为什么 react 中大多数的调用通常是闭包形式的多层调用？ 因为遵从一个函数只做一件事的原则<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(Counter)</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">"function"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> action(dispatch , getState , extraArgument);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 这是 thunk 的源码实现，只是单纯的判断了 action 类型，具体做了如下操作：</span></span><br><span class="line"><span class="comment"> * 1. 调用 dispatch派发出一个新 action对象;</span></span><br><span class="line"><span class="comment"> * 2. 调用 getState获得当前ReduxStore上的状态;</span></span><br><span class="line"><span class="comment"> * 3. 调用next告诉Redux当前中间件工作完毕，让Redux调用下一个中间件;</span></span><br><span class="line"><span class="comment"> * 4. 访问 action对象 action上的所有数据;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>触发 re-render 的方式：</p><ul><li>setState</li><li>props 改变</li><li>forceupdate</li></ul></li><li><p>fetch认为只要服务器返回一个合法的 HTTP 响应就算成功，就会调用 then提供的回调函数，即使这个HTTP响应的状态码是表示出错了的400或者500。因为 fetch 的这个特点，所以我们在 then 中，要做的第一件事就是检查传人参数 response status 字段，只有 status 是代表成功的 200 的时候才继续，否则以错误处理 。</p></li><li>组件-action-store-reducers关系图：</li></ol><p><img src="/2019/06/11/深入浅出react-redux笔记/i7eo_25f291ba15777c663644a0f507fde1af.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;深入浅出react-amp-redux笔记&quot;&gt;&lt;a href=&quot;#深入浅出react-amp-redux笔记&quot; class=&quot;headerlink&quot; title=&quot;深入浅出react&amp;amp;redux笔记&quot;&gt;&lt;/a&gt;深入浅出react&amp;amp;redux笔记&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;高内聚（js、jsx、css） 低耦合（弱化不同组件间的关系）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react组件数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生命周期 (执行顺序如序号顺序)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装载过程&lt;ol&gt;
&lt;li&gt;constructor (初始化state，绑定this。当然也可以不绑定，在class中使用声明变量&amp;amp;尖头函数的写法)&lt;/li&gt;
&lt;li&gt;getlnitialState (React.createClass中使用)&lt;/li&gt;
&lt;li&gt;getDefaultProps (React.createClass中使用)&lt;/li&gt;
&lt;li&gt;componentWillMount (这个时候没有任何渲染出来的结果，即使调用this.setState 修改状态也不会引发重新绘制换句话说，所有可以在这个 component­WillMount 中做的事情，都可以提前到 constructor 中间去做)&lt;/li&gt;
&lt;li&gt;render (完全根据 this.state 和 this.props 来决定返回的结果，而且不要产生任何副作用。在 render 函数中去调用 this.setState 毫无疑问是错误的，因为一个纯函数不应该引起状态的改变)&lt;/li&gt;
&lt;li&gt;componentDidMount (组件已经被装载到 DOM 树上了,这个时候我们可以通过请求来填充组件的内容、使用三方代码获取dom, 需要注意的是该生命周期不会在一个render后立即执行，而是在所有子组件render结束后执行，这是因为render只返回jsx对象并不往dom树上装载内容，具体的内容装载是react经过vm后才决定的)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;更新过程&lt;ol&gt;
&lt;li&gt;shouldComponentUpdate (如果这个函数返回 true，那就会继续更新过程，接下来调用 render 函数;反之，如果得到 一个 false，那就立刻停止更新过程，也就不会引发后续的渲染了)&lt;/li&gt;
&lt;li&gt;componentWillReceiveProps (只要是父组件的 render 函数被调用，在 render 函数里面被谊染的子组件就会经历更新过程，不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps 函数, 子组件中的 setstate 不会调用该方法)&lt;/li&gt;
&lt;li&gt;componentWillUpdate&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;componentDidUpdate&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;卸载过程&lt;ol&gt;
&lt;li&gt;componentWillUnmount (通常解绑事件、定时器等)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="React" scheme="https://i7eo.com/categories/React/"/>
    
    
      <category term="React" scheme="https://i7eo.com/tags/React/"/>
    
      <category term="Redux" scheme="https://i7eo.com/tags/Redux/"/>
    
      <category term="中间件" scheme="https://i7eo.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>三方接入踩坑集合</title>
    <link href="https://i7eo.com/2019/05/21/%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5%E8%B8%A9%E5%9D%91%E9%9B%86%E5%90%88.html"/>
    <id>https://i7eo.com/2019/05/21/三方接入踩坑集合.html</id>
    <published>2019-05-21T13:41:08.000Z</published>
    <updated>2020-05-07T09:18:02.670Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在做跨境电商网站的时候避免不了接入三方的支付、统计等代码来进行一系列的数据统计、分析、引流等。这里记录一下自己踩过的坑。</p><h3 id="worldpay俩方"><a href="#worldpay俩方" class="headerlink" title="worldpay俩方"></a>worldpay俩方</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前不论是 <code>paypal</code> 还是 <code>worldpay</code> 接支付都是跳转到三方页面，因为中间跳转的这一步会导致部分用户弃单，转化率下降。根据我们自己的统计和与海外客户沟通来看得到的结论时尽量不要跳转，所以要把之前的三方改为俩方，即页面中<code>嵌套 iframe</code> 的方式。</p><ol><li>引入资源css/js/helper.html</li><li>创建目标div</li><li>执行setup</li></ol><a id="more"></a><p>具体如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My test page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">href</span>=<span class="string">'https://payments.worldpay.com/resources/hpp/integrations/embedded/css/hpp-embedded-integration-library.css'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://payments.worldpay.com/resources/hpp/integrations/embedded/js/hpp-embedded-integration-library.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'custom-html'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> customOptions = &#123;</span></span><br><span class="line"><span class="javascript">        type: <span class="string">'lightbox'</span>,</span></span><br><span class="line"><span class="javascript">        iframeIntegrationId: <span class="string">'libraryObject'</span>,</span></span><br><span class="line"><span class="javascript">        iframeHelperURL: <span class="string">'https://www.example.com/helper.html'</span>,</span></span><br><span class="line"><span class="javascript">        iframeBaseURL: <span class="string">'https://www.example.com'</span>,</span></span><br><span class="line"><span class="javascript">        url: <span class="string">'https://payments.worldpay.com/ngpp/integration/wpg/corporate?OrderKey=YOUR_ORDER_KEY&amp;Ticket=YOUR_TICKET_ID'</span>,</span></span><br><span class="line"><span class="javascript">        target: <span class="string">'custom-html'</span>,</span></span><br><span class="line"><span class="javascript">        accessibility: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        debug: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">        language: <span class="string">'en'</span>,</span></span><br><span class="line"><span class="javascript">        country: <span class="string">'gb'</span>,</span></span><br><span class="line"><span class="javascript">        preferredPaymentMethod: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">        successURL: <span class="string">'https://www.example.com/success'</span>,</span></span><br><span class="line"><span class="javascript">        cancelURL: <span class="string">'https://www.example.com/cancel'</span>,</span></span><br><span class="line"><span class="javascript">        failureURL: <span class="string">'https://www.example.com/failure'</span>,</span></span><br><span class="line"><span class="javascript">        pendingURL: <span class="string">'https://www.example.com/pending'</span>,</span></span><br><span class="line"><span class="javascript">        errorURL: <span class="string">'https://www.example.com/error'</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//initialise the library and pass options</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> libraryObject = <span class="keyword">new</span> WPCL.Library();</span></span><br><span class="line"><span class="undefined">    libraryObject.setup(customOptions);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>需要注意的点如下：</p><ol><li>helper.html 必须放在与当前站点同源的环境中（必须符合同源策略），以我们的 <code>java项目</code> 来说，我把 helper.html 放在了 static 目录下，这样避免经过后端的拦截器出现访问不到的情况。结果放在 <code>iframeHelperURL</code> 属性处即可: <code>iframeHelperURL: window.location.origin + &#39;/static/html/helper.html&#39;</code> </li><li>可以在目标 div 中加入 loading 效果，因为 iframe 生成后会直接替换目标 div 中的内容： </li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'custom-html'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>=&gt;<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'custom-html'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"worldpay-loading"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sp sp-circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>示例代码中的配置对象 <code>customOptions</code> 中无 <code>inject</code> 属性而且文档中 <code>inject</code> 也是非必填的，但是 <code>hpp-embedded-integration-library.js</code> 这个资源中对这个属性没有做任何空值处理：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.options.inject === <span class="string">'immediate'</span>) &#123;</span><br><span class="line">    injectIframeToTarget.call(self);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.options.inject === <span class="string">'onload'</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        writeMessage.call(self, <span class="string">'The browser supports addEventListener'</span>);</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, self.onloadInject, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        writeMessage.call(self, <span class="string">'The  browser supports attachEvent'</span>);</span><br><span class="line">        <span class="built_in">window</span>.attachEvent(<span class="string">'onload'</span>, self.onloadInject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeMessage.call(self, <span class="string">'ERROR: the  browser does not support an onload event-handler'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.options.inject === <span class="string">'default'</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        injectIframeToTarget.call(self);</span><br><span class="line">        <span class="keyword">if</span> (e &amp;&amp; e.target &amp;&amp; e.target != <span class="built_in">document</span>) &#123;</span><br><span class="line">            self.isFakeLoadEvent = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    writeMessage.call(self, <span class="string">'ERROR: accepted parameters are immediate, onload, default'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到如果不配置 <code>inject: immediate|default|onload</code> 的话，这里直接抛出错误，但是这个时候 iframe 并未生成出来所以当前网页的控制台中不会出现任何信息，所以应该将 <code>inject: immediate</code> 加入到配置对象 <code>customOptions</code> 中。</p><p>参考资料：</p><ul><li><a href="https://payments.worldpay.com/resources/hpp/integrations/embedded/doc/#top" target="_blank" rel="noopener">worldpay iframe &amp; lightbox 帮助文档</a></li></ul><h3 id="paypal-smart-button"><a href="#paypal-smart-button" class="headerlink" title="paypal smart button"></a>paypal smart button</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做这个的起因是 paypal 来我司吹了一番 <code>smart button（sbp）</code> 对于跨境电商公司是多么的好（自动切换不同语种、避免多次跳转、balblabla）结果真正实施起来出现的 bug 还都是导致 iframe 未生成或者 支付失败的重大 bug ，感觉 sbp 还处于实验阶段。。。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你只需在 pc 上使用 sbp 那么 ie 8+ 没问题，如果要考虑手机、pc、平板等多端环境时，强烈建议暂时不要使用。附上一张考虑多端环境下的 issue 扯皮截图：</p><p><img src="/2019/05/21/三方接入踩坑集合/i7eo_df4a2176f1f9163f1d158cffcd294291.png" alt="spb-bug-issue"></p><p>接入 pc 的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//www.paypal.com/sdk/js?client-id=$SITE.paypalClientId&amp;commit=true&amp;locale=$LANG.spbLang&amp;currency=$CURRENCY.code&amp;disable-funding=credit"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(!<span class="built_in">window</span>.paypal) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'spb error: .js file has some errors when loading'</span>);</span></span><br><span class="line"><span class="javascript">&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="undefined">    paypal.Buttons(&#123;</span></span><br><span class="line"><span class="undefined">        style: &#123;</span></span><br><span class="line"><span class="javascript">            size: <span class="string">'responsive'</span>,</span></span><br><span class="line"><span class="javascript">            layout: <span class="string">'horizontal'</span>, <span class="comment">// vertical</span></span></span><br><span class="line"><span class="javascript">            tagline: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            label: <span class="string">'checkout'</span>,</span></span><br><span class="line"><span class="javascript">            shape: <span class="string">'rect'</span>,</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        commit: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        onInit: <span class="function"><span class="keyword">function</span>(<span class="params">data, actions</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'onInit, please wait ...'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        createOrder: <span class="function"><span class="keyword">function</span>(<span class="params">data, actions</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'createOrder, please wait ...'</span>);</span></span><br><span class="line"><span class="javascript">             <span class="comment">// return fetch(ajaxUrl, &#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     method: 'get'</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// .then(data =&gt; data.json())</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// .then(function(res) &#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     return resolveFunction(res);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// &#125;);</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                $.get(ajaxUrl, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(res.code === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> token = res.data.redirectUrl.split(<span class="string">'token='</span>)[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">                        result = $.extend(res.data, &#123;<span class="attr">token</span>: token&#125;)</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span>(token) &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">console</span>.log(<span class="string">'send ajax'</span>);</span></span><br><span class="line"><span class="undefined">                            resolve(token);</span></span><br><span class="line"><span class="javascript">                        &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">window</span>.location.href = location;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="javascript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">window</span>.location.href = res.msg || location;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;)</span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// Finalize the transaction</span></span></span><br><span class="line"><span class="javascript">        onApprove: <span class="function"><span class="keyword">function</span>(<span class="params">data, actions</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'onApprove, please wait ...'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> returnUrl = result.returnUrl + <span class="string">"&amp;paymentId="</span> + data.paymentID + <span class="string">"&amp;token="</span> + result.token + <span class="string">"&amp;PayerID="</span> + data.payerID;</span></span><br><span class="line"><span class="undefined">            actions.redirect(returnUrl);</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        onCancel: <span class="function"><span class="keyword">function</span>(<span class="params">data, actions</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        onError: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.error(<span class="string">'smart payment button has some errors. like: '</span>, err);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="built_in">window</span>.location = result.failedUrl + <span class="string">'&amp;err='</span> + err;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;).render(spbEl);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的点如下：</p><ol><li>sbp 在 createOrder 这一步发送请求的时候要么对普通请求进行 promise 化，要么直接使用 fetch。否则会出现 iframe 中一直 loading 的情况</li></ol><p>参考资料：</p><ul><li><a href="https://developer.paypal.com/docs/checkout/" target="_blank" rel="noopener">Smart Payment Buttons Overview</a></li></ul><h3 id="certona"><a href="#certona" class="headerlink" title="certona"></a>certona</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;certona接入应该是我做过最方便快捷的了。</p><p>node环境接入如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 当前页面：404.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">include</span>('<span class="attr">.</span>/<span class="attr">analysis</span>/<span class="attr">certona.html</span>', &#123;<span class="attr">pageType:</span> '<span class="attr">404</span>'&#125;)%&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 当前页面：certona.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//edge1.certona.net/YOUR_TAG/scripts/resonance.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">id</span>=<span class="string">"Certona"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&lt;% <span class="keyword">if</span>(<span class="keyword">typeof</span>(pageType) != <span class="string">'undefined'</span>) &#123; %&gt;</span></span><br><span class="line"><span class="javascript">    &lt;% <span class="keyword">if</span>(pageType == <span class="string">'404'</span>) &#123; %&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> certona = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"pagetype"</span> : <span class="string">"404ERROR"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"devicetype"</span> : <span class="string">"DESKTOP"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"recommendations"</span> : <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pinterest"><a href="#pinterest" class="headerlink" title="pinterest"></a>pinterest</h3><ol><li>添加主代码与 pagevisti 追踪</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">if</span>(!<span class="built_in">window</span>.pintrk)&#123;<span class="built_in">window</span>.pintrk=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="javascript">&#123;<span class="built_in">window</span>.pintrk.queue.push(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))&#125;;<span class="keyword">var</span></span></span><br><span class="line"><span class="javascript">n=<span class="built_in">window</span>.pintrk;n.queue=[],n.version=<span class="string">"3.0"</span>;<span class="keyword">var</span></span></span><br><span class="line"><span class="javascript">t=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>);t.async=!<span class="number">0</span>,t.src=e;<span class="keyword">var</span></span></span><br><span class="line"><span class="javascript">r=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];r.parentNode.insertBefore(t,r)&#125;&#125;</span></span><br><span class="line"><span class="javascript">(<span class="string">"https://s.pinimg.com/ct/core.js"</span>); </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">pintrk(<span class="string">'load'</span>,<span class="string">'YOUR_TAG_ID'</span>);</span></span><br><span class="line"><span class="javascript">pintrk(<span class="string">'page'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">height</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">src</span>=<span class="string">"https://ct.pinterest.com/v3/?tid=YOUR_TAG_ID&amp;noscript=1"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">pintrk(<span class="string">'track'</span>, <span class="string">'pagevisit'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">height</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">src</span>=<span class="string">"https://ct.pinterest.com/v3/?tid=YOUR_TAG_ID&amp;event=pagevisit&amp;noscript=1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>支付成功页</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    !<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">if</span>(!<span class="built_in">window</span>.pintrk)&#123;<span class="built_in">window</span>.pintrk=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">window</span>.pintrk.queue.push(</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))&#125;;<span class="keyword">var</span></span></span><br><span class="line"><span class="javascript">    n=<span class="built_in">window</span>.pintrk;n.queue=[],n.version=<span class="string">"3.0"</span>;<span class="keyword">var</span></span></span><br><span class="line"><span class="javascript">    t=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>);t.async=!<span class="number">0</span>,t.src=e;<span class="keyword">var</span></span></span><br><span class="line"><span class="javascript">    r=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];r.parentNode.insertBefore(t,r)&#125;&#125;(<span class="string">"https://s.pinimg.com/ct/core.js"</span>);</span></span><br><span class="line"><span class="javascript">    pintrk(<span class="string">'load'</span>, <span class="string">'YOUR_TAG_ID'</span>);</span></span><br><span class="line"><span class="javascript">    pintrk(<span class="string">'page'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">height</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">src</span>=<span class="string">"https://ct.pinterest.com/v3/?tid=YOUR_TAG_ID&amp;noscript=1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">pintrk (<span class="string">'track'</span>, <span class="string">'checkout'</span>, &#123;&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">height</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span> <span class="attr">alt</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"https://ct.pinterest.com/v3/?tid=YOUR_TAG_ID&amp;event=checkout&amp;noscript=1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的点如下：</p><ol><li>不论什么三方代码，在支付成功页添加时一定要注意避免刷新后重复上传，一般做法是利用cookie判断。shopify 平台还提供了一个 <code>first_time_accessed</code> 的方法。</li></ol><h3 id="GA"><a href="#GA" class="headerlink" title="GA"></a>GA</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ga的代码文档已经很详细，可以根据业务以及数据的不同维度来自定义上传数据，也没什么深坑，这里就不再阐述了。</p><h3 id="Ping-Pong-Pay"><a href="#Ping-Pong-Pay" class="headerlink" title="Ping Pong Pay"></a>Ping Pong Pay</h3><p>现在大多支付已经从重定向的三方模式，向伪俩方或者俩方的模式发展。毕竟俩方不会跳页面，这样会降低用户的流失率。</p><p>在对接这个支付时，采用的是伪俩方的模式，但是 pingpong 的伪俩方并不是直接生成 iframe 而是直接生成 dom，但问题是这个支付生成 dom 的父元素是一个我们自己业务的表单，当切换其他支付单击我们自己的表单提交按钮时 pingpong 的支付也会被触发。与 pingpong 沟通后，对方给了一个动态生成表单的建议。但是鉴于我们接入的支付很多，如果采用动态生成表单需要花时间重构、测试，所以这个意见并没有采纳。不过沟通后当我将 pingpong 的 js 不引入后，上述问题并没用复现。现在的问题就是怎么去除 js 的影响？<br>首先想到的是删除 script 标签，但是只要 js 加载，即使删除了 dom 代码还是会执行。（具体可参考：<a href="https://stackoverflow.com/questions/29970467/removed-javascript-is-still-executable" target="_blank" rel="noopener">Removed JavaScript is still executable</a>）所以需要换一种思路，选择非 pingpong 支付时将该 js 暴露出来的三方对象存起来后直接置 null，当从其他支付切回 pingpong 支付时将存起来的值重新赋回即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在做跨境电商网站的时候避免不了接入三方的支付、统计等代码来进行一系列的数据统计、分析、引流等。这里记录一下自己踩过的坑。&lt;/p&gt;
&lt;h3 id=&quot;worldpay俩方&quot;&gt;&lt;a href=&quot;#worldpay俩方&quot; class=&quot;headerlink&quot; title=&quot;worldpay俩方&quot;&gt;&lt;/a&gt;worldpay俩方&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前不论是 &lt;code&gt;paypal&lt;/code&gt; 还是 &lt;code&gt;worldpay&lt;/code&gt; 接支付都是跳转到三方页面，因为中间跳转的这一步会导致部分用户弃单，转化率下降。根据我们自己的统计和与海外客户沟通来看得到的结论时尽量不要跳转，所以要把之前的三方改为俩方，即页面中&lt;code&gt;嵌套 iframe&lt;/code&gt; 的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入资源css/js/helper.html&lt;/li&gt;
&lt;li&gt;创建目标div&lt;/li&gt;
&lt;li&gt;执行setup&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="三方" scheme="https://i7eo.com/categories/%E4%B8%89%E6%96%B9/"/>
    
    
      <category term="worldpay" scheme="https://i7eo.com/tags/worldpay/"/>
    
      <category term="paypal smart button" scheme="https://i7eo.com/tags/paypal-smart-button/"/>
    
      <category term="certona" scheme="https://i7eo.com/tags/certona/"/>
    
      <category term="pinterest" scheme="https://i7eo.com/tags/pinterest/"/>
    
      <category term="ga" scheme="https://i7eo.com/tags/ga/"/>
    
      <category term="pingpong" scheme="https://i7eo.com/tags/pingpong/"/>
    
  </entry>
  
  <entry>
    <title>Javascript继承</title>
    <link href="https://i7eo.com/2019/03/13/Javascript%E7%BB%A7%E6%89%BF.html"/>
    <id>https://i7eo.com/2019/03/13/Javascript继承.html</id>
    <published>2019-03-13T13:15:22.000Z</published>
    <updated>2019-03-13T17:08:02.500Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Javascript的继承是基于原型的，之前理解的比较简单，直到最近在用 es5 写星级评分组件的时候遇到了些问题，解决之后理解深了一些。总结归纳，以便后用。</p><h3 id="星级评分"><a href="#星级评分" class="headerlink" title="星级评分"></a>星级评分</h3><p>原本的需求有俩个：</p><ol><li>根据后台返回的评价分数单纯进行5颗星的展示</li><li>用户可以在5颗星上为商品进行打分，单击后上传</li></ol><p>开始用最笨的方法，从业务出发很快速的把俩个需求都实现了。最后想着能不能利用继承来优化，方便后期扩展可以进行半星或者四分之一星评分。</p><p>具体效果如下：<br><img src="/2019/03/13/Javascript继承/i7eo-Mar-14-201900-56-35.gif" alt="star"></p><h3 id="利用原型分别实现满星与半星"><a href="#利用原型分别实现满星与半星" class="headerlink" title="利用原型分别实现满星与半星"></a>利用原型分别实现满星与半星</h3><a id="more"></a><p>ps：这里的星星使用 iconfont 的字体图标</p><h4 id="Dom结构"><a href="#Dom结构" class="headerlink" title="Dom结构"></a>Dom结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"star"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"star-list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item iconfont icon-star-off"</span> <span class="attr">title</span>=<span class="string">"wtf"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item iconfont icon-star-off"</span> <span class="attr">title</span>=<span class="string">"bad"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item iconfont icon-star-off"</span> <span class="attr">title</span>=<span class="string">"not bad"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item iconfont icon-star-off"</span> <span class="attr">title</span>=<span class="string">"good"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item iconfont icon-star-off"</span> <span class="attr">title</span>=<span class="string">"perfect"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="满星-amp-半星JS代码"><a href="#满星-amp-半星JS代码" class="headerlink" title="满星&amp;半星JS代码"></a>满星&amp;半星JS代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> starRating = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 整颗</span></span><br><span class="line">    <span class="keyword">var</span> lightenFullStar = <span class="function"><span class="keyword">function</span>(<span class="params">el, opts</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$el = $(el)</span><br><span class="line">        <span class="keyword">this</span>.$stars = <span class="keyword">this</span>.$el.find(<span class="string">'.item'</span>)</span><br><span class="line">        <span class="keyword">this</span>.opts = opts</span><br><span class="line">    &#125;</span><br><span class="line">    lightenFullStar.prototype.lighten = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        num = <span class="built_in">parseInt</span>(num)</span><br><span class="line">        <span class="keyword">this</span>.$stars.each(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; num ) &#123;</span><br><span class="line">                $(<span class="keyword">this</span>).removeClass(<span class="string">'icon-star-off'</span>).addClass(<span class="string">'icon-star-on'</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $(<span class="keyword">this</span>).removeClass(<span class="string">'icon-star-on'</span>).addClass(<span class="string">'icon-star-off'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    lightenFullStar.prototype.bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">        self.$el.on(<span class="string">'click'</span>, <span class="string">'.item'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> selectedStar = $(<span class="keyword">this</span>).index() + <span class="number">1</span></span><br><span class="line">            self.opts.num = selectedStar</span><br><span class="line">            <span class="keyword">typeof</span> self.opts.select === <span class="string">'function'</span> &amp;&amp; self.opts.select.call(<span class="keyword">this</span>, selectedStar, self.$stars.length)</span><br><span class="line">        &#125;).on(<span class="string">'mouseover'</span>, <span class="string">'.item'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.lighten($(<span class="keyword">this</span>).index() + <span class="number">1</span>)</span><br><span class="line">        &#125;).on(<span class="string">'mouseout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.lighten(self.opts.num)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    lightenFullStar.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lighten(<span class="keyword">this</span>.opts.num)</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.opts.readOnly)&#123;</span><br><span class="line">            <span class="keyword">this</span>.bindEvent()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 半颗</span></span><br><span class="line">    <span class="keyword">var</span> lightenHalfStar = <span class="function"><span class="keyword">function</span>(<span class="params">el, opts</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$el = $(el)</span><br><span class="line">        <span class="keyword">this</span>.$stars = <span class="keyword">this</span>.$el.find(<span class="string">'.item'</span>)</span><br><span class="line">        <span class="keyword">this</span>.opts = opts</span><br><span class="line">        <span class="keyword">this</span>.patch = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    lightenHalfStar.prototype.lighten = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> integer = <span class="built_in">parseInt</span>(num),</span><br><span class="line">            hasDecimals = integer !== num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.$stars.each(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; num ) &#123;</span><br><span class="line">                $(<span class="keyword">this</span>).removeClass(<span class="string">'icon-star-off icon-star-half'</span>).addClass(<span class="string">'icon-star-on'</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $(<span class="keyword">this</span>).removeClass(<span class="string">'icon-star-on icon-star-half'</span>).addClass(<span class="string">'icon-star-off'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 半颗的点亮</span></span><br><span class="line">        <span class="keyword">if</span>(hasDecimals) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$stars.eq(integer).removeClass(<span class="string">'icon-star-off icon-star-on'</span>).addClass(<span class="string">'icon-star-half'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lightenHalfStar.prototype.bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">        self.$el.on(<span class="string">'mousemove'</span>, <span class="string">'.item'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 这是理想状态如果设置padingleft/right 还没到目标dom星星就产生变化</span></span><br><span class="line">            <span class="comment">// 星星的间距最好设置为margin</span></span><br><span class="line">            <span class="keyword">if</span>(e.pageX - $(<span class="keyword">this</span>).offset().left &lt; $(<span class="keyword">this</span>).width() / <span class="number">2</span>) &#123;</span><br><span class="line">                self.patch = <span class="number">0.5</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                self.patch = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> selectedStar = $(<span class="keyword">this</span>).index() + self.patch</span><br><span class="line">            self.lighten(selectedStar)</span><br><span class="line">        &#125;).on(<span class="string">'click'</span>, <span class="string">'.item'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.opts.num = $(<span class="keyword">this</span>).index() + self.patch</span><br><span class="line">            <span class="keyword">typeof</span> self.opts.select === <span class="string">'function'</span> &amp;&amp; self.opts.select.call(<span class="keyword">this</span>, self.opts.num, self.$stars.length)</span><br><span class="line">        &#125;).on(<span class="string">'mouseout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.lighten(self.opts.num)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    lightenHalfStar.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lighten(<span class="keyword">this</span>.opts.num)</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.opts.readOnly)&#123;</span><br><span class="line">            <span class="keyword">this</span>.bindEvent()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// default</span></span><br><span class="line">    <span class="keyword">var</span> defaults = &#123;</span><br><span class="line">        mode: <span class="string">'full'</span>,</span><br><span class="line">        num: <span class="number">0</span>,</span><br><span class="line">        readOnly: <span class="literal">false</span>,</span><br><span class="line">        select: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reflect = &#123;</span><br><span class="line">        <span class="string">'full'</span>: lightenFullStar,</span><br><span class="line">        <span class="string">'half'</span>: lightenHalfStar</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _init = <span class="function"><span class="keyword">function</span>(<span class="params">el, opts</span>) </span>&#123;</span><br><span class="line">        opts = $.extend(&#123;&#125;, defaults, opts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!reflect[opts.mode]) opts.mode = <span class="string">'full'</span></span><br><span class="line">        <span class="keyword">new</span> reflect[opts.mode](el, opts).init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: _init</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">starRating.init(<span class="string">'.star-list'</span>, &#123;</span><br><span class="line">    mode:<span class="string">'full'</span>,</span><br><span class="line">    num: <span class="number">4.6</span>,</span><br><span class="line">    readOnly: <span class="literal">false</span>,</span><br><span class="line">    select: <span class="function"><span class="keyword">function</span>(<span class="params">selected, total</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(selected + <span class="string">'/'</span> + total)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单来说一下，这里主要运用的事件有 mouseover(mousemove)、mouseout、click。为什么不用  mouseenter&amp;mouseleave 具体可以参考mdn。满星利用 mouseover 监听鼠标移入当前 dom 的操作，半星则将 mouseover 替换为 mousemove ，因为此时我们的鼠标移入时在星星的右侧也就是整颗星，此时在星星内部鼠标从右向左移动 mouseover 是无法触发的，所以不能选择半星。其他的实现就是按照业务一步步来即可，这俩段代码写完之后，发现其实很像。ok，下来利用继承与多态来改写。</p><h3 id="利用模版方法改写代码"><a href="#利用模版方法改写代码" class="headerlink" title="利用模版方法改写代码"></a>利用模版方法改写代码</h3><p>模版方法是什么？简单来说，抽离出公共逻辑作为父类，子类继承父类，对于特有的逻辑或方法对父类中的逻辑或方法进行重写。具体可以参考设计模式。</p><h4 id="提取公共逻辑设置父类-Lighten"><a href="#提取公共逻辑设置父类-Lighten" class="headerlink" title="提取公共逻辑设置父类 Lighten"></a>提取公共逻辑设置父类 Lighten</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Lighten = <span class="function"><span class="keyword">function</span>(<span class="params">el, opts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$el = $(el)</span><br><span class="line">    <span class="keyword">this</span>.$stars = <span class="keyword">this</span>.$el.find(<span class="string">'.item'</span>)</span><br><span class="line">    <span class="keyword">this</span>.opts = opts</span><br><span class="line">    <span class="keyword">this</span>.patch = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.selectEvent = <span class="string">'mouseover'</span></span><br><span class="line">&#125;</span><br><span class="line">Lighten.prototype.lighten = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num = <span class="built_in">parseInt</span>(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$stars.each(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; num ) &#123;</span><br><span class="line">            $(<span class="keyword">this</span>).removeClass(<span class="string">'icon-star-off icon-star-half'</span>).addClass(<span class="string">'icon-star-on'</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $(<span class="keyword">this</span>).removeClass(<span class="string">'icon-star-on icon-star-half'</span>).addClass(<span class="string">'icon-star-off'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Lighten.prototype.bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    self.$el.on(self.selectEvent, <span class="string">'.item'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        self.calculateRange(e, $(<span class="keyword">this</span>))</span><br><span class="line">        self.lighten($(<span class="keyword">this</span>).index() + self.patch)</span><br><span class="line">    &#125;).on(<span class="string">'click'</span>, <span class="string">'.item'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> selectedStar = $(<span class="keyword">this</span>).index() + self.patch</span><br><span class="line">        self.opts.num = selectedStar</span><br><span class="line">        <span class="keyword">typeof</span> self.opts.select === <span class="string">'function'</span> &amp;&amp; self.opts.select.call(<span class="keyword">this</span>, selectedStar, self.$stars.length)</span><br><span class="line">    &#125;).on(<span class="string">'mouseout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.lighten(self.opts.num)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Lighten.prototype.calculateRange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子类必须重写该方法</span></span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'Subclasses must be overridden'</span>)</span><br><span class="line">&#125;</span><br><span class="line">Lighten.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lighten(<span class="keyword">this</span>.opts.num)</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.opts.readOnly)&#123;</span><br><span class="line">        <span class="keyword">this</span>.bindEvent()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子类-lightenFullStar-amp-lightenHalfStar"><a href="#子类-lightenFullStar-amp-lightenHalfStar" class="headerlink" title="子类 lightenFullStar &amp; lightenHalfStar"></a>子类 lightenFullStar &amp; lightenHalfStar</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lightenFullStar = <span class="function"><span class="keyword">function</span>(<span class="params">el, opts</span>) </span>&#123;</span><br><span class="line">    Lighten.call(<span class="keyword">this</span>, el, opts)</span><br><span class="line">    <span class="keyword">this</span>.selectEvent = <span class="string">'mouseover'</span></span><br><span class="line">&#125;</span><br><span class="line">lightenFullStar.prototype.lighten = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    Lighten.prototype.lighten.call(<span class="keyword">this</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">lightenFullStar.prototype.calculateRange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">lightenFullStar.prototype = <span class="keyword">new</span> Lighten()</span><br><span class="line">lightenFullStar.prototype.construtor = lightenFullStar</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lightenHalfStar = <span class="function"><span class="keyword">function</span>(<span class="params">el, opts</span>) </span>&#123;</span><br><span class="line">    Lighten.call(<span class="keyword">this</span>, el, opts)</span><br><span class="line">    <span class="keyword">this</span>.selectEvent = <span class="string">'mousemove'</span></span><br><span class="line">&#125;</span><br><span class="line">lightenHalfStar.prototype.lighten = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> integer = <span class="built_in">parseInt</span>(num),</span><br><span class="line">        hasDecimals = integer !== num</span><br><span class="line">    </span><br><span class="line">    Lighten.prototype.lighten.call(<span class="keyword">this</span>, integer)</span><br><span class="line">    <span class="comment">// 半颗的点亮</span></span><br><span class="line">    <span class="keyword">if</span>(hasDecimals) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$stars.eq(integer).removeClass(<span class="string">'icon-star-off icon-star-on'</span>).addClass(<span class="string">'icon-star-half'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">lightenHalfStar.prototype.calculateRange = <span class="function"><span class="keyword">function</span>(<span class="params">e, $this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.pageX - $<span class="keyword">this</span>.offset().left &lt; $<span class="keyword">this</span>.width() / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.patch = <span class="number">0.5</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.patch = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">lightenHalfStar.prototype = <span class="keyword">new</span> Lighten()</span><br><span class="line">lightenHalfStar.prototype.construtor = lightenHalfStar</span><br></pre></td></tr></table></figure><p>alright！看起来不错，感觉万事大吉了。跑起来试试，发现报错</p><p><img src="/2019/03/13/Javascript继承/i7eo_a35030fe568d86cdf0bec5f6714af413.png" alt="wtf?"></p><p>看起来还不错的代码竟然跑挂了，根据报错信息很明显可以分析出没有执行子类重写的 lighten 方法。这是什么原因导致的呢？</p><p><code>lightenHalfStar.prototype = new Lighten()</code> </p><p>这行代码是将构造函数 <code>Lighten</code> 的原型对象赋值给  <code>lightenHalfStar</code> 的原型对象。这本身是没什么错的，原型继承的关键也是这句话。将此时的<code>lightenHalfStar.prototype</code>打印出来如下：</p><p><img src="/2019/03/13/Javascript继承/i7eo_ca76e0e73be95c62ffd52b0221daa84a.png" alt="result-1"></p><p>在执行<code>lightenHalfStar.prototype = new Lighten()</code>之前<code>lightenHalfStar.prototype</code>中的 <code>lighten</code>确实是自己重写的（可以看 FunctionLocation:120）。让我再看看执行之后的结果。如下：</p><p><img src="/2019/03/13/Javascript继承/i7eo_da48d95e719506e8f5554c12a4f6f09a.png" alt="result-2"></p><p>可以看到 FunctionLocation:41 （即指向了父类的 lighten 方法所在文件中的位置）为什么会这样？答案其实很简单，将 <code>lightenHalfStar.prototype = new Lighten()</code> 的顺序放在声明 lightenHalfStar 原型方法之前即可。</p><h3 id="总结-amp-改进"><a href="#总结-amp-改进" class="headerlink" title="总结&amp;改进"></a>总结&amp;改进</h3><p>对于实现重写方法来说，继承语句的位置是相当关键的。一不注意就进了坑。</p><p>注意原型继承中子类的构造器需要手动置回。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightenHalfStar.prototype = <span class="keyword">new</span> Lighten()</span><br><span class="line">lightenHalfStar.prototype.constructor = lightenHalfStar</span><br></pre></td></tr></table></figure></p><p>原型继承若子类与父类构造器中变量同名则子类的变量会被覆盖，要想重写，就得在构造器中改变 this 指向。如代码中的：<code>Lighten.call(this, el, opts)</code></p><p>通过图 result-2 我们也可以看到实例化之后父类构造函数的值也会被带进来。如果值很多的话也会浪费资源，这并不是比较好的结果。优化方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span>(<span class="params">sub, sup</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = sup.prototype</span><br><span class="line">    sub.prototype = <span class="keyword">new</span> F()</span><br><span class="line">    sub.prototype.construtor = sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用空的构造函数做中间人（代理）即可解决。</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol><li><p>完整代码：<a href="https://github.com/i7eo/WebCodeHodgepodge/blob/master/starRating/v2/star-v3.html" target="_blank" rel="noopener">星级评分组件</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript面向对象编程（二）：构造函数的继承</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Javascript的继承是基于原型的，之前理解的比较简单，直到最近在用 es5 写星级评分组件的时候遇到了些问题，解决之后理解深了一些。总结归纳，以便后用。&lt;/p&gt;
&lt;h3 id=&quot;星级评分&quot;&gt;&lt;a href=&quot;#星级评分&quot; class=&quot;headerlink&quot; title=&quot;星级评分&quot;&gt;&lt;/a&gt;星级评分&lt;/h3&gt;&lt;p&gt;原本的需求有俩个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据后台返回的评价分数单纯进行5颗星的展示&lt;/li&gt;
&lt;li&gt;用户可以在5颗星上为商品进行打分，单击后上传&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开始用最笨的方法，从业务出发很快速的把俩个需求都实现了。最后想着能不能利用继承来优化，方便后期扩展可以进行半星或者四分之一星评分。&lt;/p&gt;
&lt;p&gt;具体效果如下：&lt;br&gt;&lt;img src=&quot;/2019/03/13/Javascript继承/i7eo-Mar-14-201900-56-35.gif&quot; alt=&quot;star&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;利用原型分别实现满星与半星&quot;&gt;&lt;a href=&quot;#利用原型分别实现满星与半星&quot; class=&quot;headerlink&quot; title=&quot;利用原型分别实现满星与半星&quot;&gt;&lt;/a&gt;利用原型分别实现满星与半星&lt;/h3&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="继承" scheme="https://i7eo.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>前端代码编写注意事项</title>
    <link href="https://i7eo.com/2019/03/02/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html"/>
    <id>https://i7eo.com/2019/03/02/前端代码编写注意事项.html</id>
    <published>2019-03-02T12:22:23.000Z</published>
    <updated>2019-03-13T17:24:03.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li><p>声明不用，数据只使用一次或不使用就无需装到变量中</p></li><li><p>变量命名，驼峰、简洁、易懂</p></li><li><p>特定变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_INPUT_LENGTH = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (value.length &lt; MAX_INPUT_LENGTH) &#123;</span><br><span class="line">     <span class="comment">// 一目了然，不能超过最大输入长度</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用说明性的变量(即有意义的变量名)</p></li></ol><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> address = <span class="string">'One Infinite Loop, Cupertino 95014'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cityZipCodeRegex = <span class="regexp">/^[^,\]+[,\s]+(.+?)s*(d&#123;5&#125;)?$/</span>;</span><br><span class="line"></span><br><span class="line">saveCityZipCode(</span><br><span class="line">address.match(cityZipCodeRegex)[<span class="number">1</span>],<span class="comment">// 这个公式到底要干嘛，对不起，原作者已经离职了。自己看代码     </span></span><br><span class="line">address.match(cityZipCodeRegex)[<span class="number">2</span>], <span class="comment">// 这个公式到底要干嘛，对不起，原作者已经离职了。自己看代码</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">'One Infinite Loop, Cupertino 95014'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cityZipCodeRegex = <span class="regexp">/^[^,\]+[,\s]+(.+?)s*(d&#123;5&#125;)?$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, city, zipCode] = address.match(cityZipCodeRegex) || [];</span><br><span class="line"></span><br><span class="line">saveCityZipCode(city, zipCode);</span><br></pre></td></tr></table></figure><ol start="5"><li><p>避免使用太多的全局变量，如有需要请使用命名空间</p></li><li><p>对于求值变量做好默认值（兜底），对于赋值变量可不用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实在项目中有很多求值变量，对于每个求值变量都需要做好兜底。</span></span><br><span class="line"><span class="keyword">let</span> propertyValue = <span class="built_in">Object</span>.attr || <span class="number">0</span>; <span class="comment">// 因为Object.attr有可能为空，所以需要兜底。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，赋值变量就不需要兜底了。</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>; <span class="comment">// 因为有底了，所以不要兜着。</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">'Tiny'</span>; <span class="comment">// 因为有底了，所以不要兜着。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>1.对于返回true or false的函数，最好以should/is/can/has开头</p><p>2.动作函数已动词开头否则不好辨别意图</p><p>3.功能函数最好为纯函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NO: 不要让功能函数的输出变化无常。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusAbc</span>(<span class="params">a, b, c</span>) </span>&#123;  <span class="comment">// 这个函数的输出将变化无常，因为api返回的值一旦改变，同样输入函数的a，b,c的值，但函数返回的结果却不一定相同。</span></span><br><span class="line"><span class="keyword">var</span> c = fetch(<span class="string">'../api'</span>);</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//YES：功能函数使用纯函数，输入一致，输出结果永远唯一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusAbc</span>(<span class="params">a, b, c</span>) </span>&#123;  <span class="comment">// 同样输入函数的a，b,c的值，但函数返回的结果永远相同。</span></span><br><span class="line">        <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>函数传参要有说明（参数过多，使用对象来代替）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NO：传参无说明</span></span><br><span class="line">page.getSVG(api, <span class="literal">true</span>, <span class="literal">false</span>); <span class="comment">// true和false啥意思，一目不了然</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// YES: 传参有说明</span></span><br><span class="line">page.getSVG(&#123;</span><br><span class="line">    imageApi: api,</span><br><span class="line">    includePageBackground: <span class="literal">true</span>, <span class="comment">// 一目了然，知道这些true和false是啥意思</span></span><br><span class="line">    compress: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>一个函数完成一个独立的功能，不要一个函数混杂多个功能</p></li><li><p>优先使用函数式编程，少用for</p></li><li><p>多重判断使用array.includes（逻辑复杂可以考虑使用策略模式） ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NO </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit</span>) </span></span><br><span class="line"><span class="function">  <span class="title">if</span> (<span class="params">fruit == <span class="string">'apple'</span> || fruit == <span class="string">'strawberry'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// YES</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'cherry'</span>, <span class="string">'cranberries'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (redFruits.includes(fruit)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更少的嵌套，尽早return，考虑使用非（！）</p></li><li><p>倾向于遍历对象还不是switch：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NO</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用条件语句来寻找对应颜色的水果</span></span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'red'</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'yellow'</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'purple'</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'grape'</span>, <span class="string">'plum'</span>];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test results</span></span><br><span class="line">test(<span class="literal">null</span>); <span class="comment">// []</span></span><br><span class="line">test(<span class="string">'yellow'</span>); <span class="comment">// ['banana', 'pineapple']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// YES</span></span><br><span class="line"><span class="keyword">const</span> fruitColor = &#123;</span><br><span class="line">  red: [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>],</span><br><span class="line">  yellow: [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>],</span><br><span class="line">  purple: [<span class="string">'grape'</span>, <span class="string">'plum'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fruitColor[color] || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对 所有/部分 判断使用 Array.every &amp; Array.some</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;声明不用，数据只使用一次或不使用就无需装到变量中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量命名，驼峰、简洁、易懂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特定变量：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; MAX_INPUT_LENGTH = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value.length &amp;lt; MAX_INPUT_LENGTH) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 一目了然，不能超过最大输入长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用说明性的变量(即有意义的变量名)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="规范" scheme="https://i7eo.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Vue 的响应式/模版解析/渲染</title>
    <link href="https://i7eo.com/2019/01/03/vuesc.html"/>
    <id>https://i7eo.com/2019/01/03/vuesc.html</id>
    <published>2019-01-03T15:04:45.000Z</published>
    <updated>2019-01-05T05:22:56.913Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于使用 vue 的同学来说，响应式、模版解析/渲染应该都很熟悉，vue 开发离不开这些特性。用了 vue 挺长时间了，写写总结。</p><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>创建一个普通的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = &#123;</span><br><span class="line">    name: <span class="string">'t1'</span></span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(t.age) <span class="comment">// 19 那么如何监听age属性的访问与设置呢？</span></span><br></pre></td></tr></table></figure><p>在es5中加入了一个api叫 Object.defineProperty,该api允许</p><a id="more"></a><p>创建对象的属性自定义 get/set 函数。修改上面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'t1'</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">get() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span>)</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;,</span><br><span class="line">set(newVal) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span>)</span><br><span class="line">name = newVal</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="comment">// t1</span></span><br><span class="line">obj.name = <span class="string">'george'</span></span><br><span class="line"><span class="comment">// set</span></span><br></pre></td></tr></table></figure><p>在vue中我们可以模拟一下，大概过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    name: <span class="string">'lyn'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">in</span> data) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(vm, v, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">        <span class="keyword">return</span> data[v]</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal) &#123;</span><br><span class="line">        data[v] = newVal</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要将data的值全部代理至vm对象上？vue中就是这么写的 …，而且模版解析的时候会用到。</p><h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><p>我们经常在vue中使用vue模板，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;input v-model=<span class="string">"title"</span>&gt;</span><br><span class="line">  &lt;button @click=<span class="string">"add"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li v-for="v in list"&gt;&#123;&#123; v &#125;&#125;&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><p>模板的本质是字符串，其特点有：</p><ul><li>包含 if/for 等逻辑指令</li><li>动态的（动态生成 dom ）</li><li>最终转换为 html</li></ul><p>综上，要将模板转换为 html ，只能使用 js 来操作。在 html/css/js 中，只有js能处理逻辑和渲染页面。</p><p>在当前文件引入vue文件，打开控制台，在源码中搜索code.render 在 return 前打印 code.render，观察模板被解析后生成的render函数，render函数最终返回vnode。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  <span class="comment">// this 就是 vm</span></span><br><span class="line">    <span class="keyword">return</span> _c(</span><br><span class="line">        <span class="string">'div'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            attrs:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [_c(</span><br><span class="line">            <span class="string">'div'</span>,</span><br><span class="line">            [</span><br><span class="line">                _c(</span><br><span class="line">                    <span class="string">'input'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        directives:[</span><br><span class="line">                        &#123;</span><br><span class="line">                       name:<span class="string">"model"</span>,</span><br><span class="line">                       rawName:<span class="string">"v-model"</span>,</span><br><span class="line">                       value:(title),  <span class="comment">// vm.title 在这里就将model中的的值通过vm与view中的input数据联系了起来</span></span><br><span class="line">                       expression:<span class="string">"title"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        domProps:&#123;</span><br><span class="line">                            <span class="string">"value"</span>:(title)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        on:&#123;</span><br><span class="line">                            <span class="string">"input"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;</span><br><span class="line">                          <span class="comment">// 在这里可以发现v-model 其实在vue模版内被封装了进去</span></span><br><span class="line">                                <span class="keyword">if</span>($event.target.composing)<span class="keyword">return</span>;</span><br><span class="line">                                title=$event.target.value</span><br><span class="line">                                在这里就将view中的input中的值通过vm与model中的数据联系了起来与上面相对应实现双向绑定</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ),</span><br><span class="line">                _v(<span class="string">" "</span>),</span><br><span class="line">                <span class="comment">// 因为html中俩个标签间我们换行所以这里是空</span></span><br><span class="line">                _c(</span><br><span class="line">                    <span class="string">'button'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        on:&#123;</span><br><span class="line">                            <span class="string">"click"</span>:add</span><br><span class="line">                            <span class="comment">// 相当于 vm.add这里直接调用methods中定义的add函数</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    [_v(<span class="string">"submit"</span>)]</span><br><span class="line">                )</span><br><span class="line">            ]),</span><br><span class="line">        _v(<span class="string">" "</span>),</span><br><span class="line">        _c(<span class="string">'div'</span>,</span><br><span class="line">            [</span><br><span class="line">                _c(</span><br><span class="line">                    <span class="string">'ul'</span>,</span><br><span class="line">                   <span class="comment">//v-for这里使用内部定义的 _l函数来处理</span></span><br><span class="line">                    _l((list),<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="keyword">return</span> _c(<span class="string">'li'</span>,[_v(_s(item))])&#125;)</span><br><span class="line">                )</span><br><span class="line">            ]</span><br><span class="line">        )]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_c 创建标签，_v创建文本元素，_s toString()，这个_c 和 snabbdom 中的 h 函数很像，那vue中更新的操作会不会和 snabbdom 中的逻辑页相似呢？<br>vue 中的更新函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vm._update(vnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevNode = vm._vnode</span><br><span class="line">    vm._node = vnode</span><br><span class="line">    <span class="keyword">if</span>(!prevNode) &#123;</span><br><span class="line">        vm.$el = vm.__patch___(vm.$el, vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vm.$el = vm.__patch__(prevNode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm._update(vm._render())</span><br><span class="line">    <span class="comment">// vm._render 即生成上面包含 _c/_v/_s的模板解析函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说每次改变data，通过Object.defineProperty监听修改操作，一旦修改就调用 updateComponent 函数，利用vm._render方法生成新的 vnode。通过 vm._patch_ 将vnode转化为html并更新至原生dom中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>解析模板生成render函数</li><li>响应式开始监听</li><li>首次渲染，显示页面且绑定依赖</li><li>data属性变化，再次渲染</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于使用 vue 的同学来说，响应式、模版解析/渲染应该都很熟悉，vue 开发离不开这些特性。用了 vue 挺长时间了，写写总结。&lt;/p&gt;
&lt;h3 id=&quot;响应式&quot;&gt;&lt;a href=&quot;#响应式&quot; class=&quot;headerlink&quot; title=&quot;响应式&quot;&gt;&lt;/a&gt;响应式&lt;/h3&gt;&lt;p&gt;创建一个普通的对象：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; t = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;t1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age: &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(t.age) &lt;span class=&quot;comment&quot;&gt;// 19 那么如何监听age属性的访问与设置呢？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在es5中加入了一个api叫 Object.defineProperty,该api允许&lt;/p&gt;
    
    </summary>
    
      <category term="Vuejs" scheme="https://i7eo.com/categories/Vuejs/"/>
    
    
      <category term="模版解析" scheme="https://i7eo.com/tags/%E6%A8%A1%E7%89%88%E8%A7%A3%E6%9E%90/"/>
    
      <category term="render 函数" scheme="https://i7eo.com/tags/render-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>译文：Understanding the Virtual DOM</title>
    <link href="https://i7eo.com/2019/01/01/vdom.html"/>
    <id>https://i7eo.com/2019/01/01/vdom.html</id>
    <published>2019-01-01T07:22:47.000Z</published>
    <updated>2019-01-06T04:22:24.421Z</updated>
    
    <content type="html"><![CDATA[<p>本文为译文，原文地址：</p><blockquote><p><a href="https://bitsofco.de/understanding-the-virtual-dom/" target="_blank" rel="noopener">Understanding the Virtual DOM</a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最近在写一些如何正确区分 dom 与 shadow dom 的文章。总的来说，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。shadow dom 可以被认为是轻量级版本的 dom。它同样是以原生对象为基础的 html document，但是它并不是完整的。可能有些难懂，换一种说法来看，shadow dom 允许我们去将我们的 dom 划分的更小，更轻，可以跨文档使用。（这里作者想表达的意思是我们可以根据需要截取部分 dom 生成 vdom，而不用每次从 html 标签开始写 vdom 直到 html 标签闭合）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个你可能遇到过的相似说法称 “shadow dom” 为 “virtual DOM”。尽管</p><a id="more"></a><p>这个说法已经存在了很多年，但是它真正的流行是在 react 使用它之后。在这篇文章中我将尽力阐述什么是虚拟 dom ，它与原生 dom 又什么不同以及如何使用它。</p><h3 id="我们为什么需要虚拟-dom-？"><a href="#我们为什么需要虚拟-dom-？" class="headerlink" title="我们为什么需要虚拟 dom ？"></a>我们为什么需要虚拟 dom ？</h3><p>想要了解虚拟dom为什么会出现，让我们先回顾以下原生dom。正如我所提到的，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。举个例子看看：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span>List item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以用如下 dom 树来表示：</p><p><img src="/2019/01/01/vdom/i7eo_854852a0e956219a4a2a016470fe6c6c.png" alt=""></p><p>让我们来进行以下操作：</p><ul><li>修改第一个 li 的内容为 list item one</li><li>加上一个 li</li></ul><p>要完成上述操作需要创建新节点，添加新属性与内容，最终完成更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listItemOne = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"list__item"</span>)[<span class="number">0</span>];</span><br><span class="line">listItemOne.textContent = <span class="string">"List item one"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"list"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> listItemTwo = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">listItemTwo.classList.add(<span class="string">"list__item"</span>);</span><br><span class="line">listItemTwo.textContent = <span class="string">"List item two"</span>;</span><br><span class="line">list.appendChild(listItemTwo);</span><br></pre></td></tr></table></figure><h3 id="Dom-并不是为此而生的"><a href="#Dom-并不是为此而生的" class="headerlink" title="Dom 并不是为此而生的"></a>Dom 并不是为此而生的</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当1998年发布DOM的第一个规范时，我们以非常不同的方式构建和管理web页面。很少像今天这样依赖DOM api来创建和更新页面内容。</p><p>像 <code>document.getElementsByClassName()</code> 这个方法小规模使用没有问题，但是如果在同一页面间隔很短的情况下去更新多个元素，就会使对于 dom 的查询与更新操作变得很昂贵。此外，更新文档中较大一部分比更新特定元素的开销会小一些。回到我们列表例子中，从某种程度上来说用新元素替换整个无序列表比修改某个特定元素要简单一些。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"list"</span>)[<span class="number">0</span>];</span><br><span class="line">list.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;li class="list__item"&gt;List item one&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class="list__item"&gt;List item two&lt;/li&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>在这俩个例子中，性能差异并不大。但是随着页面数量的增加，选择、更新我们需要的代码会显得尤为重要。</p><h3 id="虚拟-Dom-因此而出现"><a href="#虚拟-Dom-因此而出现" class="headerlink" title="虚拟 Dom 因此而出现"></a>虚拟 Dom 因此而出现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟 Dom 的出现是为了用更加高效的方式来处理频繁更新 dom 所产生的问题。与 dom 和 shadow dom 不同的是，虚拟 dom 不是一种正式的规范，它更像一种与 dom 交互的新方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟 dom 可以被认为是原生 dom 的一个复制品。在这个复制品上我们可以不通过 dom api 就能频繁更新数据。一旦对虚拟DOM进行了所有更新，我们就可以查看需要对原始DOM进行哪些特定更改，并且使这些改变更加具体与优化。</p><h3 id="虚拟-Dom-张什么样呢？"><a href="#虚拟-Dom-张什么样呢？" class="headerlink" title="虚拟 Dom 张什么样呢？"></a>虚拟 Dom 张什么样呢？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一听到虚拟，可能会觉得有些神秘感。其实虚拟 dom 就是 js 对象。让我们再来回顾先前创建的 dom 树：</p><p><img src="/2019/01/01/vdom/i7eo_854852a0e956219a4a2a016470fe6c6c.png" alt=""></p><p>这个树可以表示为如下 js 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vdom = &#123;</span><br><span class="line">    tagName: <span class="string">"html"</span>,</span><br><span class="line">    children: [</span><br><span class="line">        &#123; <span class="attr">tagName</span>: <span class="string">"head"</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tagName: <span class="string">"body"</span>,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    tagName: <span class="string">"ul"</span>,</span><br><span class="line">                    attributes: &#123; <span class="string">"class"</span>: <span class="string">"list"</span> &#125;,</span><br><span class="line">                    children: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            tagName: <span class="string">"li"</span>,</span><br><span class="line">                            attributes: &#123; <span class="string">"class"</span>: <span class="string">"list__item"</span> &#125;,</span><br><span class="line">                            textContent: <span class="string">"List item"</span></span><br><span class="line">                        &#125; <span class="comment">// end li</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125; <span class="comment">// end ul</span></span><br><span class="line">            ]</span><br><span class="line">        &#125; <span class="comment">// end body</span></span><br><span class="line">    ]</span><br><span class="line">&#125; <span class="comment">// end html</span></span><br></pre></td></tr></table></figure><p>我们完全可以把这个 js 对象当作虚拟 dom 。我们可以根据需要自由的频繁操作它而不改变原生 dom。</p><p>相比于使用整个对象，我们通常的做法是使用部分虚拟 dom。举个例子，我们要操作一个 list 组件，这个组件与我们的无序列表元素相关联。具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">    tagName: <span class="string">"ul"</span>,</span><br><span class="line">    attributes: &#123; <span class="string">"class"</span>: <span class="string">"list"</span> &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tagName: <span class="string">"li"</span>,</span><br><span class="line">            attributes: &#123; <span class="string">"class"</span>: <span class="string">"list__item"</span> &#125;,</span><br><span class="line">            textContent: <span class="string">"List item"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚拟-Dom-如何使用？"><a href="#虚拟-Dom-如何使用？" class="headerlink" title="虚拟 Dom 如何使用？"></a>虚拟 Dom 如何使用？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们见识过了虚拟dom的样子，那么它是如何处理dom操作的性能问题？</p><p>正如我所提到的，虚拟 dom 可以专门用来对你需要改变的元素进行操作。（不影响没有改变的元素）让我们重回无序列表的例子。</p><p>第一件事我们应该复制dom来产生虚拟dom，然后对需要改变的元素在虚拟dom中进行改变操作。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copy = &#123;</span><br><span class="line">    tagName: <span class="string">"ul"</span>,</span><br><span class="line">    attributes: &#123; <span class="string">"class"</span>: <span class="string">"list"</span> &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tagName: <span class="string">"li"</span>,</span><br><span class="line">            attributes: &#123; <span class="string">"class"</span>: <span class="string">"list__item"</span> &#125;,</span><br><span class="line">            textContent: <span class="string">"List item one"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tagName: <span class="string">"li"</span>,</span><br><span class="line">            attributes: &#123; <span class="string">"class"</span>: <span class="string">"list__item"</span> &#125;,</span><br><span class="line">            textContent: <span class="string">"List item two"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个复制出来的虚拟 dom 用来和原生 dom 进行比较，从而把比较出来的差异用创建的 diff 来保存。 diff 是像这个样子的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> diffs = [</span><br><span class="line">    &#123;</span><br><span class="line">        newNode: &#123; <span class="comment">/* new version of list item one */</span> &#125;,</span><br><span class="line">        oldNode: &#123; <span class="comment">/* original version of list item one */</span> &#125;,</span><br><span class="line">        index: <span class="comment">/* index of element in parent's list of child nodes */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        newNode: &#123; <span class="comment">/* list item two */</span> &#125;,</span><br><span class="line">        index: &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个 diff 提供了一个结构，这个结构可以用来更新原生的 dom。一旦所有的 diff 检测完毕，我们可以对原生 dom 只进行一次更新操作即可。</p><p>在下面的例子中，我们对 diff 进行循环，不论是添加新的元素还是更新旧的元素，我们都可以像下面这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domElement = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"list"</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">diffs.forEach(<span class="function">(<span class="params">diff</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newElement = <span class="built_in">document</span>.createElement(diff.newNode.tagName);</span><br><span class="line">    <span class="comment">/* Add attributes ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff.oldNode) &#123;</span><br><span class="line">        <span class="comment">// If there is an old version, replace it with the new version</span></span><br><span class="line">        domElement.replaceChild(diff.newNode, diff.index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no old version exists, create a new node</span></span><br><span class="line">        domElement.appendChild(diff.newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>虚拟dom是让我们与dom交互更加高效的且性能更好一种方法</li><li>虚拟dom是一个js对象，它允许我们对js对象进行频繁的修改</li><li>所有的修改在虚拟dom中结束后，我们可以一次性对原生dom中需要改变的地方进行更新</li></ul><h3 id="附录：snabbdom"><a href="#附录：snabbdom" class="headerlink" title="附录：snabbdom"></a>附录：snabbdom</h3><p>实现 vdom 的库不多，snabbdom 算是佼佼者。vue 中集成了它的核心代码，在每次修改数据后，都会执行函数进行 diff。下面总结一下非框架下vdom的使用方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn-submit"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/snabbdom/0.7.3/h.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上是html结构，引入不同的snabbdom文件是对应解析绑定的事件、属性等。首先使用 <code>patch(c, vnode)</code> 创建无序列表如下：</p><p><img src="/2019/01/01/vdom/i7eo_e5b8b50c2235d093133d181540a27ca4.png" alt=""></p><p>单击按钮再次调用 <code>patch</code> 函数即可生成：</p><p><img src="/2019/01/01/vdom/i7eo_f5991aaaa93507781a69bbf70d507739.png" alt=""></p><p>具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> snabbdom = <span class="built_in">window</span>.snabbdom</span><br><span class="line"></span><br><span class="line">      <span class="comment">// init snabbdom</span></span><br><span class="line">      <span class="keyword">let</span> patch = snabbdom.init([</span><br><span class="line">        snabbdom_class,</span><br><span class="line">        snabbdom_props,</span><br><span class="line">        snabbdom_style,</span><br><span class="line">        snabbdom_eventlisteners</span><br><span class="line">      ])</span><br><span class="line"></span><br><span class="line">      <span class="comment">//define h()</span></span><br><span class="line">      <span class="keyword">let</span> h = snabbdom.h</span><br><span class="line">      <span class="keyword">let</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">      <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn-submit'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create vnode</span></span><br><span class="line">      <span class="keyword">let</span> vnode = h(<span class="string">'ul#list'</span>, &#123;&#125;, [</span><br><span class="line">        h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item1'</span>),</span><br><span class="line">        h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item2'</span>)</span><br><span class="line">      ])</span><br><span class="line"></span><br><span class="line">      <span class="comment">// first time create vdom and transform it to dom</span></span><br><span class="line">      patch(c, vnode)</span><br><span class="line"></span><br><span class="line">      btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// define new node</span></span><br><span class="line">        <span class="keyword">let</span> newNode = h(<span class="string">'ul#list'</span>, &#123;&#125;, [</span><br><span class="line">          h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item1'</span>),</span><br><span class="line">          h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item22'</span>),</span><br><span class="line">          h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item3'</span>)</span><br><span class="line">        ])</span><br><span class="line">        <span class="comment">// find diffs , update diffs into original DOM</span></span><br><span class="line">        patch(vnode, newNode)</span><br><span class="line">        vnode = newNode</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>h 函数的作用是将传入的数据转化为vnode（vnode具体格式参照上述译文中的 copy），patch 函数先判断是否存在 vnode，不存在的话直接将 vnode，生成 dom，插入目标中；若存在进行 diff 算法，找出差异后对原生 dom 进行更新。</p><h3 id="动手模拟-patch-实现过程"><a href="#动手模拟-patch-实现过程" class="headerlink" title="动手模拟 patch 实现过程"></a>动手模拟 patch 实现过程</h3><p>patch 函数有俩种用法：</p><ul><li><code>patch(container, vnode)</code></li><li><code>patch(vnode, newNode)</code></li></ul><p>先来看第一种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'ul'</span>,</span><br><span class="line">    attrs: &#123;</span><br><span class="line">        id: <span class="string">'list'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">'li'</span>,</span><br><span class="line">            attrs: &#123;</span><br><span class="line">                classname: <span class="string">'item'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            children: [<span class="string">'item1'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先得将vnode转化为html结构，才能加入到container种，那么如何将上述js对象（vnode）转化为 html 呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEl</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tag = vnode.tag</span><br><span class="line">    <span class="keyword">let</span> attrs = vnode.attrs || &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> children = vnode.children || []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!tag) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(tag)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> attrName <span class="keyword">in</span> attrs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(attrs.hasOwnProperty(attrName))&#123;</span><br><span class="line">            el.setAttribute(attrName, attrs[attrName])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        el.append(createElement(v))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概就是这样，利用递归循环遍历 children，设置 <code>!tag</code> 为终止条件。</p><p>第二种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'ul'</span>,</span><br><span class="line">    attrs: &#123;</span><br><span class="line">        id: <span class="string">'list'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">'li'</span>,</span><br><span class="line">            attrs: &#123;</span><br><span class="line">                classname: <span class="string">'item'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            children: [<span class="string">'item12'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">'li'</span>,</span><br><span class="line">            attrs: &#123;</span><br><span class="line">                classname: <span class="string">'item'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            children: [<span class="string">'item2'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>item 12<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们想要将列表更新为上述结构，使用 <code>patch(vnode, newNode)</code> 方法，这个方法中肯定是要不断的去对比，不断的对比children肯定还会用到递归，模拟代码（只考虑最简单的情况）如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEl</span>(<span class="params">vnode, newNode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> children = vnode.children || []</span><br><span class="line">    <span class="keyword">let</span> newChildren = newNode.children || []</span><br><span class="line"></span><br><span class="line">    children.forEach(<span class="function">(<span class="params">child, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newChild = newChildren[idx]</span><br><span class="line">        <span class="keyword">if</span>(newChild === <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(child.tag === newChild.tag) &#123;</span><br><span class="line">            <span class="comment">// the same tag</span></span><br><span class="line">            updateEl(child, newChild)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// the different tag</span></span><br><span class="line">            replaceNode(child, newChild)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为译文，原文地址：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bitsofco.de/understanding-the-virtual-dom/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understanding the Virtual DOM&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我最近在写一些如何正确区分 dom 与 shadow dom 的文章。总的来说，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。shadow dom 可以被认为是轻量级版本的 dom。它同样是以原生对象为基础的 html document，但是它并不是完整的。可能有些难懂，换一种说法来看，shadow dom 允许我们去将我们的 dom 划分的更小，更轻，可以跨文档使用。（这里作者想表达的意思是我们可以根据需要截取部分 dom 生成 vdom，而不用每次从 html 标签开始写 vdom 直到 html 标签闭合）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另一个你可能遇到过的相似说法称 “shadow dom” 为 “virtual DOM”。尽管&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="虚拟Dom" scheme="https://i7eo.com/tags/%E8%99%9A%E6%8B%9FDom/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop总结</title>
    <link href="https://i7eo.com/2018/11/11/Event-Loop%E6%80%BB%E7%BB%93.html"/>
    <id>https://i7eo.com/2018/11/11/Event-Loop总结.html</id>
    <published>2018-11-11T14:33:12.000Z</published>
    <updated>2019-01-05T03:57:58.091Z</updated>
    
    <content type="html"><![CDATA[<p>之前也有 event loop 的概念，但一直都是琐碎的。直到阅读以下三篇文章后，琐碎的点串在了一起。</p><blockquote><p><a href="https://www.cnblogs.com/cangqinglang/p/8963557.html" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/33087629" target="_blank" rel="noopener">Event Loop的规范和实现</a></p></blockquote><p>为了印象深刻，还是决定自己写一写。总结如下：</p><h3 id="1、进程与线程的区别"><a href="#1、进程与线程的区别" class="headerlink" title="1、进程与线程的区别"></a>1、进程与线程的区别</h3><h4 id="1、什么是进程？"><a href="#1、什么是进程？" class="headerlink" title="1、什么是进程？"></a>1、什么是进程？</h4><p>在计算机操作系统中，只有进程才能在系统中运行。所以要使程序运行就必须为其创建进程。当我们打开浏览器时就已经创建了进程。创建进程之后，系统会为其分配资源(内存等)供其使用。</p><p><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>是程序（指令和数据）的真正运行实例。若干<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>有可能 …</p><a id="more"></a><p>与同一个程序相关系，且每个<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="noopener">进程</a>皆可以同步（循序）或异步（平行）的方式独立运行。</p><h4 id="2、什么是线程？"><a href="#2、什么是线程？" class="headerlink" title="2、什么是线程？"></a>2、什么是线程？</h4><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">线程</a>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">线程</a>指的是进程中一个单一顺序的控制流，一个进程中可以并发多个<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">线程</a>，每条<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">线程</a>并行执行不同的任务。</p><p><strong>总的来说进程是资源分配的最小单位，线程是计算机系统调度和分派的基本单位。线程基本上不拥有资源（也有一点必不可少的资源）它只专注于调度和分派，提高系统并发程度，但是它可以访问其隶属进程的资源。</strong></p><h3 id="2、浏览器是多进程"><a href="#2、浏览器是多进程" class="headerlink" title="2、浏览器是多进程"></a>2、浏览器是多进程</h3><p>上图来阐述，进入浏览器（chrome等）打开多个标签页，然后打开浏览器的 task manager。如下图：</p><p><img src="/2018/11/11/Event-Loop总结/i7eo_6e8f969201c7cd42ae589fe20d2fd558.png" alt=""></p><p>从图上来看，我们首先可以确定的是我打开的4个页面都是进程，因为它们有不同的 process id（进程标识符），这个是存在 PCB 中的，系统分配且唯一的数字标识符。PCB 是进程控制块，具体可搜索计算机操作系统-进程。</p><p>浏览器的主要进程有四个，分别为：主进程、GPU进程、浏览器渲染（render）进程（每个标签页都会一个渲染进程）、第三方插件进程。</p><p>主要来说说这四个进程的职责：</p><h4 id="1-主进程："><a href="#1-主进程：" class="headerlink" title="1. 主进程："></a>1. 主进程：</h4><ul><li>用户的前进、后退操作</li><li>每个标签页的创建与销毁</li><li>将渲染进程执行后生成的位图（bitmap）绘制在对应标签页上，呈现给用户</li><li>书签、下载等功能的管理</li></ul><h4 id="2-浏览器渲染进程"><a href="#2-浏览器渲染进程" class="headerlink" title="2. 浏览器渲染进程"></a>2. 浏览器渲染进程</h4><ul><li>页面渲染</li><li>脚本执行（事件、task）</li></ul><h4 id="3-GPU进程：用于3D绘制等"><a href="#3-GPU进程：用于3D绘制等" class="headerlink" title="3. GPU进程：用于3D绘制等"></a>3. GPU进程：用于3D绘制等</h4><h4 id="4-第三方插件进程：使用插件时创建"><a href="#4-第三方插件进程：使用插件时创建" class="headerlink" title="4. 第三方插件进程：使用插件时创建"></a>4. 第三方插件进程：使用插件时创建</h4><p>主要来说下浏览器渲染进程，这个进程是当前标签的控制者。js 代码的执行、事件的触发、页面的展示等都由它负责。那么这一个进程可以同时干这么多事情吗？它一个当然是可以的，但是如果一个人来做就会浪费资源而且一旦执行脚本文件后会不断阻塞页面执行。至此，引入了线程来解决这个问题。</p><h3 id="3、Javascript-的单线程"><a href="#3、Javascript-的单线程" class="headerlink" title="3、Javascript 的单线程"></a>3、Javascript 的单线程</h3><p>在渲染进程中划分了很多个线程，这里介绍一些常驻线程：</p><h5 id="1-JS-线程（引擎线程，即常说的那个js单线程）"><a href="#1-JS-线程（引擎线程，即常说的那个js单线程）" class="headerlink" title="1. JS 线程（引擎线程，即常说的那个js单线程）"></a>1. JS 线程（引擎线程，即常说的那个js单线程）</h5><ul><li>运行环境（v8），负责处理 js 脚本</li><li>每个标签页只有一个 js 线程在执行代码</li><li>js 线程与 Gui 渲染线程互斥，js 执行时间过长会导致页面渲染的阻塞（互斥原因下面阐述</li></ul><h5 id="2-GUI-渲染线程"><a href="#2-GUI-渲染线程" class="headerlink" title="2. GUI 渲染线程"></a>2. GUI 渲染线程</h5><ul><li>负责渲染页面（构建dom 树 &amp; cssparser 树 &amp; renderobject 树）</li><li>当页面出现重绘或回流（repaint/reflow）时，会调用该线程</li><li>与 js 线程互斥</li></ul><h5 id="3-事件触发线程：遵循先进先出的原则在异步队列中等待-js-线程处理。（异步队列下面会解释）"><a href="#3-事件触发线程：遵循先进先出的原则在异步队列中等待-js-线程处理。（异步队列下面会解释）" class="headerlink" title="3. 事件触发线程：遵循先进先出的原则在异步队列中等待 js 线程处理。（异步队列下面会解释）"></a>3. 事件触发线程：遵循先进先出的原则在异步队列中等待 js 线程处理。（异步队列下面会解释）</h5><h5 id="4-定时器触发线程"><a href="#4-定时器触发线程" class="headerlink" title="4. 定时器触发线程"></a>4. 定时器触发线程</h5><ul><li>定时器并不是在某段时间后执行，而是在某时间后被添加至异步队列，等 js 线程空闲后执行</li><li>W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li></ul><h5 id="5-http-请求线程：请求成功后会把回调放入异步队列中。"><a href="#5-http-请求线程：请求成功后会把回调放入异步队列中。" class="headerlink" title="5. http 请求线程：请求成功后会把回调放入异步队列中。"></a>5. http 请求线程：请求成功后会把回调放入异步队列中。</h5><h5 id="6-备注：上述执行环境是在浏览器中，如果执行环境换为-node-的话，还有-I-O-线程与-setImmediate"><a href="#6-备注：上述执行环境是在浏览器中，如果执行环境换为-node-的话，还有-I-O-线程与-setImmediate" class="headerlink" title="6. 备注：上述执行环境是在浏览器中，如果执行环境换为 node 的话，还有 I/O 线程与 setImmediate"></a>6. 备注：上述执行环境是在浏览器中，如果执行环境换为 node 的话，还有 I/O 线程与 setImmediate</h5><h3 id="3、为什么说-JS-线程与-GUI-渲染线程互斥（js-代码会阻塞渲染）？"><a href="#3、为什么说-JS-线程与-GUI-渲染线程互斥（js-代码会阻塞渲染）？" class="headerlink" title="3、为什么说 JS 线程与 GUI 渲染线程互斥（js 代码会阻塞渲染）？"></a>3、为什么说 JS 线程与 GUI 渲染线程互斥（js 代码会阻塞渲染）？</h3><p>GUI 渲染线程第一个构建的是 dom 树，js 代码也有可能会修改 dom 结构，一旦修改就会引起 重绘或回流，这就会导致 GUI 线程的再次从头开始。为了避免这样的事情发生所以采用了这种互斥的策略。俩者并不能在同一时间进行。</p><h3 id="4、异步的实现方案-event-loop"><a href="#4、异步的实现方案-event-loop" class="headerlink" title="4、异步的实现方案 - event loop"></a>4、异步的实现方案 - event loop</h3><p>针对于 js 引擎单线程这种情况，为了不让程序（被 http 请求、定时器等）阻塞，所以有了异步的概念。但是在现代 web 程序开发中，代码量越来越大。为了能让越来越多的定时器、事件、请求有序且规范的执行，event loop 方案出现了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br></pre></td></tr></table></figure><p>上述代码的执行结果是：1 3 6 4 5 2</p><p>首先介绍 task &amp; microtask：</p><ul><li>task 主要包括：setTimeout、setInterval、setImmediate、I/O、UI交互事件</li><li>microtask 主要包括：Promise、<a href="https://nodejs.org/api/process.html" target="_blank" rel="noopener">process.nextTick</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe" target="_blank" rel="noopener">MutationObserver</a>（在node中 process.nextTick 的优先级高于 promise）</li></ul><p>task &amp; microtask 在当前标签页中拥有俩个队列来分别存储 task &amp; microtask除了 js &amp; gui 线程，其他每个线程执行时都会按照 task都有一个异步队列来控制顺序。如下图</p><p><img src="/2018/11/11/Event-Loop总结/i7eo_b879476dd053c59cfd42b8fe4cdfa137.png" alt="Event Loop"></p><p>Event Loop 过程如下：</p><ol><li>整个script代码作为 task 执行时先判断是同步任务还是异步任务</li><li>同步任务依次进入 js 线程，依次执行</li><li>异步任务<strong>先在 table 中注册</strong>，然后<strong>当任务完成时</strong>按照 task/microtask 区分开来，依次进入不同的异步队列</li><li>js 线程执行完毕后（执行栈为空）先读取 microtask 的异步队列，全部执行完毕（队列为空后），再去读取 task 的异步队列，<strong>task 异步队列中的任务若包含 microtask 则再次去读取 microtask 异步队列</strong>。</li><li>上述过程不断重复，直至 task 异步队列为空。整个过程即为 Event Loop。</li></ol><p>还是直接来看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>详细过程请参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/33087629" target="_blank" rel="noopener">Event Loop的规范和实现</a></p></blockquote><p>输出：1 7 8 2 4 5 9 11 12</p><p>那如果执行环境切换为 node，node 的 Event loop的实现与浏览器稍有差异。具体如下：</p><p><img src="/2018/11/11/Event-Loop总结/i7eo_6474957a85872c82bdf475ba406ffe10.png" alt="node - event loop"></p><p>需要注意的是：</p><ul><li>expired timers and intervals queue 这个异步队列专门来存储所有的 setTimeout/setInterval</li><li>immediates queue 这个异步队列专门来存储所有的 setImmediate</li><li>next tick queue 专门来存储所有的 process.nextTick</li><li>node 清空 queue 时会执行所有 task（不论时 task 还是 microtask）</li></ul><p>那么以下代码的结果呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">11</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">12</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>js 执行栈为空，microtask queue 为空时，去检查 task queue，发现俩个 settimeout 这时<strong>依次执行</strong>。这里与浏览器环境不同，浏览器环境是从 task queue 读出一个 task 先执行，执行完后去检查 microtask queue，而 node 中是一次性执行完 task queue，再去检查 micrtask queue（比如 process.nextTick、promise 等）</p><p>输出：1 7 6 8 2 4 9 11 3 10 5 12</p><p>分析过程请参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/33087629" target="_blank" rel="noopener">Event Loop的规范和实现</a></p></blockquote><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul><li>js 是一门单线程语言</li><li>event loop 是 js 的执行机制</li></ul><p>参考资料：</p><ul><li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a></li><li><a href="https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c" target="_blank" rel="noopener">What you should know to really understand the Node.js Event Loop</a></li><li><a href="https://jsblog.insiderattack.net/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2-2c53fd511bb3?gi=d90233a38d18" target="_blank" rel="noopener">Timers, Immediates and Process.nextTick</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前也有 event loop 的概念，但一直都是琐碎的。直到阅读以下三篇文章后，琐碎的点串在了一起。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cangqinglang/p/8963557.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/59e85eebf265da430d571f89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这一次，彻底弄懂 JavaScript 执行机制&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33087629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Event Loop的规范和实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了印象深刻，还是决定自己写一写。总结如下：&lt;/p&gt;
&lt;h3 id=&quot;1、进程与线程的区别&quot;&gt;&lt;a href=&quot;#1、进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;1、进程与线程的区别&quot;&gt;&lt;/a&gt;1、进程与线程的区别&lt;/h3&gt;&lt;h4 id=&quot;1、什么是进程？&quot;&gt;&lt;a href=&quot;#1、什么是进程？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是进程？&quot;&gt;&lt;/a&gt;1、什么是进程？&lt;/h4&gt;&lt;p&gt;在计算机操作系统中，只有进程才能在系统中运行。所以要使程序运行就必须为其创建进程。当我们打开浏览器时就已经创建了进程。创建进程之后，系统会为其分配资源(内存等)供其使用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程&lt;/a&gt;是程序（指令和数据）的真正运行实例。若干&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程&lt;/a&gt;有可能 …&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="EventLoop" scheme="https://i7eo.com/tags/EventLoop/"/>
    
  </entry>
  
  <entry>
    <title>HTTP笔记(下)</title>
    <link href="https://i7eo.com/2018/11/06/HTTP1-02.html"/>
    <id>https://i7eo.com/2018/11/06/HTTP1-02.html</id>
    <published>2018-11-06T14:48:44.000Z</published>
    <updated>2019-01-13T08:15:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>跨域、缓存这些都是开发中常常遇到的，做些笔记供日后查阅。</p><h3 id="CORS（Cross-Origin-Resource-Sharing）跨源资源分享"><a href="#CORS（Cross-Origin-Resource-Sharing）跨源资源分享" class="headerlink" title="CORS（Cross-Origin Resource Sharing）跨源资源分享"></a>CORS（Cross-Origin Resource Sharing）跨源资源分享</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源策略（<a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank" rel="noopener">same-origin policy</a>）是浏览器保障安全的一种方法。<br>主要指的是在同协议，同域名，同端口下才能访问资源。为什么要这样限制？假设某用户登陆了自己的网上网上银行，接着去访问了其他网站，如果没有同源策略的限制，那么其他网站就可以访问银行网站的cookie，而cookie一般存放着与用户相关的某些信息，这样用户的信息就会被泄漏或者被冒名顶替去访问网上银行。</p><a id="more"></a><h4 id="CORS-amp-JSONP"><a href="#CORS-amp-JSONP" class="headerlink" title="CORS &amp; JSONP"></a>CORS &amp; JSONP</h4><p>正是源于上述的策略，导致在开发中出现跨域的问题。那么如何跨过这个限制呢？常见的有：</p><ul><li>cors</li><li>jsonp</li><li>websocket</li><li>postMessage</li><li>iframe</li><li>…</li></ul><p>具体可以参考这篇文章：<a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener"><br>前端常见跨域解决方案（全）</a><br>这里主要说一说常见的 cors 与 jsonp</p><h5 id="CROS"><a href="#CROS" class="headerlink" title="CROS"></a>CROS</h5><p>CORS 指的是跨源资源分享，具体的实现分为俩类：</p><ul><li>简单请求（simple request）</li><li>预请求（preflight request）</li></ul><p>对于能满足以下俩大条件的即为简单请求：</p><ol><li>请求方法是以下三种之一：</li></ol><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><ol start="2"><li>http 的头信息不能超出以下几种字段：</li></ol><ul><li>Accept</li><li>Accept - Language</li><li>Content - Language</li><li>Content - type<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li><li><a href="https://httpwg.org/http-extensions/client-hints.html#viewport-width" target="_blank" rel="noopener">Viewport-Width</a></li><li><a href="https://httpwg.org/http-extensions/client-hints.html#dpr" target="_blank" rel="noopener">DPR</a></li><li><a href="https://httpwg.org/http-extensions/client-hints.html#downlink" target="_blank" rel="noopener">Downlink</a></li><li><a href="https://httpwg.org/http-extensions/client-hints.html#save-data" target="_blank" rel="noopener">Save-Data</a></li><li><a href="https://httpwg.org/http-extensions/client-hints.html#width" target="_blank" rel="noopener">Width</a></li></ul><p>而不满足如上条件的即为预请求。</p><p>假设现在开启了端口8888、8887 俩个 node 服务，当8888上的页面请求8887的时候，请求其实是已经发送到了8887。请求头中多出了 <code>origin</code> 字段，但是此时服务器中并没有设置相应的 <code>Access-Control-Allow-Origin</code> 所以当请求从8887返回给浏览器后，浏览器阻挡了该请求:</p><p><img src="/2018/11/06/HTTP1-02/i7eo_1c52b0af524198a362d4c1b1ae4571f7.png" alt=""></p><p>解决办法就是在8887上的响应头中添加 <code>&#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;</code> 这里的 * 表示通配符，当然你还可以根据需要设置成单一的地址，比如：<code>&#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39;</code> 。</p><p>当你在请求头中设置了 PUT 或者 自定义信息（token 等）这个时候需要在响应头上添加：<code>&#39;Access-Control-Allow-Methods&#39;: &#39;PUT, Delete&#39;, &#39;Access-Control-Allow-Headers&#39;: &#39;Token&#39;</code>,这是为了让服务器支持对应的信息，这里需要注意的是在8888发送请求前会多发送一条方法为 <code>OPTIONS</code>的请求来进行预请求。还可以设置时间使接下来的请求中不带有这条预请求，即：<code>&#39;Access-Control-Max-Age&#39;: &#39;1000&#39;</code>（单位为秒）在 1000s 内不会再发送预请求。</p><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>浏览器允许跨域资源的嵌入。具体如下：</p><ul><li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。</li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code> 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头</li><li><code>&lt;img&gt;</code>嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG…</li><li><code>&lt;video&gt;</code>和 <code>&lt;audio&gt;</code>嵌入多媒体资源。</li><li><code>&lt;frame&gt;</code> 和 <code>&lt;iframe&gt;</code></li><li>@font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。</li><li><code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code> 和 <code>&lt;applet&gt;</code> 的插件。</li></ul><p>jsonp 正式运用了第一条规则,将数据利用如下形式包装在请求的js文件中：<code>cors({})</code> 然后在发出请求的地址后面加上 <code>callback=cors</code> 即可通过 <code>cors</code> 获得数据。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>浏览器的缓存有俩种，即强缓存与协商缓存。具体选用哪一种由 header 的设置来决定。</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存有浏览器设置在内存中，直接从内存中读取，而不去服务器拉取数据。</p><p>强缓存的具体设置有俩种：</p><ol><li>http 1.0 中设置 expires。如：<code>&#39;expires&#39;: &#39;Mon, 10 Jun 2015 21:31:12 GMT&#39;</code> 发送请求的时间在此之前，缓存均有效。</li><li>http 1.1 中设置 cache-control 。如：<code>&#39;cache-control&#39;: &#39;max-age=20&#39;</code>（单位为秒）<br>这里需要注意的是，一般使用 cache-control （客户端缓存）时，设置的时间都较长。此时如果修改js文件的话，是不会生效的。解决方法就是在项目构建文件中跟js文件的内容生成hash值，这样强缓存就会及时更新。还可以设置其他属性，如下：</li></ol><ul><li>可缓存性：<ul><li>public 除了浏览器与服务器，代理服务器也可以缓存</li><li>private 只有发起请求的浏览器才可以缓存</li><li>no-cache 需要与服务器进行协商，是否能使用本地缓存</li><li>no-store 本地与缓存服务器均不能使用缓存</li></ul></li><li>到期<ul><li>max-age</li><li>s-maxage 只有在代理服务器中生效</li><li>max-stale 指发起请求方缓存过期后还可以使用过期缓存的时间</li></ul></li><li>重新验证<ul><li>must-revalidate 在max-age过期后，重新发送请求验证是否真正过期</li><li>proxy-revalidate 在max-age过期后，重新发送请求至缓存服务器验证是否真正过期</li></ul></li><li>其他<ul><li>no-transform 告诉proxy不要压缩缓存</li></ul></li></ul><p>例子：<code>&#39;cache-control&#39;: &#39;public, max-age=200, no-cache&#39;</code></p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>Last-Modified/Etag 是协商缓存的俩种方式，都是在服务器端的响应头中设置。不同之处在于：</p><ol><li>一些文件可能会定时的更新，但是内容未被更改。这个时候如果使用 Last-Modified 的话就会被认为文件被修改了，而 etag 则不会，因为 etag 是服务器上每个资源的唯一标识。可以根据文件内容生成 hash 来设置 etag。</li><li>对于某些修改频繁的文件来说，频率在秒以内。Last-Modified 只能精确到秒，所以这种情况无法判断。</li></ol><p>这俩者的值可以随便设置，没有具体的规定。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p>具体过程：</p><ol><li>在服务端响应头上设置 <code>&#39;Last-Modified&#39;: &#39;&#39;</code></li><li>请求再次发送到服务器后，请求头中会出现 <code>&#39;If-Modified-Since&#39;: &#39;&#39;</code> (这个值与上述设置的值相同)</li><li>再次发送请求到服务器后会判断俩者的值，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，浏览器就会从内存中读取缓存。这个动作就是协商后的结果。</li><li>如果缓存没有命中，就直接从服务器加载数据。此时会更新响应头中的 <code>Last-Modified</code>的信息，供下次对比使用。</li></ol><h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h5><p>etag 具体过程与上相同。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>虽说没有具体规定要设置的值，但是 <code>Last-Modified</code> 一般设置为时间，即文件最后一次的更新时间。而 <code>Etag</code> 则设置为根据内容生成的 hash 值。</p><p>参考文章：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a></p></li><li><p><a href="https://fetch.spec.whatwg.org/#content-type-header" target="_blank" rel="noopener">Fetch Standard</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;跨域、缓存这些都是开发中常常遇到的，做些笔记供日后查阅。&lt;/p&gt;
&lt;h3 id=&quot;CORS（Cross-Origin-Resource-Sharing）跨源资源分享&quot;&gt;&lt;a href=&quot;#CORS（Cross-Origin-Resource-Sharing）跨源资源分享&quot; class=&quot;headerlink&quot; title=&quot;CORS（Cross-Origin Resource Sharing）跨源资源分享&quot;&gt;&lt;/a&gt;CORS（Cross-Origin Resource Sharing）跨源资源分享&lt;/h3&gt;&lt;h4 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h4&gt;&lt;p&gt;同源策略（&lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;same-origin policy&lt;/a&gt;）是浏览器保障安全的一种方法。&lt;br&gt;主要指的是在同协议，同域名，同端口下才能访问资源。为什么要这样限制？假设某用户登陆了自己的网上网上银行，接着去访问了其他网站，如果没有同源策略的限制，那么其他网站就可以访问银行网站的cookie，而cookie一般存放着与用户相关的某些信息，这样用户的信息就会被泄漏或者被冒名顶替去访问网上银行。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://i7eo.com/categories/HTTP/"/>
    
    
      <category term="CORS" scheme="https://i7eo.com/tags/CORS/"/>
    
      <category term="缓存" scheme="https://i7eo.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP笔记(上)</title>
    <link href="https://i7eo.com/2018/11/03/HTTP1-0.html"/>
    <id>https://i7eo.com/2018/11/03/HTTP1-0.html</id>
    <published>2018-11-03T02:02:35.000Z</published>
    <updated>2019-01-06T15:45:24.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP-基础"><a href="#HTTP-基础" class="headerlink" title="HTTP 基础"></a>HTTP 基础</h3><h4 id="网络间通信的大体流程"><a href="#网络间通信的大体流程" class="headerlink" title="网络间通信的大体流程"></a>网络间通信的大体流程</h4><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">概念</th><th style="text-align:left">常用协议</th></tr></thead><tbody><tr><td style="text-align:left">应用层</td><td style="text-align:left">为应用程序提供服务</td><td style="text-align:left">HTTP/FTP/SMTP</td></tr><tr><td style="text-align:left">表示层</td><td style="text-align:left">定义数据格式及加密</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">会话层</td><td style="text-align:left">定义了如何开始、控制和结束一个会话</td><td style="text-align:left">SSL</td></tr><tr><td style="text-align:left">传输层</td><td style="text-align:left">向用户提供端到端的服务</td><td style="text-align:left">TCP/UDP</td></tr><tr><td style="text-align:left">网络层</td><td style="text-align:left">数据在俩个机器间创建逻辑链路</td><td style="text-align:left">IP(IPV4/IPV6)、ARP</td></tr><tr><td style="text-align:left">数据链路层</td><td style="text-align:left">通信实体间建立数据链路连接</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">物理层</td><td style="text-align:left">定义物理设备间如何传输比特流的规范（网线、光缆等硬件）</td></tr></tbody></table><p>osi 模型较为复杂，一般常说的是五层模型：</p><p>物理层 -&gt; 数据链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层</p><a id="more"></a><p>下面这张图用来简单描述俩台通过路由器联系起来的主机的数据是如何传输的。</p><p><img src="/2018/11/03/HTTP1-0/i7eo_519e65e5e25f00ef5a81add83a0c3d79.png" alt=""></p><p>假设主机1的程序ap1向主机2的程序ap2传送数据。ap1先将数据交给第5层（应用层）。第5层<strong>加上必要的控制信息h5传递给下一层</strong>，以此类推。需要注意的是数据到达第2层（数据链路层）后，控制信息分成俩部分，分别加到本层数据单元的首部（h2）和尾部（t2）；而第1层由于是比特流传送即0101…所以不必加上控制信息，但是物理层是从首部开始传递数据。</p><p>这一串比特流离开主机1后通过物理媒介传递到路由器，从路由器的第1层（物理层）依次上升至第3层（网络层）每一层都会对控制信息进行操作，操作后将控制信息剥去将剩下的数据向上传送，当到达第3层后就会<strong>根据首部的目的地址查找路由器中的路由表，找出转发分组的接口</strong>，然后从第3层向下传递至第1层，转为比特流之后传递给主机2，主机2的过程与上类似，最终程序ap2收到传输的数据。</p><p>在我们平时上网浏览网页时，通常都是我们的电脑与服务器的数据交互，中间过程不是像上述描述的只经过一个路由器这么简单，期间会经过dns服务器、cdn服务器等等。这里着重记录关于 http 部分的知识。</p><h4 id="HTTP-不同版本特点对比"><a href="#HTTP-不同版本特点对比" class="headerlink" title="HTTP 不同版本特点对比"></a>HTTP 不同版本特点对比</h4><p>HTTP/0.9 ：</p><ul><li>只有一个 GET 命令</li><li>没有 header 等描述信息</li><li>服务器发送完毕，tcp连接被关闭</li></ul><p>HTTP/1.0</p><ul><li>增加 POST/PUT 等命令</li><li>增加 header &amp; status code 信息</li><li>支持多字符集、多部分发送，缓存等</li></ul><p>HTTP/1.1</p><ul><li>使tcp连接持久化</li><li>pipeline（客户端可以发送多个http请求，但是服务端必须按顺序返回）</li><li>增加host与其他命令（利用host中的端口判断具体属于node还是java等）</li></ul><p>HTTP/2.0</p><ul><li>数据以二进制传输（2.0之前数据传输是已字符串传输）</li><li>对于客户端发送的多个http请求，服务器返回时不用按照顺序返回，可以并行返回</li><li>头信息压缩，增加了推送等提高效率的功能</li></ul><p>需要注意的是：</p><ul><li>理论上来说一个tcp连接中可以存在多个http请求，但是目前的做法是http1.1中一个tcp链接上同时最多只有一个http请求</li><li>并发量一般指的是tcp连接的并发量</li></ul><p>各个浏览器对应的tcp并发数量详情可查看：<br><a href="https://blog.csdn.net/jueshengtianya/article/details/38271081" target="_blank" rel="noopener">主流浏览器的HTTP最大并发连接数</a></p><h4 id="HTTP-的三次握手"><a href="#HTTP-的三次握手" class="headerlink" title="HTTP 的三次握手"></a>HTTP 的三次握手</h4><p><img src="/2018/11/03/HTTP1-0/i7eo_2aa7ba936cdaf5772435de872d3f18d2.png" alt=""></p><p>具体情况如上图，这里的 syn 代表同步位，seq 代表序号，ack 代表确认号。需要注意的是当首次握手发生时，即客户端进入 SYN-SENT状态前，不能携带数据，当发生二次握手时，即服务器进入SYN-RECV状态前，也是不能携带数据的，当发生第三次握手时即客户端进入ESTAB-LISHED状态前，<strong>可以携带数据。</strong></p><p>为什么需要三次握手？<br>因为tcp要保证传输的数据可靠性，但是信道（数据链路层）传输是不可靠的。如何保证tcp传输的数据是可靠的？只能在tcp连接建立前保证通道畅通。因为在三次握手的过程中有网络延迟、包丢失等原因，所以才有了三次握手，三次握手是理论上的最小值。具体分析请参考：<a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a> 、<a href="https://www.jianshu.com/p/e7f45779008a" target="_blank" rel="noopener">tcp建立连接为什么需要三次握手</a></p><h4 id="补充：套接字（socket）"><a href="#补充：套接字（socket）" class="headerlink" title="补充：套接字（socket）"></a>补充：套接字（socket）</h4><p>平常我们在使用自己电脑测试移动端页面或者是自己在写程序连接某项服务时都会使用 ip + 端口号 来连接，这是为什么呢？</p><p>因为这些做法都使用了tcp连接，而tcp把连接作为最基本的抽象。在tcp的俩端分别有俩个端点，端点叫做套接字。rfc 793 定义：端口号拼接到 ip 地址构成了套接字。如下图：</p><p><img src="/2018/11/03/HTTP1-0/i7eo_c3ad664d8759aeed097490aee8830038.png" alt=""></p><p>同一个ip地址可以有多个tcp连接，而同一个端口号也可以出现在多个不同的tcp连接中。</p><h4 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h4><p><img src="/2018/11/03/HTTP1-0/i7eo_2635b93238bf4d0760e51199dca77949.png" alt=""></p><p>这是一个很简单的请求与响应报文格式图。需要注意的是响应报文的首部结尾是空行。响应报文中具体的status code 请参考：<a href="https://blog.csdn.net/l_mloveforever/article/details/82892292" target="_blank" rel="noopener">常见的HTTPRequest状态码说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP-基础&quot;&gt;&lt;a href=&quot;#HTTP-基础&quot; class=&quot;headerlink&quot; title=&quot;HTTP 基础&quot;&gt;&lt;/a&gt;HTTP 基础&lt;/h3&gt;&lt;h4 id=&quot;网络间通信的大体流程&quot;&gt;&lt;a href=&quot;#网络间通信的大体流程&quot; class=&quot;headerlink&quot; title=&quot;网络间通信的大体流程&quot;&gt;&lt;/a&gt;网络间通信的大体流程&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;名称&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;概念&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;常用协议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;应用层&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;为应用程序提供服务&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;HTTP/FTP/SMTP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示层&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;定义数据格式及加密&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;会话层&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;定义了如何开始、控制和结束一个会话&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;SSL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;传输层&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;向用户提供端到端的服务&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;TCP/UDP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;网络层&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;数据在俩个机器间创建逻辑链路&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;IP(IPV4/IPV6)、ARP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;数据链路层&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;通信实体间建立数据链路连接&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;物理层&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;定义物理设备间如何传输比特流的规范（网线、光缆等硬件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;osi 模型较为复杂，一般常说的是五层模型：&lt;/p&gt;
&lt;p&gt;物理层 -&amp;gt; 数据链路层 -&amp;gt; 网络层 -&amp;gt; 传输层 -&amp;gt; 应用层&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://i7eo.com/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS元素嵌套问题</title>
    <link href="https://i7eo.com/2018/09/05/CSS%E5%85%83%E7%B4%A0%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98.html"/>
    <id>https://i7eo.com/2018/09/05/CSS元素嵌套问题.html</id>
    <published>2018-09-05T13:30:39.000Z</published>
    <updated>2019-01-05T06:45:07.511Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回顾了一下之前的代码，发现一个css中的坑即层叠顺序。什么叫层叠顺序？简单来说就是在屏幕上某一个位置堆积了很多 <code>div</code> 这些块哪个在上哪个在下的关系就是层叠顺序。（下面代码演示了三层堆叠）</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test2</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">260px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">130px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test3</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test4</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的html结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test4"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2018/09/05/CSS元素嵌套问题/i7eo_a3e3f0589b44e1eb85a387e0b8fa7d38.png" alt=""></p><p>如图所示，都是水平垂直居中的。这里我们主要关注层叠顺序。此时三者均为绝对定位，由test2开始从下到上依次是 test2 -&gt; test3 -&gt; test4 这样的顺序。test4位于最上方，此时想让test3与test4位置颠倒且test2位置不变（由下到上的顺序为test2 -&gt; test4 -&gt; test3），应该怎么做？<br>肯定首先想到使用 z-index：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test3</span> &#123;</span><br><span class="line">  //...</span><br><span class="line">  <span class="selector-tag">z-index</span>: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.test4</span> &#123;</span><br><span class="line">  //..</span><br><span class="line">  <span class="selector-tag">z-index</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改结果并不会改变。为什么？既然 z-index 不生效那我们肯定先去查 z-index 。</p><blockquote><p>对于一个已经定位的元素（即position属性值是非static的元素），z-index 属性指定：<br>元素在当前堆叠上下文中的堆叠层级。<br>元素是否创建一个新的本地层叠上下文。</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="noopener">MDN : z-index</a></p><p>根据mdn的介绍来看，我们设定了堆叠层级，这样来说是应该可以的。但是结果却不尽人意。留意一下层叠上下文，是否跟创建的层叠上下文有关呢？<br>常见的创建层叠上下文（stacking context）的方式有：</p><ul><li><p>z-index 值不为 “auto”的 绝对/相对定位</p></li><li><p>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex</p></li></ul><p>可能你并没有意识，但你确实会常常这样为html标签创建样式并为它创建了层叠上下文。</p><p>层叠上下文的特点：(mdn)</p><ol><li>给一个 HTML 元素定位和 z-index 赋值创建一个层叠上下文，（opacity 值不为 1 的也是相同）。</li><li>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个有层级的层叠上下文。</li><li>每个层叠上下文完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</li><li>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会 在父层叠上下文中 按顺序进行层叠。</li></ol><p>具体的层叠关系如下图：</p><p><img src="/2018/09/05/CSS元素嵌套问题/i7eo_5a1d655846a04a4367b22766f24cf0a0.png" alt=""></p><p><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解CSS中的层叠上下文和层叠顺序</a></p><p>对于当前代码来说，我创建了三个层叠上下文元素并且一一嵌套。当我们设置test3的z-index时，test4是test3的子元素（层叠上下文特点3），会影响到test4。此时test3与test4一同来到了test2上方（其实也就是保持了原位置，因为test2没有设置zindex所以没有层叠上下文）。<br>这个时候再设置test4的z-index，相当于俩个层叠上下文元素在比较z-index，那按照上图所示的比较规则，test3的z-index只要大于test4就能在上面了，那为什么还是不变呢？我们来看看大神的解释：</p><p>层叠上下文元素有如下特性：（<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">理解元素层叠上下文-张鑫旭</a>）</p><blockquote><p>1、层叠上下文的层叠水平要比普通元素高（原因后面会说明）；</p></blockquote><blockquote><p>2、层叠上下文可以阻断元素的混合模式；</p></blockquote><blockquote><p>3、层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</p></blockquote><blockquote><p>4、每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</p></blockquote><blockquote><p>5、每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</p></blockquote><p>根据上面第3点我们知道了内部层叠受制于外部层叠，结合代码也就是说只要test3设置了z-index，那它就会带着test4一起走。当test4设置z-index时，<strong>首先要判断设置的值和test3的z-index正负是否相同，如果都为正（同为负），无论大小test3与test4的位置永不会变</strong>。既然设置俩个正值作为z-index行不通，那我们试试一正一负行得通吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先设置test4的z-index为-1，此时只有一个层叠上下文test4，并且层叠顺序为：由test4开始从下到上依次是 test4 -&gt; test2 -&gt; test3 这样的顺序。test3位于最上方，此时如果给test3的z-index赋正值会导致test4重回原位置（test3上方），赋负值会导致test3来到了test2之下，不符合要求。既然父级元素没有操作空间了，试试父父级元素test2，根据特点3我们猜想如果test2的z-index设置正值那么会把test3（包括test4）这个整体共同带到test2之上的位置。如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2763803-ae96de8a5feb15ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="test.png"></p><p>在改变test4的z-index之后（为了看得更清晰我手动改变了长宽）我们发现达到了效果。设置父父级（test2）的z-index为1之后拥有了层叠上下文，test4设置z-index为-1也拥有了层叠上下文。<strong>此时test3作为普通的绝对定位元素保留在原位置（为了方便理解所以这样描述，这里test3其实是bfc发挥了作用），因为test2是父父级符合特点3，所以将位于底下的test4带了上来，但是test4属于test3的子元素，上来后就去和test3比较，因为test3不拥有层叠上下文保留在原位置，而此时test4的z-index为负值，所以在test3之下，test2之上显示</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里说了三个块级元素，大家还可以试试嵌套行内元素是什么效果。需要注意的是伪元素创建层叠上下文的表现是否和上面一样呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">260px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">130px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test1</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">animation</span>: breathe infinite ease-in-out <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> breathe&#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">transform</span>:<span class="built_in">scale</span>(.5);</span><br><span class="line">        <span class="attribute">opacity</span>:.<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    95% &#123;</span><br><span class="line">      <span class="attribute">transform</span>:<span class="built_in">scale</span>(1.5);</span><br><span class="line">      <span class="attribute">opacity</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">transform</span>:<span class="built_in">scale</span>(.9);</span><br><span class="line">        <span class="attribute">opacity</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>html如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个其实就是我遇到的问题，用伪元素创建了层叠上下文，我想让伪元素动画出现在test1的下方test的上方。和上面一样分别设置z-index为-1和1即可达到效果。</p><p>参考资料：</p><ul><li><p><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解CSS中的层叠上下文和层叠顺序</a></p></li><li><p><a href="https://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/" target="_blank" rel="noopener">CSS深入理解流体特性和BFC特性下多栏自适应布局</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">层叠上下文</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/Stacking_context_example_2" target="_blank" rel="noopener">Stacking_context_example_2</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/Stacking_context_example_3" target="_blank" rel="noopener">Stacking_context_example_3</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;回顾了一下之前的代码，发现一个css中的坑即层叠顺序。什么叫层叠顺序？简单来说就是在屏幕上某一个位置堆积了很多 &lt;code&gt;div&lt;/code&gt; 这些块哪个在上哪个在下的关系就是层叠顺序。（下面代码演示了三层堆叠）&lt;/p&gt;
    
    </summary>
    
      <category term="HTML&amp;CSS" scheme="https://i7eo.com/categories/HTML-CSS/"/>
    
    
      <category term="层叠上下文" scheme="https://i7eo.com/tags/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt.js踩坑实录</title>
    <link href="https://i7eo.com/2018/07/04/Nuxt.js%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95.html"/>
    <id>https://i7eo.com/2018/07/04/Nuxt.js踩坑实录.html</id>
    <published>2018-07-04T15:22:36.000Z</published>
    <updated>2019-01-05T03:57:01.319Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。</p><h3 id="CSR-amp-SSR"><a href="#CSR-amp-SSR" class="headerlink" title="CSR &amp; SSR"></a>CSR &amp; SSR</h3><h4 id="什么是-CSR"><a href="#什么是-CSR" class="headerlink" title="什么是 CSR ?"></a>什么是 CSR ?</h4><p>CSR =&gt; client-side-reder，即客户端渲染。具体过程如下：</p><ul><li>用户请求页面，返回页面。此时页面只是模版页面</li><li>浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据</li><li>得到返回数据后使用模版（vue/react/ng/art-template）进行渲染<h4 id="什么是-SSR"><a href="#什么是-SSR" class="headerlink" title="什么是 SSR ?"></a>什么是 SSR ?</h4></li></ul><a id="more"></a><p>SSR =&gt; server-side-render，即服务器端渲染。具体过程如下：</p><ul><li>用户请求页面</li><li>后端取到准备好的数据，渲染到我们自己写的服务器模版（next/nuxt/ejs）中，准备好html结构与相应数据后返回给浏览器</li></ul><h4 id="CSR-amp-SSR-优缺点对比"><a href="#CSR-amp-SSR-优缺点对比" class="headerlink" title="CSR &amp; SSR 优缺点对比"></a>CSR &amp; SSR 优缺点对比</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">CSR</td><td style="text-align:left">减轻服务器压力，前后端分离</td><td style="text-align:left">对seo不友（不利于爬虫爬取），首页渲染存在白屏问题</td></tr><tr><td style="text-align:left">SSR</td><td style="text-align:left">对seo友好，首页渲染完美无白屏问题</td><td style="text-align:left">对服务器性能有一定要求，不利于前后端分离</td></tr></tbody></table><p>其实在真正开发中通常是 csr 与 ssr 相结合使用，前端使用cdn缓存，后端使用nginx缓存。这样是最优的解决方案。上两张图大家对比理解：</p><p><img src="/2018/07/04/Nuxt.js踩坑实录/i7eo_1687e50bff1dbae80b0211d67d9dbde4.png" alt="csr"></p><p><img src="/2018/07/04/Nuxt.js踩坑实录/i7eo_910d2d75c2c87a237bfa316a4ed5ea26.png" alt="ssr"></p><h3 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h3><h4 id="什么是-Nuxt"><a href="#什么是-Nuxt" class="headerlink" title="什么是 Nuxt ?"></a>什么是 Nuxt ?</h4><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。</p><h4 id="Nuxt-流程"><a href="#Nuxt-流程" class="headerlink" title="Nuxt 流程"></a>Nuxt 流程</h4><p><img src="/2018/07/04/Nuxt.js踩坑实录/i7eo_0667f547016c7ce4a49e09b07b9b68fa.png" alt="Nuxt流程图"></p><h5 id="nuxtServerInit"><a href="#nuxtServerInit" class="headerlink" title="nuxtServerInit"></a>nuxtServerInit</h5><p>请求先到达 nuxtServerInit 方法，图中也表明了适用场景是对 store 的 action 操作即（vuex）：</p><p><img src="/2018/07/04/Nuxt.js踩坑实录/i7eo_702484477e28e35d0d7057ad05916493.png" alt=""></p><h5 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h5><p>下来请求到达 middleware 属性，虽然这里叫做中间件属性，但还是做着同中间件一样的事。官方给出的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。</span><br></pre></td></tr></table></figure></p><p>也就是说，定义 middleware 属性后你可以在 匹配布局（layout 组件）前执行某种操作，也可以在解析完 layout 之后，解析 page 组件前 执行某种操作。</p><h5 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h5><p>下来请求到达 validate 方法，在这里可以对 page 组件或者 page 中的子组件 component 进行动态路由对应的页面组件中动态路由参数的有效性。</p><h5 id="asyncData-amp-fetch"><a href="#asyncData-amp-fetch" class="headerlink" title="asyncData &amp; fetch"></a>asyncData &amp; fetch</h5><p>接下来达到 asyncData &amp; fetch 方法，asyncData() 适用于在渲染组件前获取异步数据，fetch() 适用于在渲染页面前填充 vuex 中维护的数据。</p><h5 id="render"><a href="#render" class="headerlink" title="render"></a>render</h5><p>最后进行渲染。将渲染后的页面返回给浏览器，用户在页面进行操作，<strong>如果再次请求新的页面，此时只会回到生命周期中的 middlerware 中，而非 nuxtServerInit ，所以如果不同页面间需要操作相同的数据请用 vuex 来维护</strong>。</p><h3 id="Nuxt-笔记"><a href="#Nuxt-笔记" class="headerlink" title="Nuxt 笔记"></a>Nuxt 笔记</h3><h4 id="Nuxt-项目结构"><a href="#Nuxt-项目结构" class="headerlink" title="Nuxt 项目结构"></a>Nuxt 项目结构</h4><p><img src="/2018/07/04/Nuxt.js踩坑实录/i7eo_2b5a004471f261f8a5a2b7af246c6c39.png" alt=""></p><p>通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install npx</span><br><span class="line">npx create-nuxt-app xxx</span><br></pre></td></tr></table></figure><p>生成如上结构，布局组件（layout）用来存放页面整体布局，在 layout 中我们可以放入一些每个页面都会以用到的组件，比如 header &amp; footer。当然如果你不想使用已生成的 layout 组件，你可以重新创建一个，比如 blank.vue 一般不需要引入 header&amp;footer 的页面可以使用 blank.vue 这个 layout 组件。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout: &apos;blank&apos;</span><br></pre></td></tr></table></figure><p><strong>在 nuxt 中引入 layout 不用写路径，nuxt 已经帮我们做了映射，同理在 nuxt 中不用写路由，pages 中文件名映射为了路由</strong>。</p><h4 id="nuxt-中的钩子函数"><a href="#nuxt-中的钩子函数" class="headerlink" title="nuxt 中的钩子函数"></a>nuxt 中的钩子函数</h4><p>nuxt 中提供很多钩子函数，参考文档：<a href="https://zh.nuxtjs.org/api/internals/" target="_blank" rel="noopener">nuxt hooks</a></p><p>这里我们主要来看 vue 组件生命周期中钩子函数，服务器端的 vue 组件也是有生命周期的，只不过只有 beforeCreate 和 created 俩个。<strong>也就是说，我们把服务器端创建的 .vue 文件全部理解成组件，在服务器端环境（node）通过 beforeCreate 和 created 这俩个生命周期节点后服务器端 vue 组件生命周期结束。返回页面给浏览器，在客户端环境（v8）中这个 vue 组件实例创建后会在客户端再次拥有生命周期，此时生命周期中有 mounted 等钩子函数</strong>。</p><p><strong>需要特别注意的是 nuxt 中没有 mounted 钩子函数也没有组件实例，只有 beforeCreate/created 钩子与 context 对象</strong>。</p><h4 id="asyncData-传递服务器数据至客户端"><a href="#asyncData-传递服务器数据至客户端" class="headerlink" title="asyncData() 传递服务器数据至客户端"></a>asyncData() 传递服务器数据至客户端</h4><p><strong>在 asyncData() 中可以处理请求得来的数据，通过 return 将处理后的数据返回给当前 vue 组件的 data 。再次强调这里不能使用 this ，因为没有组件实例，asyncData() 默认的参数是 ctx 即 content 对象</strong>。</p><p>对于打开网页要立即显示的内容，如首页中的 geo 组件（显示当前位置）来说有俩种方式实现，如下：</p><ul><li>ssr<ul><li>nuxtServerInit 方法</li><li>middleware 属性</li></ul></li><li>vue 组件 mounted 函数发送请求</li></ul><p>no-ssr 即 mounted 函数方式实现相信大家都很熟悉。主要来说说 ssr 对应的俩种实现方式。</p><p>nuxtServerInit() 前面也说过，搭配 vuex 使用，所以顾名思义，在 nuxtServerInit 函数中准备好首页 geo 组件需要的数据存入 vuex，<strong>这样 vuex 实例化后的 store 会贯穿整个服务器端与客户端的生命周期</strong>。可能有的同学会问这是怎么传过去的？文末会截图说明。所以在首页返回客户端时数据存在 store 实例中可直接获取即可。获取方式如下：</p><ul><li>服务器端：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.store.state.xxx.xxx.xxx</span><br><span class="line"><span class="comment">// eg: ctx.store.state.home.position.city</span></span><br></pre></td></tr></table></figure><ul><li>客户端：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.xxx.xxx.xxx</span><br><span class="line"><span class="comment">// eg: this.$store.state.home.position.city</span></span><br></pre></td></tr></table></figure><p>middleware 属性是在 vue 组件中直接定义即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">middleware: async (ctx) =&gt; &#123;</span><br><span class="line">    let &#123;status, data: &#123;province, city&#125;&#125; = await ctx.$axios.get(&apos;/geo/getPosition&apos;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>问题来了，如何将获取的 data 赋值给组件中的 data 呢？上面在 nuxt流程图 部分我们分析过，渲染前的最后一步是 asyncData&amp;fetch ，这里我们还是需要用 asyncData 方法把 data 给组件 return 即可。具体做法见官方给出的 issue &amp; 例子：</p><p><a href="https://github.com/nuxt/nuxt.js/issues/1738" target="_blank" rel="noopener">issue：#1738</a></p><p><a href="https://github.com/nuxt/nuxt.js/blob/dev/test/fixtures/basic/pages/fn-midd.vue" target="_blank" rel="noopener">nuxt/fn-midd.vue</a></p><p>解答上面遗留的问题，ssr 生成的页面如何把 vuex 实例后的 store 传给客户端？</p><p>其实在服务器返回页面给浏览器时会传一个名为 __NUXT__ 的对象挂载在 window 上，这里面存储了 store 。如下：</p><p><img src="/2018/07/04/Nuxt.js踩坑实录/i7eo_728311f61451d0611502442c08197ff6.png" alt=""></p><p>如图可以找到 $store.state.home.position.city 这个数据。</p><p>参考文章：</p><p><a href="https://w3ctech.com/topic/2005" target="_blank" rel="noopener">The Benefits of Server Side Rendering Over Client Side Rendering</a></p><p><a href="https://nuxtjs.org/" target="_blank" rel="noopener">NUXT-Universal Vue.js Applications</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。&lt;/p&gt;
&lt;h3 id=&quot;CSR-amp-SSR&quot;&gt;&lt;a href=&quot;#CSR-amp-SSR&quot; class=&quot;headerlink&quot; title=&quot;CSR &amp;amp; SSR&quot;&gt;&lt;/a&gt;CSR &amp;amp; SSR&lt;/h3&gt;&lt;h4 id=&quot;什么是-CSR&quot;&gt;&lt;a href=&quot;#什么是-CSR&quot; class=&quot;headerlink&quot; title=&quot;什么是 CSR ?&quot;&gt;&lt;/a&gt;什么是 CSR ?&lt;/h4&gt;&lt;p&gt;CSR =&amp;gt; client-side-reder，即客户端渲染。具体过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户请求页面，返回页面。此时页面只是模版页面&lt;/li&gt;
&lt;li&gt;浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据&lt;/li&gt;
&lt;li&gt;得到返回数据后使用模版（vue/react/ng/art-template）进行渲染&lt;h4 id=&quot;什么是-SSR&quot;&gt;&lt;a href=&quot;#什么是-SSR&quot; class=&quot;headerlink&quot; title=&quot;什么是 SSR ?&quot;&gt;&lt;/a&gt;什么是 SSR ?&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Vuejs" scheme="https://i7eo.com/categories/Vuejs/"/>
    
    
      <category term="Nuxt.js" scheme="https://i7eo.com/tags/Nuxt-js/"/>
    
      <category term="SSR" scheme="https://i7eo.com/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>Javascript面向对象笔记</title>
    <link href="https://i7eo.com/2018/03/25/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0.html"/>
    <id>https://i7eo.com/2018/03/25/Javascript面向对象笔记.html</id>
    <published>2018-03-25T02:29:48.000Z</published>
    <updated>2018-12-30T13:44:35.875Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。</p><h3 id="Javascript-中创建对象"><a href="#Javascript-中创建对象" class="headerlink" title="Javascript 中创建对象"></a>Javascript 中创建对象</h3><h4 id="new-关键字做了什么？"><a href="#new-关键字做了什么？" class="headerlink" title="new 关键字做了什么？"></a>new 关键字做了什么？</h4><p>利用 new &amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步：</p><ul><li>声明新的变量 basketball</li></ul><a id="more"></a><ul><li>new 将新变量的 _proto_ 属性指向了构造函数（Ball）的 prototype 属性，这时内存为 basketball 分配了内存，其成为了对象。<code>basketball._proto_ = ball.prototype</code></li><li>利用 call 函数将新产生的对象 basketball 的 this 指向 ball。即绑定 this。</li></ul><h4 id="prototype-proto-是什么？"><a href="#prototype-proto-是什么？" class="headerlink" title="prototype/_proto_ 是什么？"></a>prototype/_proto_ 是什么？</h4><p>有的书上别别用显示原型/隐示原型来分别代 prototype/_proto_ 还有的用原型对象/对象原型。其实不论哪一种说法，代表的东西都是一样的。这里我们使用第二种说法。俩者区别如下表：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">解释</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">prototype</td><td style="text-align:left">指向函数的原型对象（包括拥有的变量与方法，constructor ，_proto_）</td><td style="text-align:left">只有函数拥有此属性</td></tr><tr><td style="text-align:left">_proto_</td><td style="text-align:left">指向构造器的原型对象</td><td style="text-align:left">不论对象或者函数都有此属性</td></tr></tbody></table><p>来看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ball</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> basketball = <span class="keyword">new</span> Ball(<span class="string">'basketball'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(basketball.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出</span></span><br><span class="line"><span class="comment">    constructor: ƒ ball(name)</span></span><br><span class="line"><span class="comment">    arguments: null</span></span><br><span class="line"><span class="comment">    caller: null</span></span><br><span class="line"><span class="comment">    length: 1</span></span><br><span class="line"><span class="comment">    name: "ball"</span></span><br><span class="line"><span class="comment">    prototype: &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">    __proto__: ƒ ()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ball.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出</span></span><br><span class="line"><span class="comment">    constructor: ƒ ball(name)</span></span><br><span class="line"><span class="comment">    arguments: null</span></span><br><span class="line"><span class="comment">    caller: null</span></span><br><span class="line"><span class="comment">    length: 1</span></span><br><span class="line"><span class="comment">    name: "ball"</span></span><br><span class="line"><span class="comment">    prototype: &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">    __proto__: ƒ ()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(basketball.__proto__ === ball.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从结果来看确实跟我们上述的 new 创建对象过程一致。</p><h3 id="面向对象-—-继承"><a href="#面向对象-—-继承" class="headerlink" title="面向对象 — 继承"></a>面向对象 — 继承</h3><h4 id="1、call-apply"><a href="#1、call-apply" class="headerlink" title="1、call/apply"></a>1、call/apply</h4><p>该方式采取的办法是将父对象的构造函数绑定在子对象上。具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ball</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.general = <span class="string">"球类运动"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Basketball</span>(<span class="params">name, space</span>) </span>&#123;</span><br><span class="line">    Ball.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.space = space;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bb = <span class="keyword">new</span> Basketball(<span class="string">'耐克7号球'</span>, <span class="string">'室内'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bb.general)</span><br><span class="line"><span class="comment">// 球类运动</span></span><br></pre></td></tr></table></figure><h4 id="2、原型链继承"><a href="#2、原型链继承" class="headerlink" title="2、原型链继承"></a>2、原型链继承</h4><p>使子类原型对象指向父类的原型对象以实现继承。具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ball</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.general = <span class="string">"球类运动"</span>;</span><br><span class="line">    <span class="keyword">this</span>.ballprint = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ball'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Basketball</span>(<span class="params">name, space</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.space = space;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'basketball'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Basketball.prototype = <span class="keyword">new</span> Ball();</span><br><span class="line"><span class="keyword">let</span> bb = <span class="keyword">new</span> Basketball(<span class="string">'耐克7号球'</span>, <span class="string">'室内'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bb.general) <span class="comment">// 1、球类运动</span></span><br><span class="line"><span class="built_in">console</span>.log(bb.ballprint()) <span class="comment">// 2、ball</span></span><br><span class="line"><span class="built_in">console</span>.log(bb.name) <span class="comment">// 3、耐克7号球</span></span><br><span class="line"><span class="built_in">console</span>.log(bb.print()) <span class="comment">// 4、basketball</span></span><br><span class="line"><span class="built_in">console</span>.log(Basketball.prototype == Ball.prototype) <span class="comment">// 5、true</span></span><br><span class="line"><span class="built_in">console</span>.log(Basketball.prototype.__proto__ == Ball.prototype) <span class="comment">// 6、true</span></span><br></pre></td></tr></table></figure><p>调试语句5更深层次的意思是说:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Basketball.prototype.constuctor = Ball.prototype.constuctor</span><br></pre></td></tr></table></figure></p><p>因为前面说过每个函数特有 prototype 这个原型对象属性，而在这个原型对象中存有 constuctor ，所以<strong>要使俩函数的 prototype 相等，那么其中的 constuctor 必定也想等</strong>。所以 bb 作为子类才可以访问到 ball 中的属性与方法。语句1&amp;2证明了这一点。</p><p>语句6结果符合 new 操作符的操作。</p><p>如果子类与父类中的属性、方法同名那么结果怎样呢？结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ball</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"球类运动"</span>;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ball'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Basketball</span>(<span class="params">name, space</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.space = space;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'basketball'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Basketball.prototype = <span class="keyword">new</span> Ball();</span><br><span class="line"><span class="keyword">let</span> bb = <span class="keyword">new</span> Basketball(<span class="string">'耐克7号球'</span>, <span class="string">'室内'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bb.name) <span class="comment">// 1、耐克7号球</span></span><br><span class="line"><span class="built_in">console</span>.log(bb.print()) <span class="comment">// 2、basketball</span></span><br><span class="line"><span class="built_in">console</span>.log(Basketball.prototype == Ball.prototype) <span class="comment">// 3、true</span></span><br><span class="line"><span class="built_in">console</span>.log(Basketball.prototype.__proto__ == Ball.prototype) <span class="comment">// 4、true</span></span><br></pre></td></tr></table></figure><p>此时虽然 <code>bb._proto_ = Basketball.prototype = Ball.prototype</code> 但是同名采取的<strong>就近访问的原则</strong>，所以执行 Basketball 中的语句。<strong>而不会通过 _proto_ 原型链去去上级父类寻找变量与方法</strong>。</p><h4 id="3、改进后的原型继承"><a href="#3、改进后的原型继承" class="headerlink" title="3、改进后的原型继承"></a>3、改进后的原型继承</h4><p>因为上述2中的方法会修改构造函数，所以我们应该手动置回。具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ball</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"球类运动"</span>;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ball'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Basketball</span>(<span class="params">name, space</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.space = space;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'basketball'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Basketball.prototype = <span class="keyword">new</span> Ball();</span><br><span class="line">Basketball.prototype.constructor = Basketball;</span><br><span class="line"><span class="keyword">let</span> bb = <span class="keyword">new</span> Basketball(<span class="string">'耐克7号球'</span>, <span class="string">'室内'</span>);</span><br></pre></td></tr></table></figure><p>这样即可。当然这样的继承方式是多占用了些内存，<code>Basketball.prototype = new Ball();</code> ，<strong>当然还有不占内存的方式，比如利用空对象作为中介的方式</strong>。创建了一个临时的对象，理解起来不难。具体请参考：</p><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript面向对象编程（二）：构造函数的继承</a></p><p>阮老师这里介绍的空对象方法，没什么问题。但是我觉得没有把临时对象使用完后手动置空的操作，自己加上即可。</p><h4 id="4、class-extends-关键字实现继承"><a href="#4、class-extends-关键字实现继承" class="headerlink" title="4、class/extends 关键字实现继承"></a>4、class/extends 关键字实现继承</h4><p>es6中引入了类的概念，用 class 关键字声明的函数作为对象模版。具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">play() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Ball is: '</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basketball</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name) &#123;</span><br><span class="line"><span class="keyword">super</span>(name)</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">playb() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Basketball is: '</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bb = <span class="keyword">new</span> Basketball(<span class="string">'nikeball'</span>)</span><br><span class="line">bb.play(); <span class="comment">// Ball is: nikeball</span></span><br><span class="line">bb.playb(); <span class="comment">// Basketball is: nikeball</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Ball) <span class="comment">// 1、function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Basketball) <span class="comment">// 2、function</span></span><br><span class="line"><span class="built_in">console</span>.log(bb.__proto__ == Basketball.prototype) <span class="comment">// 3、true</span></span><br><span class="line"><span class="built_in">console</span>.log(Basketball.prototype)</span><br><span class="line"><span class="comment">/* 4、</span></span><br><span class="line"><span class="comment">constructor: class Basketball</span></span><br><span class="line"><span class="comment">playb: ƒ playb()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由打印出的结果1&amp;2我们可以看出，class 好像是包在 function 上的语法糖；由3慢慢确定了这一点；由4我们更加确定了这一点，而且<strong>结合前面说的改进原型继承的方式，还可以尝试分析 class 继承的关键步骤</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Basketball.prototype = <span class="keyword">new</span> Ball()</span><br><span class="line"></span><br><span class="line">Basketball.prototype.constructor = Basketball</span><br><span class="line"></span><br><span class="line"><span class="comment">// playb() &#123;...&#125; 相当于:</span></span><br><span class="line">Basketball.prototype.playb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>使用 class 时一定要注意在使用 this 或者子类构造函数返回前，一定要在子类中使用 super 关键字调用父类的构造函数。说白了就是在子类中一定要使用 super 。</p><p>参考资料：</p><p><a href="http://www.cnblogs.com/cshi/p/5476416.html" target="_blank" rel="noopener">JS当中的new关键字都干了些什么？</a></p><p><a href="http://www.cnblogs.com/pssp/p/5204324.html" target="_blank" rel="noopener">作用域链与原型链</a></p><p><a href="http://louiszhai.github.io/2015/12/17/prototype/" target="_blank" rel="noopener">详解prototype与_proto_</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。&lt;/p&gt;
&lt;h3 id=&quot;Javascript-中创建对象&quot;&gt;&lt;a href=&quot;#Javascript-中创建对象&quot; class=&quot;headerlink&quot; title=&quot;Javascript 中创建对象&quot;&gt;&lt;/a&gt;Javascript 中创建对象&lt;/h3&gt;&lt;h4 id=&quot;new-关键字做了什么？&quot;&gt;&lt;a href=&quot;#new-关键字做了什么？&quot; class=&quot;headerlink&quot; title=&quot;new 关键字做了什么？&quot;&gt;&lt;/a&gt;new 关键字做了什么？&lt;/h4&gt;&lt;p&gt;利用 new &amp;amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明新的变量 basketball&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="继承" scheme="https://i7eo.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="prototype/_proto_" scheme="https://i7eo.com/tags/prototype-proto/"/>
    
      <category term="面向对象" scheme="https://i7eo.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Mac下利用Alfred与七牛搭建markdown图床</title>
    <link href="https://i7eo.com/2018/01/13/Mac%E4%B8%8B%E5%88%A9%E7%94%A8Alfred%E4%B8%8E%E4%B8%83%E7%89%9B%E6%90%AD%E5%BB%BAmarkdown%E5%9B%BE%E5%BA%8A.html"/>
    <id>https://i7eo.com/2018/01/13/Mac下利用Alfred与七牛搭建markdown图床.html</id>
    <published>2018-01-13T12:57:58.000Z</published>
    <updated>2019-01-05T05:29:01.883Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。</p><h3 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a>前期准备：</h3><ul><li>可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后）</li></ul><a id="more"></a><ul><li>七牛账号&amp;七牛自动化工具qshell</li><li>截图工具（这个也可以没有，可以利用电脑自带的截图功能，只要保证截图动作后的结果处于剪切板中即可）</li></ul><h3 id="第一部分：（七牛操作）"><a href="#第一部分：（七牛操作）" class="headerlink" title="第一部分：（七牛操作）"></a>第一部分：（七牛操作）</h3><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>注册成功登陆后，单击 管理控制台 -&gt; 对象存储 -&gt; 内容管理 找到外链默认域名，复制并保存。</p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>返回首页，单击 服务与支持 -&gt; 开发者中心 -&gt; sdk与工具 -&gt; 开发者工具 -&gt; qshell 进入后按照提示下载并安装。</p><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>创建账户时，除了ak&amp;sk 现在还需要输入七牛账户名；配置upload.conf文件时需要注意如果本地新增文件七牛默认不会自动检查，你需要设置 rescan_local: true ;如果你在七牛空间（web页）中手动删除某个文件，再次上传该文件的时候七牛默认该文件已经存在空间中，不会再上传该文件，你需要配置 check_exists: true 。</p><h3 id="第二部分：（alfred-workflow操作）"><a href="#第二部分：（alfred-workflow操作）" class="headerlink" title="第二部分：（alfred workflow操作）"></a>第二部分：（alfred workflow操作）</h3><h4 id="第一步：-1"><a href="#第一步：-1" class="headerlink" title="第一步："></a>第一步：</h4><p><img src="/2018/01/13/Mac下利用Alfred与七牛搭建markdown图床/i7eo_6ae05412c45cd93d76aee7dfc829ee6d.png" alt=""></p><p>点击 + ，创建blank workflow即可，注意bundle id必填一个唯一值，能够在alfred中标示你这个workflow即可，其余选项正常填写，category默认选项即可。</p><h4 id="第二步：-1"><a href="#第二步：-1" class="headerlink" title="第二步："></a>第二步：</h4><p><img src="/2018/01/13/Mac下利用Alfred与七牛搭建markdown图床/i7eo_67ef692bcaa2e05863e0aed092834efd.png" alt=""></p><p>创建热键hotkey，其余默认选项不变，完成后save。</p><p><img src="/2018/01/13/Mac下利用Alfred与七牛搭建markdown图床/i7eo_959e803647132d100867bf95fd3f2b97.png" alt=""></p><p>创建热键触发后需要执行的脚本文件，当然run script创建的脚本是后台运行不需要先调出terminal（控制台），如果需要调出terminal（控制台），选择terminal command。<br>根据脚本语言对应选择language，这里提供一个as版本代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">property fileTypes : &#123;¬</span><br><span class="line">    &#123;«class PNGf», ".png"&#125;, ¬</span><br><span class="line">    &#123;JPEG picture, <span class="string">".jpg"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">on getType() --判断剪贴板中的数据类型，暂时只支持png和jpg，优先用png</span><br><span class="line">    repeat <span class="keyword">with</span> aType <span class="keyword">in</span> fileTypes</span><br><span class="line">        repeat <span class="keyword">with</span> theInfo <span class="keyword">in</span> (clipboard info)</span><br><span class="line">            <span class="keyword">if</span> (first item <span class="keyword">of</span> theInfo) is equal to (first item <span class="keyword">of</span> aType) then <span class="keyword">return</span> aType</span><br><span class="line">        end repeat</span><br><span class="line">    end repeat</span><br><span class="line">    <span class="keyword">return</span> missing value</span><br><span class="line">end getType</span><br><span class="line"></span><br><span class="line">set theType to getType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> theType is not missing value then</span><br><span class="line">    set filePath to <span class="string">"/Users/xxx/Documents/screenCaptures/"</span> --这里换成你自己放置图片的路径</span><br><span class="line">    set fileName to <span class="keyword">do</span> shell script <span class="string">"date \"+%Y%m%d%H%M%S\" | md5"</span> --用当前时间的md5值做文件名</span><br><span class="line">set prefix to <span class="string">"i7eo_"</span> -- 改成自己的前缀</span><br><span class="line">    <span class="keyword">if</span> fileName does not end <span class="keyword">with</span> (second item <span class="keyword">of</span> theType) then set fileName to (fileName &amp; second item <span class="keyword">of</span> theType <span class="keyword">as</span> text)</span><br><span class="line">    set markdownUrl to <span class="string">"![截图](http://xxx.com/i7eo_"</span> &amp; fileName &amp; <span class="string">")"</span> --这里如果没有用到图床，就把前面前缀去掉，用到的话换成你自己图床的url</span><br><span class="line">    set filePath to filePath &amp; prefix &amp; fileName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        set imageFile to (open <span class="keyword">for</span> access filePath <span class="keyword">with</span> write permission)</span><br><span class="line">        set eof imageFile to <span class="number">0</span></span><br><span class="line">        write (the clipboard <span class="keyword">as</span> (first item <span class="keyword">of</span> theType)) to imageFile -- <span class="keyword">as</span> whatever</span><br><span class="line">        close access imageFile</span><br><span class="line">        set the clipboard to markdownUrl</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            tell application <span class="string">"System Events"</span></span><br><span class="line">                keystroke <span class="string">"v"</span> using command down</span><br><span class="line">            end tell</span><br><span class="line">        end <span class="keyword">try</span></span><br><span class="line">    on error</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            close access imageFile</span><br><span class="line">        end <span class="keyword">try</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    end <span class="keyword">try</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">end <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p><p>把 <code>http://xxx.com/</code><br>改为之前从七牛默认外链处复制出来的地址。</p><h4 id="第三步：-1"><a href="#第三步：-1" class="headerlink" title="第三步："></a>第三步：</h4><p>再次创建一个blank workflow，热键自己设置；再次创建一个as脚本，具体代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> shell script <span class="string">"/usr/local/bin/qshell qupload ~/.qshell/upload.conf"</span></span><br></pre></td></tr></table></figure></p><p>把qupload前的路径换成自己存放七牛qshell文件的位置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法适合写博客时，把该篇博客需要的图片都存放在同一个文件下，写完后一次性上传至七牛空间。然后在把博客推至gitpage即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想每次插入一张图片就上传，可以使用插件 <a href="https://github.com/jiwenxing/qimage-mac" target="_blank" rel="noopener">Mac 版本的 Markdown 一键贴图工具</a></p><p><a href="https://www.jianshu.com/p/5b3f98b1f7b6" target="_blank" rel="noopener">alfred3 Powerpack</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。&lt;/p&gt;
&lt;h3 id=&quot;前期准备：&quot;&gt;&lt;a href=&quot;#前期准备：&quot; class=&quot;headerlink&quot; title=&quot;前期准备：&quot;&gt;&lt;/a&gt;前期准备：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="自动化" scheme="https://i7eo.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="Alfred3 workflow" scheme="https://i7eo.com/tags/Alfred3-workflow/"/>
    
      <category term="图床" scheme="https://i7eo.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="qshell" scheme="https://i7eo.com/tags/qshell/"/>
    
  </entry>
  
  <entry>
    <title>为git page开通https踩坑实录</title>
    <link href="https://i7eo.com/2017/10/01/%E4%B8%BAgitPages%E5%BC%80%E9%80%9Ahttps%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95.html"/>
    <id>https://i7eo.com/2017/10/01/为gitPages开通https踩坑实录.html</id>
    <published>2017-10-01T08:37:27.000Z</published>
    <updated>2018-12-28T18:56:19.680Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。</p><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><ul><li>了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li><li>最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合自己的代码发现引用的图片全是http协议下的，而且在input（即使type≠keyword）输入内容时感叹号变成了红字叉。我所用的是阿里的域名所以去网站查询https的信息，发现有免费的赛门铁克（Symantec）证书试用。果断申请后，发现：</p><h3 id="gitPages注意事项"><a href="#gitPages注意事项" class="headerlink" title="gitPages注意事项"></a>gitPages注意事项</h3><ul><li>git page自带https，在对应rep的设置中，点击 Enforce HTTPS 即可。</li><li>git page绑定自定义域名后无法添加ssl证书。<br>这个时候有点懵了，不过检索多次相关关键字后，发现了cloudflare这个好东西。大概了解了下后就确定用它了，好处如下：</li></ul><h3 id="安利cloudflare的原因"><a href="#安利cloudflare的原因" class="headerlink" title="安利cloudflare的原因"></a>安利cloudflare的原因</h3><ul><li>有免费套</li><li>cloudflare的dns服务器风评还是不错的<br>-cloudflare提供 Universal SSL 服务，简单来说就是让任意http站点支持https。<br>  （具体原理指的是，用cloudflare的dns服务器，当你访问网页时，网页 -&gt; cloudflare 这个过程是加密的，而 cloudflare -&gt; git page这个过程是非加密（http））</li></ul><p>具体可参考官方文档：<a href="https://support.cloudflare.com/hc/en-us/articles/200170416" target="_blank" rel="noopener"> how Cloudflare’s servers connect to your origin for HTTPS requests</a></p><h3 id="cloudflare配置的具体步骤"><a href="#cloudflare配置的具体步骤" class="headerlink" title="cloudflare配置的具体步骤"></a>cloudflare配置的具体步骤</h3><h4 id="第一步：设置dns"><a href="#第一步：设置dns" class="headerlink" title="第一步：设置dns"></a>第一步：设置dns</h4><p>把自己对应的dns服务器改为cloudflare的，下面以阿里来举例。阿里云 -&gt; 域名 -&gt; 管理 -&gt; 修改dns，出现一下界面：</p><p><img src="为gitPages开通https踩坑实录/i7eo_4436910aa5b1e131037aa2f6007f7d23.png" alt=""></p><p>这是我已经修改后的，单击右边的修改dns服务器即可，把cloudflare给出的俩个dns地址换上来就好。cloudflare给出的dns地址位于：cloudflare -&gt; dns -&gt; Cloudflare Nameservers。</p><p>如何判断更换dns成功？<br>回到cloudflare后，单击overview，如果成功会出现：</p><p><img src="为gitPages开通https踩坑实录/i7eo_be5528c7b4f28ce887136746b5de2d03.png" alt=""></p><h4 id="第二步：设置dns信息"><a href="#第二步：设置dns信息" class="headerlink" title="第二步：设置dns信息"></a>第二步：设置dns信息</h4><p>cloudflare -&gt; dns -&gt; DNS Records 如果这里没设置时有记录先删除，新增一条记录:</p><p><img src="为gitPages开通https踩坑实录/i7eo_a726bae253f790060294d739a7ea706f.png" alt=""></p><h4 id="第三步：设置ssl-amp-强制跳转"><a href="#第三步：设置ssl-amp-强制跳转" class="headerlink" title="第三步：设置ssl&amp;强制跳转"></a>第三步：设置ssl&amp;强制跳转</h4><p>cloudflare -&gt; crypto -&gt; SSL 勾选flexible</p><p>cloudflare -&gt; crypto -&gt; Always Use HTTPS 勾选on</p><h4 id="第四步：坐等-amp-排错"><a href="#第四步：坐等-amp-排错" class="headerlink" title="第四步：坐等&amp;排错"></a>第四步：坐等&amp;排错</h4><p>大概10mins - 30mins左右就会生效，可以在等待的时候使用ping命令来ping个人的域名查看ip。</p><p>如果你的博客出现以下情况：</p><p><img src="为gitPages开通https踩坑实录/i7eo_65772c9053e1e9b5a941fa515bc3c3f5.png" alt=""></p><p>检查gitpage的设置，取消掉勾选的Enforce HTTPS选项，这个设置是有缓存的</p><p><img src="为gitPages开通https踩坑实录/i7eo_ee6b38aa59be590bd6736c90911683a4.png" alt=""></p><p>可以切换source或者theme chooser这样可以清理掉缓存的Enforce HTTPS选项信息。</p><p>参考文章：</p><p><a href="https://steffan.cn/2017/03/22/use-cloudflare-to-implement-HTTPS-for-GithubPages-with-custom-domain-names/" target="_blank" rel="noopener">使用Cloudflare为自定义域名的GithubPages实现HTTPS化</a></p><p><a href="https://www.heartnn.com/2018/11/17/resolve-err-too-many-redirects-on-cloudflare/" target="_blank" rel="noopener">解决Cloudflare产生的“ERR_TOO_MANY_REDIRECTS”错误</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。&lt;/p&gt;
&lt;h3 id=&quot;HTTPS的优点&quot;&gt;&lt;a href=&quot;#HTTPS的优点&quot; class=&quot;headerlink&quot; title=&quot;HTTPS的优点&quot;&gt;&lt;/a&gt;HTTPS的优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。&lt;/li&gt;
&lt;li&gt;最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="运维" scheme="https://i7eo.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="cloudflare" scheme="https://i7eo.com/tags/cloudflare/"/>
    
      <category term="https" scheme="https://i7eo.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>手撕值传递&amp;对象深浅拷贝</title>
    <link href="https://i7eo.com/2017/05/20/%E6%89%8B%E6%92%95%E5%80%BC%E4%BC%A0%E9%80%92.html"/>
    <id>https://i7eo.com/2017/05/20/手撕值传递.html</id>
    <published>2017-05-20T13:42:48.000Z</published>
    <updated>2019-01-05T08:55:09.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><blockquote><ol><li>JS 中的基本类型&amp;引用类型分别是什么？</li><li>基本类型&amp;引用类型如何存储？</li><li>值传递的由来&amp;举例说明值传递的过程</li><li>扩展阅读（call-by-sharing）</li></ol></blockquote><h4 id="JS-中的基本类型"><a href="#JS-中的基本类型" class="headerlink" title="JS 中的基本类型"></a>JS 中的基本类型</h4><p>JS 中的基本类型分别是：Number、String、Boolean、undefined、null；引用类型分别是：Function、Object、Array 等。</p><h4 id="基本类型-amp-引用类型存储"><a href="#基本类型-amp-引用类型存储" class="headerlink" title="基本类型&amp;引用类型存储"></a>基本类型&amp;引用类型存储</h4><p>基本类型均存储在栈中而且</p><a id="more"></a><p>在栈中的大小是在引擎中固定的，所以基本类型的包装类型（Number&amp;String&amp;Boolean）的生命周期很短，因为一旦包装类型的生命周期变长，对应的栈中内存会发生变化，导致内存出现问题。而引用类型的存储分为俩部分，在栈中存储对应变量的引用（理解为地址好一点），堆中存放真正的数据。每次都是根据栈中的地址而找到对应的堆中存放的位置，进行读写。代码和图示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pen = <span class="string">'hero'</span>;</span><br><span class="line"><span class="keyword">var</span> pencil = <span class="string">'zhonghua'</span>;</span><br><span class="line"><span class="keyword">var</span> pencil_box = &#123; <span class="attr">eraser</span>: <span class="string">'xiaoxiao'</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="/2017/05/20/手撕值传递/i7eo_13671635cc8398be0b9a302604ab2140.png" alt=""></p><p>这里补充一个关于包装对象的问题。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">'test'</span>;</span><br><span class="line">test.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.color); <span class="comment">// test.color 输出什么？</span></span><br></pre></td></tr></table></figure><p>输出 undefined，引用类型与基本包装类型的主要区别就是对象的生命周期（在上述已经说明生命周期过长会发生什么）。自动创建的基本包装类型的对象只存在于执行代码后的瞬间，然后被销毁。</p><h4 id="值传递的过程"><a href="#值传递的过程" class="headerlink" title="值传递的过程"></a>值传递的过程</h4><p><strong>ECMAScript 中所有函数的参数都是按值传递</strong>。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。访问变量有按值和按引用俩种方式，而参数只能按值传递。值传递代码和图示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">num += <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p><img src="/2017/05/20/手撕值传递/i7eo_a75f9f1c713dcb5407001d3399033f27.png" alt=""></p><p>改为对象再试试看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">obj.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure><p>因为 person 指向的对象在堆内存中只有一个，而且是全局的。有很多人错误地认为：在局部作用域中（setName 中）修改的对象会在全局作用域中（<code>console.log( person.name )</code>）反映出来就说明参数按引用传递。为了证明对象是按值传递，再来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">obj.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'Greg'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure><p>这个时候输出的会是什么？是 “Nicholas”？还是 “Greg”？好吧，先来一个错误答案</p><p>“Greg”（即引用传递） 的图示：</p><p><img src="/2017/05/20/手撕值传递/i7eo_810dcfce80fafb90c2bddbf0e69fcb31.png" alt=""></p><p>调用 setName 执行到 <code>obj = new Object();</code> 时会断开 person 原先指向堆中的连接（图中红叉处）从而指向新开辟的内存空间（new Object()），然后设置 obj 的 name 属性。正确的结果应该是 “Nicholas” 图示如下：</p><p><img src="/2017/05/20/手撕值传递/i7eo_249d6356d297448af0ba9f77d8f90c12.png" alt=""></p><p>传入的 obj 只是对 person 对象的引用进行了复制，执行 obj = new Object(); 时只是让复制后的 person 对象的引用指向了 新开辟的空间（new Object()）。</p><h3 id="引用类型的深浅拷贝"><a href="#引用类型的深浅拷贝" class="headerlink" title="引用类型的深浅拷贝"></a>引用类型的深浅拷贝</h3><p>浅拷贝最简单的方法就是直接利用 <code>=</code> 赋值，这样的话改变一个值，另一个也跟着变化。原理就是因为这样简单地赋值结果共用的是同一块内存。这个不管是 Array 还是 Object都很简单就不举例了。在这里想着重说的一个知识点是关于 Array 的 slice&amp;concat 方法，很多很多网文都把这俩个方法说成了 Array 的深拷贝方法，其实这是错的。为什么？请看下例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>] ];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.slice(); <span class="comment">// 换成 var arr2 = arr1.concat(); 结果不变</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1,arr2);</span><br><span class="line">arr1[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'ss'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1,arr2); <span class="comment">// arr1[2][0] = 'ss' , arr2[2][0] = 'ss'</span></span><br></pre></td></tr></table></figure><p>如果是二维数组，如上代码。通过查看 <code>arr1[2][0]&amp;arr2[2][0]</code> 的结果我们可以发现这并不是深拷贝，因为改变了 <code>arr1[2][0]</code> 后 <code>arr2[2][0]</code> 也顺势改变。但如果是一维数组，则不会有任何问题。如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.slice();</span><br><span class="line"><span class="built_in">console</span>.log(arr1,arr2);</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="string">'ss'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1,arr2); <span class="comment">// arr1 = ['ss', 2, 3] , arr2 = [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>难道只是因为数组的维数不同吗？不是的，应该说是我们并没有深层次地明白什么叫浅拷贝？什么叫深拷贝？</p><p>浅拷贝只复制一层引用类型对象的属性。深拷贝不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。代码和图示，请查看知乎上关于这个问题的回答 <a href="https://www.zhihu.com/question/23031215" target="_blank" rel="noopener">javascript中的深拷贝和浅拷贝？</a><br>通吃数组与对象的深拷贝代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneObj = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> str, newobj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.JSON)&#123;</span><br><span class="line">    str = <span class="built_in">JSON</span>.stringify(obj), <span class="comment">//系列化对象</span></span><br><span class="line">    newobj = <span class="built_in">JSON</span>.parse(str); <span class="comment">//还原</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        newobj[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span> ?</span><br><span class="line">        cloneObj(obj[i]) : obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JSON.stringify()&amp;JSON.parse()可以进行引用对象的拷贝，但是对古老浏览器（IE6—IE8）的兼容性问题即你得先查看（window.JSON）浏览器是否有 JSON 对象。如果没有可以引用 <a href="https://github.com/douglascrockford/JSON-js/blob/master/json2.js" target="_blank" rel="noopener">json2.js</a> 文件。如果数组值为函数，该方法也是不行的。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>　　<br>　　尽管 pass-by-reference（引用传递）与 pass-by-value （值传递）存在了很长一段时间，但是外国小哥提出了一种 pass-by-sharing 的说法，感兴趣的同学可以看看。<a href="http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language" target="_blank" rel="noopener">Is JavaScript a pass-by-reference or pass-by-value language?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;值传递&quot;&gt;&lt;a href=&quot;#值传递&quot; class=&quot;headerlink&quot; title=&quot;值传递&quot;&gt;&lt;/a&gt;值传递&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;JS 中的基本类型&amp;amp;引用类型分别是什么？&lt;/li&gt;
&lt;li&gt;基本类型&amp;amp;引用类型如何存储？&lt;/li&gt;
&lt;li&gt;值传递的由来&amp;amp;举例说明值传递的过程&lt;/li&gt;
&lt;li&gt;扩展阅读（call-by-sharing）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;JS-中的基本类型&quot;&gt;&lt;a href=&quot;#JS-中的基本类型&quot; class=&quot;headerlink&quot; title=&quot;JS 中的基本类型&quot;&gt;&lt;/a&gt;JS 中的基本类型&lt;/h4&gt;&lt;p&gt;JS 中的基本类型分别是：Number、String、Boolean、undefined、null；引用类型分别是：Function、Object、Array 等。&lt;/p&gt;
&lt;h4 id=&quot;基本类型-amp-引用类型存储&quot;&gt;&lt;a href=&quot;#基本类型-amp-引用类型存储&quot; class=&quot;headerlink&quot; title=&quot;基本类型&amp;amp;引用类型存储&quot;&gt;&lt;/a&gt;基本类型&amp;amp;引用类型存储&lt;/h4&gt;&lt;p&gt;基本类型均存储在栈中而且&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="值传递" scheme="https://i7eo.com/tags/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    
      <category term="深拷贝" scheme="https://i7eo.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>手撕闭包</title>
    <link href="https://i7eo.com/2017/05/12/%E6%89%8B%E6%92%95%E9%97%AD%E5%8C%85.html"/>
    <id>https://i7eo.com/2017/05/12/手撕闭包.html</id>
    <published>2017-05-12T11:24:19.000Z</published>
    <updated>2019-01-05T08:57:58.908Z</updated>
    
    <content type="html"><![CDATA[<p>既然说到了手撕那么我们就按照下列顺序一步步来看。</p><blockquote><ol><li>闭包是什么?</li><li>闭包产生过程详解</li><li>闭包常用场景示例</li></ol></blockquote><h3 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h3><blockquote><ol><li>高程三：闭包是指有权访问另一个函数作用域中的变量的函数。</li><li>Javasript Ninja：闭包是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域。</li><li>…<br>总结一下，闭包是<strong>有权操作</strong>除自己外函数作用域中变量的函数。</li></ol></blockquote><a id="more"></a><p>这里对于上面的总结我们需要注意的有三点，也就是闭包的三个特点。首先闭包是一个 <strong>函数</strong>，其次闭包具有操作（读写）<strong>除自己外函数作用域</strong>的能力，最后闭包可以操作（读写）的是 <strong>变量</strong>。</p><h3 id="闭包产生过程详解"><a href="#闭包产生过程详解" class="headerlink" title="闭包产生过程详解"></a>闭包产生过程详解</h3><p>这里还是取大家常看的高程三上的例子来举例说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span> (<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> val1 = obj1[propertyName];</span><br><span class="line"><span class="keyword">var</span> val2 = obj2[propertyName];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (val1 &gt; val2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">var</span> result = compareName(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;);</span><br></pre></td></tr></table></figure><p>下列 AO，代表执行环境中创建的 activity object，可以对应 variable object（VO） 来记忆。此时 js 引擎中的处理顺序如下图：</p><p><img src="/2017/05/12/手撕闭包/i7eo_c35262cc6520474fdd31c7c3a782e043.png" alt=""></p><p> <strong>此时匿名函数中的val1/val2 获得了 propertyName ，拥有了读的能力，所以形成了闭包。而且在匿名函数的执行环境中不仅包括了自己的 AO 还包括了 createComparsonFunction 执行环境的 AO（分别有 createComparson AO&amp;Global AO）</strong>，如下图：</p><p><img src="/2017/05/12/手撕闭包/i7eo_eaa71c1098d03e0eb1d93ad4614d94ef.png" alt=""></p><p>什么是 VO? 什么是执行环境？可以参考我的上一篇文章<a href="https://i7eo.com/2017/05/10/手撕作用域与上下文.html">手撕作用域&amp;上下文</a><br>由上我们知道了 <strong>闭包其实在形成的过程中携带了包含它的函数的作用域</strong>，正因为如此，所以闭包才有读写除自己外函数作用域中变量的能力。但这样<strong>拥有过多作用域会占用大量内存 </strong>，我们可以通过 <code>compareNames = null;</code>来手动释放内存。如果大量使用闭包的话，我们不可能一个个手动去释放内存，所以还是请大家慎用闭包。</p><h3 id="闭包应用场景"><a href="#闭包应用场景" class="headerlink" title="闭包应用场景"></a>闭包应用场景</h3><h4 id="私有变量-——-限制变量作用域"><a href="#私有变量-——-限制变量作用域" class="headerlink" title="私有变量 —— 限制变量作用域"></a>私有变量 —— 限制变量作用域</h4><p>说得简单点就是模拟其他面向对象语言中的变量修饰符 private，给变量增加权限控制。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> feints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>.getFeints = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> feints;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.feint = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">feints++;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ninja = <span class="keyword">new</span> Ninja();</span><br><span class="line">ninja.feint();</span><br><span class="line"><span class="built_in">console</span>.log(ninja.getFeints() == <span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使变量 feints 私有，让外部不能直接访问。如果想访问只能通过 getFeints 方法访问，这里的 getFeints 方法即形成了闭包，因为在这个函数中拥有访问 feints 变量的能力。这里如果将  <code>var feints = 0;</code> 改为 <code>this.feints = 0;</code> 外部即可访问 =。= 聪明的你一定一眼就看出了为什么吧？就是因为上下文！可以参考我的上一篇文章 <a href="https://i7eo.com/2017/05/10/手撕作用域与上下文.html">手撕作用域&amp;上下文</a></p><h4 id="回调（callback）与计时器（timer）"><a href="#回调（callback）与计时器（timer）" class="headerlink" title="回调（callback）与计时器（timer）"></a>回调（callback）与计时器（timer）</h4><p>来看一个回调的例子。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> elem = $(<span class="string">'btnObject'</span>);</span><br><span class="line">elem.html(<span class="string">"Loading ..."</span>);</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url: <span class="string">'test.html'</span>,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">elem.html(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 success 回调中有能力操作 elem ，即形成了闭包。计时器类似，大家可以自己去写写类似的。</p><h4 id="即时函数与闭包的组合"><a href="#即时函数与闭包的组合" class="headerlink" title="即时函数与闭包的组合"></a>即时函数与闭包的组合</h4><p>　　由于即时函数是立即执行，<strong>其内部所有的函数、所有的变量都局限于其内部作用域&gt;。我们可以使用即时函数创建一个临时作用域，用于存储数据状态</strong><br>。想起一到经典的 JS题目。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFuntcions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 result 总是10？因为每个函数的作用域链中都保存着createFunction 的活动对象，所以他们引用的都是同一个变量 i 。当 createFunction 返回后 i 的值为 10 ，此时每个函数都引用着保存变量 i 的同一个变量对象，所以每个函数内部 i 的值都是10。(所有函数都拥有的是同一个词法作用域，要想使每一个闭包保留当时的对i的引用，我们需要对每一个闭包新建一个作用域。)可以使用立即执行函数&amp;let创建函数作用域&amp;块级作用域改进代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFuntcions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">result[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">result[i] = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然说到了手撕那么我们就按照下列顺序一步步来看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;闭包是什么?&lt;/li&gt;
&lt;li&gt;闭包产生过程详解&lt;/li&gt;
&lt;li&gt;闭包常用场景示例&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;闭包是什么？&quot;&gt;&lt;a href=&quot;#闭包是什么？&quot; class=&quot;headerlink&quot; title=&quot;闭包是什么？&quot;&gt;&lt;/a&gt;闭包是什么？&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;高程三：闭包是指有权访问另一个函数作用域中的变量的函数。&lt;/li&gt;
&lt;li&gt;Javasript Ninja：闭包是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域。&lt;/li&gt;
&lt;li&gt;…&lt;br&gt;总结一下，闭包是&lt;strong&gt;有权操作&lt;/strong&gt;除自己外函数作用域中变量的函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="闭包" scheme="https://i7eo.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>手撕作用域与上下文</title>
    <link href="https://i7eo.com/2017/05/10/%E6%89%8B%E6%92%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87.html"/>
    <id>https://i7eo.com/2017/05/10/手撕作用域与上下文.html</id>
    <published>2017-05-10T11:37:58.000Z</published>
    <updated>2019-01-05T08:21:05.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>　先来抛出结论：</p><ol><li>作用域与上下文肯定<strong>不是一回事</strong>。</li><li>作用域是<strong>由 function 进行声明的</strong>而非代码块（{ }）。</li><li>除了全局作用域，函数只要被声明（创建了），它就有了独立的作用域。</li><li>我们<strong>常说的上下文指的是 this</strong>，这里其实对 this 更准确的说法应该被称为<strong>函数上下文（function context）</strong>。</li><li>各大网文与部分书籍中所讲解的上下文，其实是<strong>执行环境（execution context）有的地方也称为执行上下文/执行上下文环境</strong>。这个执行环境<strong>不仅确定了 this （即我们常说的上下文对象），还确定了将各个作用域联系起来的作用域链</strong>。</li><li><strong>执行环境并不是我们常说的上下文</strong>，而是用来确定它的指向。</li><li>本文中将采用高程3的说法 — 执行环境。</li></ol></blockquote><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在 Javascript 中，作用域是由 function 声明的，而不是代码块。声明的作用域创建于代码块，但不终于代码块（其他语言终于代码块）。查看以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>) &#123;</span><br><span class="line"> 　<span class="keyword">var</span> x = <span class="string">'123'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> alert(x);</span><br></pre></td></tr></table></figure><p>在其它语言中，x 终结于大括号关闭处，alert 弹出 undefined。</p><a id="more"></a><p>但是这里还是会出现 123，这是因为<strong>Javascript 中并没有块级作用域的概念</strong>。这样看起来很简单，但是其中还是有一些细微的差别。如下：</p><blockquote><ol><li>变量声明的作用域开始于声明开始的地方，结束于所在函数的结尾。</li><li>函数可以在其作用域范围内被提前引用（被提升），但变量不行。</li><li>对于作用域声明，全局作用域就像一个包含页面所有代码的超大型函数。</li></ol></blockquote><p><strong>函数提升的详细原因参照下述的 </strong>三、执行环境<strong> 中的内容</strong>。</p><p>来看下面代码：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_8f9183aeaa7a8ac5b3d706776260afc3.png" alt=""></p><p>对于这段代码，执行调用 outer() 时，outer 函数中按照从上到下的顺序执行代码，<strong>当进入第2行时（在 outer 中，变量 a 声明前），inner 已经在作用域（scope）中，此时作用域中有 outer () 与 inner()</strong>。之后执行第 2 行，现在 a 也在 scope 中。当进入第 4 行时（在 outer 中，inner() 与 a 之后），由于函数声明提前这里第 3 行相当于已经提前执行，所以越过第 3 行，直接执行第 4 行。后面过程以此类推。</p><h3 id="上下文（即我们常说的-this）"><a href="#上下文（即我们常说的-this）" class="headerlink" title="上下文（即我们常说的 this）"></a>上下文（即我们常说的 this）</h3><p>在开始上下文之前我们需要明白我们研究的 <strong>this 是从哪里来的</strong>。其实这个问题很简单，在我们<strong>调用函数的时候关注点总是在可以看到的函数参数上面</strong>，而没有注意到俩个隐式（implicit）参数—— arguments 与 this。arguments 参数是传递给函数的一个所有参数的集合，它本质不是数组但是有 length 属性，所以我们更喜欢叫它类数组。<strong>this 参数引用了与该函数调用进行隐式关联的一个对象（这里需要注意，上下文是一个对象！），被称为函数上下文（function context）</strong>。</p><p><strong>不同的方法进行函数调用决定了函数上下文的不同</strong>。总结如下：</p><blockquote><ol><li>作为普通函数进行调用时，其上下文是全局对象（window）。</li><li>作为方法调用的时候，其上下文是拥有该方法的对象。</li><li>作为构造器进行调用时，其上下文是一个新分配的对象。</li><li>通过函数的 apply/call 方法进行调用时，上下文可以设置成任意值。</li></ol></blockquote><p>对于上述的 1、2 点我们来看以下代码：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_ca9ce4132a8ca343821d2a3e65aac5d5.png" alt=""></p><p>1-4 行代码，都是<strong>作为普通函数调用，上下文为window</strong>。6-12 行代码，都是<strong>做为方法调用，上下文是拥有该方法的对象（ninja1、ninja2）</strong>。对于第<br> 3 点我们来看下列代码：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_6e653440daf608d20a7651f8b5b26327.png" alt=""></p><p>这时的<strong>上下文指新创建的 ninja </strong>，通过第 8 行代码测试，我们发现 skulk 方法返回的是构造器对象本身。对于第 4 点我们来看下列代码：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_522ab435a82632051edcfa0d3b2f341e.png" alt=""></p><p><strong>通过 apply&amp;call 我们可以分别将上下文从 juggle 切换至 ninja1&amp;ninja2</strong>。</p><p>对于 apply&amp;call 我们很常用，所以扩展也很多。下面列出一个自定义 forEach 函数：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_7c74ee279add6ac0b6ebfaf081005452.png" alt=""></p><p>这个例子，列出了<strong>如何在回调中指定上下文</strong>，而在这里的9-12行我们也验证了如上所说的，this （上下文）是一个对象。因为在第 3 行代码处，我们传入的 <code>List[i]</code> 的类型是 string，但是经过 call 将其指定成上下文对象后在第 10 行我们比较时发现 <code>this === heroList[index]</code> 结果为 false，第 11 行验证了上下文确实是一个对象。这里是一个 String 对象具体信息就不再深究了，有兴趣的同学可以打印 this 出来看看。</p><h3 id="执行环境（执行上下文-执行上下文环境）"><a href="#执行环境（执行上下文-执行上下文环境）" class="headerlink" title="执行环境（执行上下文/执行上下文环境）"></a>执行环境（执行上下文/执行上下文环境）</h3><p>　　这里再次重新声明，执行环境并不是我们常说的上下文，我们常说的上下文指的是 this（函数上下文）。该执行环境确定了作用域链（scope chain）与 this 。来一段高程三中对于执行环境的介绍如下：</p><blockquote><ol><li>执行环境（execution context，为简单起见，有时也称为“环境”）是Javascript中最重要的一个概念。执行环境定义了变量和函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</li><li>全局执行环境是最外围的一个执行环境。根据ECMAScript 实现所在宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。</li><li>每个函数都有自己的执行环境。当执行环境流入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正在由这个方便的机制控制着。</li></ol></blockquote><p>简洁明了，这里对于纯文字看着可能比较苦涩。来个图片以及例子，大家可以结合着消化。下面先给出 js 引擎执行函数时的进出栈图。</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_61842777393ab2c3694af41d4b8c35ad.png" alt=""></p><p>根据这幅图，大家结合下面代码与 executionContextAction.gif 可以很清楚的理解js线程工作的方式。代码片段：<br>　　<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       foo(++i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p><p>这个代码对应引擎处理函数的过程如下：</p><p><img src="/2017/05/10/手撕作用域与上下文/excstack.gif" alt="executionContextAction.gif"></p><p>　　<br>在搞清楚了引擎工作的方式后，我们还得知道执行环境在建立的时候发生的详细过程。<strong>建立阶段以及代码执行阶段的详细分析如下</strong>：</p><p>确切地说，<strong>执行环境是在函数被调用时，但是在函数体被真正执行以前所创建的</strong>。函数被调用时，就处于第一个阶段——建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行环境中。在这个阶段，variableObject 对象，作用域链，以及 this 所指向的对象都会被确定。</p><p>具体过程如下：</p><ol><li>找到当前上下文中的调用函数的代码</li><li>在执行被调用的函数体中的代码以前（编译阶段），开始创建执行环境（执行上下文/执行上下文环境）</li><li>进入第一个阶段-建立阶段:</li></ol><ul><li><p>建立variableObject对象:</p><ul><li><p>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值</p></li><li><p>确定参数变量，若有重名，以已有的变量为准。用已有的变量去覆盖参数变量</p></li><li><p>检查当前执行环境中的函数声明：</p><ol><li>每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用。</li><li>如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。</li></ol></li><li><p>检查当前执行环境中的变量声明：</p><ol><li>每找到一个变量的声明，就在variableObject下，用变量名建立一个属性，属性值为undefined。</li><li>如果该变量名已经存在于variableObject属性中，直接跳过（防止指向函数的属性的值被变量属性覆盖为undefined），原属性值不会被修改。</li></ol></li></ul></li><li><p>初始化作用域链</p></li><li>确定上下文 — this（确定指向）</li></ul><ol start="4"><li>代码执行阶段: 执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。</li></ol><p>来个例子来模拟引擎的执行过程。如下：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_67e7e6b9af04efbd55c44c864ef37a5c.png" alt=""></p><p>在调用 testEC(11) 时，真正执行 testEC(11) 之前，建立以下阶段：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_827811b5802a812ea11c7cd06053b9a1.png" alt=""></p><p>由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段。如下：</p><p><img src="/2017/05/10/手撕作用域与上下文/i7eo_e83d63e89160791e2682a63a27f83b3f.png" alt=""></p><p>那么通过上面例子中的三张图片我们能否发现在函数作用域中关于提升的一些秘密呢？答案是肯定的！在 testEC-prev.png 中 c 函数 是被提升的！因为在建立阶段<code>c: pointer to function c ()</code>，而 b 与 a 均是 undefined，由图上显而易见。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="执行环境与作用域的关系"><a href="#执行环境与作用域的关系" class="headerlink" title="执行环境与作用域的关系"></a>执行环境与作用域的关系</h4><ul><li>在执行环境中首先我们将参数、变量等都存在 VO<br>（变量对象中），这是确确实实存在的，只能供内部使用。</li><li>执行环境只在函数被调用时创建</li><li>执行函数时 VO -&gt; AO（活动对象） 这时我们就可以使用了</li><li>一个作用域下可以没有执行环境（未被调用）；可以有1个；还可以有若干个（存在闭包）</li></ul><h4 id="如何在-callback-中绑定this"><a href="#如何在-callback-中绑定this" class="headerlink" title="如何在 callback 中绑定this"></a>如何在 callback 中绑定this</h4><p>在 div 节点事件函数内部，有一个局部的 callback 方法，callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往想让它指向该 div 节点。如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>I am a div!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.id = <span class="string">'window'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="keyword">this</span>.id); <span class="comment">// test</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="keyword">this</span>.id); <span class="comment">// window</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">    callback();</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下我们需要一个变量保存 div 节点的引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 保存 div 节点引用</span></span><br><span class="line">    <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(that.id); <span class="comment">// test</span></span><br><span class="line">    &#125;;</span><br><span class="line">    callback();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Events in JavaScript: Removing event listeners<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"element"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-1.10.2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//var element = document.getElementById('element');</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> element = $(<span class="string">'#element'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> user = &#123;</span></span><br><span class="line"><span class="javascript"> firstname: <span class="string">'Bob'</span>,</span></span><br><span class="line"><span class="javascript"> greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">   alert(<span class="string">'My name is '</span> + <span class="keyword">this</span>.firstname);</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">obj, name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> obj[name].apply(obj);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Attach user.greeting as a callback</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//element.addEventListener('click', bind(user, 'greeting'));</span></span></span><br><span class="line"><span class="javascript">element.on(<span class="string">'click'</span>, user.greeting.bind(user))</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子是告诉我们无论原生js还是jquery在使用事件函数调用执行方法时函数上下文（this）默认指当前获取的dom元素（jq对象）所以当我们希望当前函数上下文指向user时我们应该改变函数上下文即改变this的指向。改变的方法有三种apply/call/bind。</p><p>参考资料：</p><ul><li>Javascript高级程序设计（第3版）</li><li>Javascript Ninja</li><li><a href="http://blogread.cn/it/article/6178" target="_blank" rel="noopener">深入理解Javascript之执行上下文(Execution Context)</a></li><li><a href="http://www.cnblogs.com/wangfupeng1988/p/4000798.html" target="_blank" rel="noopener">深入理解javascript原型和闭包（18）——补充：上下文环境和作用域的关系</a></li><li><a href="http://www.igooda.cn/jzjl/20150322837.html" target="_blank" rel="noopener">最详细的JavaScript和事件解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;　先来抛出结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作用域与上下文肯定&lt;strong&gt;不是一回事&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;作用域是&lt;strong&gt;由 function 进行声明的&lt;/strong&gt;而非代码块（{ }）。&lt;/li&gt;
&lt;li&gt;除了全局作用域，函数只要被声明（创建了），它就有了独立的作用域。&lt;/li&gt;
&lt;li&gt;我们&lt;strong&gt;常说的上下文指的是 this&lt;/strong&gt;，这里其实对 this 更准确的说法应该被称为&lt;strong&gt;函数上下文（function context）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;各大网文与部分书籍中所讲解的上下文，其实是&lt;strong&gt;执行环境（execution context）有的地方也称为执行上下文/执行上下文环境&lt;/strong&gt;。这个执行环境&lt;strong&gt;不仅确定了 this （即我们常说的上下文对象），还确定了将各个作用域联系起来的作用域链&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行环境并不是我们常说的上下文&lt;/strong&gt;，而是用来确定它的指向。&lt;/li&gt;
&lt;li&gt;本文中将采用高程3的说法 — 执行环境。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h3&gt;&lt;p&gt;在 Javascript 中，作用域是由 function 声明的，而不是代码块。声明的作用域创建于代码块，但不终于代码块（其他语言终于代码块）。查看以下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 　&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&#39;123&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; alert(x);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在其它语言中，x 终结于大括号关闭处，alert 弹出 undefined。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://i7eo.com/categories/Javascript/"/>
    
    
      <category term="作用域" scheme="https://i7eo.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="上下文" scheme="https://i7eo.com/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="执行环境" scheme="https://i7eo.com/tags/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
</feed>
