{"meta":{"title":"Solitude is freedom","subtitle":"Articles on front-end development by George Tan","description":"A man who dreams of being a full stack engineer","author":"George Tan","url":"https://i7eo.com"},"pages":[{"title":"关于我","date":"2017-09-28T00:09:53.000Z","updated":"2019-02-03T03:49:29.901Z","comments":true,"path":"about/index.html","permalink":"https://i7eo.com/about/index.html","excerpt":"","text":"一个梦想成为全栈的前端工程师。喜欢： Javascript NodeJs Java 常用技术： Vue&amp;Vuex Nuxt JQuery Mongodb/redis koa&amp;express 联系我： GitHub: GeorgeTan Gmail: george704t@gmail.com"}],"posts":[{"title":"Javascript继承","slug":"Javascript继承","date":"2019-03-13T13:15:22.000Z","updated":"2019-03-13T17:08:02.500Z","comments":true,"path":"2019/03/13/Javascript继承.html","link":"","permalink":"https://i7eo.com/2019/03/13/Javascript继承.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Javascript的继承是基于原型的，之前理解的比较简单，直到最近在用 es5 写星级评分组件的时候遇到了些问题，解决之后理解深了一些。总结归纳，以便后用。 星级评分原本的需求有俩个： 根据后台返回的评价分数单纯进行5颗星的展示 用户可以在5颗星上为商品进行打分，单击后上传 开始用最笨的方法，从业务出发很快速的把俩个需求都实现了。最后想着能不能利用继承来优化，方便后期扩展可以进行半星或者四分之一星评分。 具体效果如下： 利用原型分别实现满星与半星","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Javascript的继承是基于原型的，之前理解的比较简单，直到最近在用 es5 写星级评分组件的时候遇到了些问题，解决之后理解深了一些。总结归纳，以便后用。 星级评分原本的需求有俩个： 根据后台返回的评价分数单纯进行5颗星的展示 用户可以在5颗星上为商品进行打分，单击后上传 开始用最笨的方法，从业务出发很快速的把俩个需求都实现了。最后想着能不能利用继承来优化，方便后期扩展可以进行半星或者四分之一星评分。 具体效果如下： 利用原型分别实现满星与半星 ps：这里的星星使用 iconfont 的字体图标 Dom结构123456789&lt;section class=\"star\"&gt; &lt;ul class=\"star-list\"&gt; &lt;li class=\"item iconfont icon-star-off\" title=\"wtf\"&gt;&lt;/li&gt; &lt;li class=\"item iconfont icon-star-off\" title=\"bad\"&gt;&lt;/li&gt; &lt;li class=\"item iconfont icon-star-off\" title=\"not bad\"&gt;&lt;/li&gt; &lt;li class=\"item iconfont icon-star-off\" title=\"good\"&gt;&lt;/li&gt; &lt;li class=\"item iconfont icon-star-off\" title=\"perfect\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt; 满星&amp;半星JS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120var starRating = (function() &#123; // 整颗 var lightenFullStar = function(el, opts) &#123; this.$el = $(el) this.$stars = this.$el.find('.item') this.opts = opts &#125; lightenFullStar.prototype.lighten = function(num) &#123; num = parseInt(num) this.$stars.each(function(i) &#123; if(i &lt; num ) &#123; $(this).removeClass('icon-star-off').addClass('icon-star-on') &#125;else&#123; $(this).removeClass('icon-star-on').addClass('icon-star-off') &#125; &#125;) &#125; lightenFullStar.prototype.bindEvent = function() &#123; var self = this self.$el.on('click', '.item', function() &#123; var selectedStar = $(this).index() + 1 self.opts.num = selectedStar typeof self.opts.select === 'function' &amp;&amp; self.opts.select.call(this, selectedStar, self.$stars.length) &#125;).on('mouseover', '.item', function() &#123; self.lighten($(this).index() + 1) &#125;).on('mouseout', function() &#123; self.lighten(self.opts.num) &#125;) &#125; lightenFullStar.prototype.init = function() &#123; this.lighten(this.opts.num) if(!this.opts.readOnly)&#123; this.bindEvent() &#125; &#125; // 半颗 var lightenHalfStar = function(el, opts) &#123; this.$el = $(el) this.$stars = this.$el.find('.item') this.opts = opts this.patch = 1 &#125; lightenHalfStar.prototype.lighten = function(num) &#123; var integer = parseInt(num), hasDecimals = integer !== num this.$stars.each(function(i) &#123; if(i &lt; num ) &#123; $(this).removeClass('icon-star-off icon-star-half').addClass('icon-star-on') &#125;else&#123; $(this).removeClass('icon-star-on icon-star-half').addClass('icon-star-off') &#125; &#125;) // 半颗的点亮 if(hasDecimals) &#123; this.$stars.eq(integer).removeClass('icon-star-off icon-star-on').addClass('icon-star-half') &#125; &#125; lightenHalfStar.prototype.bindEvent = function() &#123; var self = this self.$el.on('mousemove', '.item', function(e) &#123; // 这是理想状态如果设置padingleft/right 还没到目标dom星星就产生变化 // 星星的间距最好设置为margin if(e.pageX - $(this).offset().left &lt; $(this).width() / 2) &#123; self.patch = 0.5 &#125;else&#123; self.patch = 1 &#125; var selectedStar = $(this).index() + self.patch self.lighten(selectedStar) &#125;).on('click', '.item', function() &#123; self.opts.num = $(this).index() + self.patch typeof self.opts.select === 'function' &amp;&amp; self.opts.select.call(this, self.opts.num, self.$stars.length) &#125;).on('mouseout', function() &#123; self.lighten(self.opts.num) &#125;) &#125; lightenHalfStar.prototype.init = function() &#123; this.lighten(this.opts.num) if(!this.opts.readOnly)&#123; this.bindEvent() &#125; &#125; // default var defaults = &#123; mode: 'full', num: 0, readOnly: false, select: function() &#123;&#125; &#125; var reflect = &#123; 'full': lightenFullStar, 'half': lightenHalfStar &#125; var _init = function(el, opts) &#123; opts = $.extend(&#123;&#125;, defaults, opts) if(!reflect[opts.mode]) opts.mode = 'full' new reflect[opts.mode](el, opts).init() &#125; return &#123; init: _init &#125;&#125;)()starRating.init('.star-list', &#123; mode:'full', num: 4.6, readOnly: false, select: function(selected, total) &#123; console.log(selected + '/' + total) &#125;&#125;) 简单来说一下，这里主要运用的事件有 mouseover(mousemove)、mouseout、click。为什么不用 mouseenter&amp;mouseleave 具体可以参考mdn。满星利用 mouseover 监听鼠标移入当前 dom 的操作，半星则将 mouseover 替换为 mousemove ，因为此时我们的鼠标移入时在星星的右侧也就是整颗星，此时在星星内部鼠标从右向左移动 mouseover 是无法触发的，所以不能选择半星。其他的实现就是按照业务一步步来即可，这俩段代码写完之后，发现其实很像。ok，下来利用继承与多态来改写。 利用模版方法改写代码模版方法是什么？简单来说，抽离出公共逻辑作为父类，子类继承父类，对于特有的逻辑或方法对父类中的逻辑或方法进行重写。具体可以参考设计模式。 提取公共逻辑设置父类 Lighten1234567891011121314151617181920212223242526272829303132333435363738394041var Lighten = function(el, opts) &#123; this.$el = $(el) this.$stars = this.$el.find('.item') this.opts = opts this.patch = 1 this.selectEvent = 'mouseover'&#125;Lighten.prototype.lighten = function(num) &#123; num = parseInt(num) this.$stars.each(function(i) &#123; if(i &lt; num ) &#123; $(this).removeClass('icon-star-off icon-star-half').addClass('icon-star-on') &#125;else&#123; $(this).removeClass('icon-star-on icon-star-half').addClass('icon-star-off') &#125; &#125;)&#125;Lighten.prototype.bindEvent = function() &#123; var self = this self.$el.on(self.selectEvent, '.item', function(e) &#123; self.calculateRange(e, $(this)) self.lighten($(this).index() + self.patch) &#125;).on('click', '.item', function() &#123; var selectedStar = $(this).index() + self.patch self.opts.num = selectedStar typeof self.opts.select === 'function' &amp;&amp; self.opts.select.call(this, selectedStar, self.$stars.length) &#125;).on('mouseout', function() &#123; self.lighten(self.opts.num) &#125;)&#125;Lighten.prototype.calculateRange = function() &#123; // 子类必须重写该方法 console.warn('Subclasses must be overridden')&#125;Lighten.prototype.init = function() &#123; this.lighten(this.opts.num) if(!this.opts.readOnly)&#123; this.bindEvent() &#125;&#125; 子类 lightenFullStar &amp; lightenHalfStar12345678910var lightenFullStar = function(el, opts) &#123; Lighten.call(this, el, opts) this.selectEvent = 'mouseover'&#125;lightenFullStar.prototype.lighten = function(num) &#123; Lighten.prototype.lighten.call(this, num)&#125;lightenFullStar.prototype.calculateRange = function() &#123;&#125;lightenFullStar.prototype = new Lighten()lightenFullStar.prototype.construtor = lightenFullStar 1234567891011121314151617181920212223var lightenHalfStar = function(el, opts) &#123; Lighten.call(this, el, opts) this.selectEvent = 'mousemove'&#125;lightenHalfStar.prototype.lighten = function(num) &#123; var integer = parseInt(num), hasDecimals = integer !== num Lighten.prototype.lighten.call(this, integer) // 半颗的点亮 if(hasDecimals) &#123; this.$stars.eq(integer).removeClass('icon-star-off icon-star-on').addClass('icon-star-half') &#125;&#125;lightenHalfStar.prototype.calculateRange = function(e, $this) &#123; if(e.pageX - $this.offset().left &lt; $this.width() / 2) &#123; this.patch = 0.5 &#125;else&#123; this.patch = 1 &#125;&#125;lightenHalfStar.prototype = new Lighten()lightenHalfStar.prototype.construtor = lightenHalfStar alright！看起来不错，感觉万事大吉了。跑起来试试，发现报错 看起来还不错的代码竟然跑挂了，根据报错信息很明显可以分析出没有执行子类重写的 lighten 方法。这是什么原因导致的呢？ lightenHalfStar.prototype = new Lighten() 这行代码是将构造函数 Lighten 的原型对象赋值给 lightenHalfStar 的原型对象。这本身是没什么错的，原型继承的关键也是这句话。将此时的lightenHalfStar.prototype打印出来如下： 在执行lightenHalfStar.prototype = new Lighten()之前lightenHalfStar.prototype中的 lighten确实是自己重写的（可以看 FunctionLocation:120）。让我再看看执行之后的结果。如下： 可以看到 FunctionLocation:41 （即指向了父类的 lighten 方法所在文件中的位置）为什么会这样？答案其实很简单，将 lightenHalfStar.prototype = new Lighten() 的顺序放在声明 lightenHalfStar 原型方法之前即可。 总结&amp;改进对于实现重写方法来说，继承语句的位置是相当关键的。一不注意就进了坑。 注意原型继承中子类的构造器需要手动置回。如下：12lightenHalfStar.prototype = new Lighten()lightenHalfStar.prototype.constructor = lightenHalfStar 原型继承若子类与父类构造器中变量同名则子类的变量会被覆盖，要想重写，就得在构造器中改变 this 指向。如代码中的：Lighten.call(this, el, opts) 通过图 result-2 我们也可以看到实例化之后父类构造函数的值也会被带进来。如果值很多的话也会浪费资源，这并不是比较好的结果。优化方法： 123456var extend = function(sub, sup) &#123; var F = function() &#123;&#125; F.prototype = sup.prototype sub.prototype = new F() sub.prototype.construtor = sub&#125; 利用空的构造函数做中间人（代理）即可解决。 资料 完整代码：星级评分组件 Javascript面向对象编程（二）：构造函数的继承","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"继承","slug":"继承","permalink":"https://i7eo.com/tags/继承/"}]},{"title":"前端代码编写注意事项","slug":"前端代码编写注意事项","date":"2019-03-02T12:22:23.000Z","updated":"2019-03-13T17:24:03.864Z","comments":true,"path":"2019/03/02/前端代码编写注意事项.html","link":"","permalink":"https://i7eo.com/2019/03/02/前端代码编写注意事项.html","excerpt":"变量 声明不用，数据只使用一次或不使用就无需装到变量中 变量命名，驼峰、简洁、易懂 特定变量： 12345const MAX_INPUT_LENGTH = 8;if (value.length &lt; MAX_INPUT_LENGTH) &#123; // 一目了然，不能超过最大输入长度 ....&#125; 使用说明性的变量(即有意义的变量名)","text":"变量 声明不用，数据只使用一次或不使用就无需装到变量中 变量命名，驼峰、简洁、易懂 特定变量： 12345const MAX_INPUT_LENGTH = 8;if (value.length &lt; MAX_INPUT_LENGTH) &#123; // 一目了然，不能超过最大输入长度 ....&#125; 使用说明性的变量(即有意义的变量名) 123456789101112131415161718const address = 'One Infinite Loop, Cupertino 95014';const cityZipCodeRegex = /^[^,\\]+[,\\s]+(.+?)s*(d&#123;5&#125;)?$/;saveCityZipCode(address.match(cityZipCodeRegex)[1],// 这个公式到底要干嘛，对不起，原作者已经离职了。自己看代码 address.match(cityZipCodeRegex)[2], // 这个公式到底要干嘛，对不起，原作者已经离职了。自己看代码);// 改为如下：const address = 'One Infinite Loop, Cupertino 95014';const cityZipCodeRegex = /^[^,\\]+[,\\s]+(.+?)s*(d&#123;5&#125;)?$/;const [, city, zipCode] = address.match(cityZipCodeRegex) || [];saveCityZipCode(city, zipCode); 避免使用太多的全局变量，如有需要请使用命名空间 对于求值变量做好默认值（兜底），对于赋值变量可不用： 123456//其实在项目中有很多求值变量，对于每个求值变量都需要做好兜底。let propertyValue = Object.attr || 0; // 因为Object.attr有可能为空，所以需要兜底。// 但是，赋值变量就不需要兜底了。let a = 2; // 因为有底了，所以不要兜着。let myName = 'Tiny'; // 因为有底了，所以不要兜着。 函数1.对于返回true or false的函数，最好以should/is/can/has开头 2.动作函数已动词开头否则不好辨别意图 3.功能函数最好为纯函数：12345678910// NO: 不要让功能函数的输出变化无常。function plusAbc(a, b, c) &#123; // 这个函数的输出将变化无常，因为api返回的值一旦改变，同样输入函数的a，b,c的值，但函数返回的结果却不一定相同。var c = fetch('../api'); return a+b+c;&#125;//YES：功能函数使用纯函数，输入一致，输出结果永远唯一function plusAbc(a, b, c) &#123; // 同样输入函数的a，b,c的值，但函数返回的结果永远相同。 return a+b+c;&#125; 函数传参要有说明（参数过多，使用对象来代替） 123456789// NO：传参无说明page.getSVG(api, true, false); // true和false啥意思，一目不了然// YES: 传参有说明page.getSVG(&#123; imageApi: api, includePageBackground: true, // 一目了然，知道这些true和false是啥意思 compress: false,&#125;) 一个函数完成一个独立的功能，不要一个函数混杂多个功能 优先使用函数式编程，少用for 多重判断使用array.includes（逻辑复杂可以考虑使用策略模式） ： 123456789101112131415// NO function test(fruit) if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125;// YESfunction test(fruit) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 更少的嵌套，尽早return，考虑使用非（！） 倾向于遍历对象还不是switch： 1234567891011121314151617181920212223242526272829// NOfunction test(color) &#123; // 使用条件语句来寻找对应颜色的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125;// test resultstest(null); // []test('yellow'); // ['banana', 'pineapple']// YESconst fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum']&#125;;function test(color) &#123; return fruitColor[color] || [];&#125; 对 所有/部分 判断使用 Array.every &amp; Array.some","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://i7eo.com/tags/规范/"}]},{"title":"Vue 的响应式/模版解析/渲染","slug":"vuesc","date":"2019-01-03T15:04:45.000Z","updated":"2019-01-05T05:22:56.913Z","comments":true,"path":"2019/01/03/vuesc.html","link":"","permalink":"https://i7eo.com/2019/01/03/vuesc.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于使用 vue 的同学来说，响应式、模版解析/渲染应该都很熟悉，vue 开发离不开这些特性。用了 vue 挺长时间了，写写总结。 响应式创建一个普通的对象： 12345let t = &#123; name: 't1' age: 19&#125;console.log(t.age) // 19 那么如何监听age属性的访问与设置呢？ 在es5中加入了一个api叫 Object.defineProperty,该api允许","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于使用 vue 的同学来说，响应式、模版解析/渲染应该都很熟悉，vue 开发离不开这些特性。用了 vue 挺长时间了，写写总结。 响应式创建一个普通的对象： 12345let t = &#123; name: 't1' age: 19&#125;console.log(t.age) // 19 那么如何监听age属性的访问与设置呢？ 在es5中加入了一个api叫 Object.defineProperty,该api允许 创建对象的属性自定义 get/set 函数。修改上面代码： 1234567891011121314151617let t = &#123;&#125;let name = 't1'Object.defineProperty(obj, 'name', &#123; get() &#123; console.log('get') return name &#125;, set(newVal) &#123; console.log('set') name = newVal &#125;&#125;)console.log(obj.name)// get// t1obj.name = 'george'// set 在vue中我们可以模拟一下，大概过程如下： 123456789101112131415161718let vm = &#123;&#125;let data = &#123; name: 'lyn', age: 20&#125;for(let v in data) &#123; (function(v) &#123; Object.defineProperty(vm, v, &#123; get() &#123; return data[v] &#125;, set(newVal) &#123; data[v] = newVal &#125; &#125;) &#125;)(v)&#125; 为什么要将data的值全部代理至vm对象上？vue中就是这么写的 …，而且模版解析的时候会用到。 模板解析我们经常在vue中使用vue模板，比如： 1234567&lt;div id=\"app\"&gt; &lt;input v-model=\"title\"&gt; &lt;button @click=\"add\"&gt;&lt;/button&gt;&lt;/div&gt;&lt;ul&gt; &lt;li v-for=\"v in list\"&gt;&#123;&#123; v &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 模板的本质是字符串，其特点有： 包含 if/for 等逻辑指令 动态的（动态生成 dom ） 最终转换为 html 综上，要将模板转换为 html ，只能使用 js 来操作。在 html/css/js 中，只有js能处理逻辑和渲染页面。 在当前文件引入vue文件，打开控制台，在源码中搜索code.render 在 return 前打印 code.render，观察模板被解析后生成的render函数，render函数最终返回vnode。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758with(this)&#123; // this 就是 vm return _c( 'div', &#123; attrs:&#123;\"id\":\"app\"&#125; &#125;, [_c( 'div', [ _c( 'input', &#123; directives:[ &#123; name:\"model\", rawName:\"v-model\", value:(title), // vm.title 在这里就将model中的的值通过vm与view中的input数据联系了起来 expression:\"title\" &#125; ], domProps:&#123; \"value\":(title) &#125;, on:&#123; \"input\":function($event)&#123; // 在这里可以发现v-model 其实在vue模版内被封装了进去 if($event.target.composing)return; title=$event.target.value 在这里就将view中的input中的值通过vm与model中的数据联系了起来与上面相对应实现双向绑定 &#125; &#125; &#125; ), _v(\" \"), // 因为html中俩个标签间我们换行所以这里是空 _c( 'button', &#123; on:&#123; \"click\":add // 相当于 vm.add这里直接调用methods中定义的add函数 &#125; &#125;, [_v(\"submit\")] ) ]), _v(\" \"), _c('div', [ _c( 'ul', //v-for这里使用内部定义的 _l函数来处理 _l((list),function(item)&#123;return _c('li',[_v(_s(item))])&#125;) ) ] )] )&#125; _c 创建标签，_v创建文本元素，_s toString()，这个_c 和 snabbdom 中的 h 函数很像，那vue中更新的操作会不会和 snabbdom 中的逻辑页相似呢？vue 中的更新函数： 1234567891011121314vm._update(vnode) &#123; const prevNode = vm._vnode vm._node = vnode if(!prevNode) &#123; vm.$el = vm.__patch___(vm.$el, vnode) &#125;else&#123; vm.$el = vm.__patch__(prevNode, vnode) &#125;&#125;function updateComponent() &#123; vm._update(vm._render()) // vm._render 即生成上面包含 _c/_v/_s的模板解析函数&#125; 也就是说每次改变data，通过Object.defineProperty监听修改操作，一旦修改就调用 updateComponent 函数，利用vm._render方法生成新的 vnode。通过 vm._patch_ 将vnode转化为html并更新至原生dom中。 总结 解析模板生成render函数 响应式开始监听 首次渲染，显示页面且绑定依赖 data属性变化，再次渲染","categories":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://i7eo.com/categories/Vuejs/"}],"tags":[{"name":"模版解析","slug":"模版解析","permalink":"https://i7eo.com/tags/模版解析/"},{"name":"render 函数","slug":"render-函数","permalink":"https://i7eo.com/tags/render-函数/"}]},{"title":"译文：Understanding the Virtual DOM","slug":"vdom","date":"2019-01-01T07:22:47.000Z","updated":"2019-01-06T04:22:24.421Z","comments":true,"path":"2019/01/01/vdom.html","link":"","permalink":"https://i7eo.com/2019/01/01/vdom.html","excerpt":"本文为译文，原文地址： Understanding the Virtual DOM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最近在写一些如何正确区分 dom 与 shadow dom 的文章。总的来说，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。shadow dom 可以被认为是轻量级版本的 dom。它同样是以原生对象为基础的 html document，但是它并不是完整的。可能有些难懂，换一种说法来看，shadow dom 允许我们去将我们的 dom 划分的更小，更轻，可以跨文档使用。（这里作者想表达的意思是我们可以根据需要截取部分 dom 生成 vdom，而不用每次从 html 标签开始写 vdom 直到 html 标签闭合） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个你可能遇到过的相似说法称 “shadow dom” 为 “virtual DOM”。尽管","text":"本文为译文，原文地址： Understanding the Virtual DOM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最近在写一些如何正确区分 dom 与 shadow dom 的文章。总的来说，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。shadow dom 可以被认为是轻量级版本的 dom。它同样是以原生对象为基础的 html document，但是它并不是完整的。可能有些难懂，换一种说法来看，shadow dom 允许我们去将我们的 dom 划分的更小，更轻，可以跨文档使用。（这里作者想表达的意思是我们可以根据需要截取部分 dom 生成 vdom，而不用每次从 html 标签开始写 vdom 直到 html 标签闭合） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个你可能遇到过的相似说法称 “shadow dom” 为 “virtual DOM”。尽管 这个说法已经存在了很多年，但是它真正的流行是在 react 使用它之后。在这篇文章中我将尽力阐述什么是虚拟 dom ，它与原生 dom 又什么不同以及如何使用它。 我们为什么需要虚拟 dom ？想要了解虚拟dom为什么会出现，让我们先回顾以下原生dom。正如我所提到的，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。举个例子看看： 123456789&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"list__item\"&gt;List item&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 可以用如下 dom 树来表示： 让我们来进行以下操作： 修改第一个 li 的内容为 list item one 加上一个 li 要完成上述操作需要创建新节点，添加新属性与内容，最终完成更新： 12345678const listItemOne = document.getElementsByClassName(\"list__item\")[0];listItemOne.textContent = \"List item one\";const list = document.getElementsByClassName(\"list\")[0];const listItemTwo = document.createElement(\"li\");listItemTwo.classList.add(\"list__item\");listItemTwo.textContent = \"List item two\";list.appendChild(listItemTwo); Dom 并不是为此而生的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当1998年发布DOM的第一个规范时，我们以非常不同的方式构建和管理web页面。很少像今天这样依赖DOM api来创建和更新页面内容。 像 document.getElementsByClassName() 这个方法小规模使用没有问题，但是如果在同一页面间隔很短的情况下去更新多个元素，就会使对于 dom 的查询与更新操作变得很昂贵。此外，更新文档中较大一部分比更新特定元素的开销会小一些。回到我们列表例子中，从某种程度上来说用新元素替换整个无序列表比修改某个特定元素要简单一些。代码如下： 12345const list = document.getElementsByClassName(\"list\")[0];list.innerHTML = `&lt;li class=\"list__item\"&gt;List item one&lt;/li&gt;&lt;li class=\"list__item\"&gt;List item two&lt;/li&gt;`; 在这俩个例子中，性能差异并不大。但是随着页面数量的增加，选择、更新我们需要的代码会显得尤为重要。 虚拟 Dom 因此而出现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟 Dom 的出现是为了用更加高效的方式来处理频繁更新 dom 所产生的问题。与 dom 和 shadow dom 不同的是，虚拟 dom 不是一种正式的规范，它更像一种与 dom 交互的新方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟 dom 可以被认为是原生 dom 的一个复制品。在这个复制品上我们可以不通过 dom api 就能频繁更新数据。一旦对虚拟DOM进行了所有更新，我们就可以查看需要对原始DOM进行哪些特定更改，并且使这些改变更加具体与优化。 虚拟 Dom 张什么样呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一听到虚拟，可能会觉得有些神秘感。其实虚拟 dom 就是 js 对象。让我们再来回顾先前创建的 dom 树： 这个树可以表示为如下 js 对象： 12345678910111213141516171819202122const vdom = &#123; tagName: \"html\", children: [ &#123; tagName: \"head\" &#125;, &#123; tagName: \"body\", children: [ &#123; tagName: \"ul\", attributes: &#123; \"class\": \"list\" &#125;, children: [ &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item\" &#125; // end li ] &#125; // end ul ] &#125; // end body ]&#125; // end html 我们完全可以把这个 js 对象当作虚拟 dom 。我们可以根据需要自由的频繁操作它而不改变原生 dom。 相比于使用整个对象，我们通常的做法是使用部分虚拟 dom。举个例子，我们要操作一个 list 组件，这个组件与我们的无序列表元素相关联。具体如下： 1234567891011const list = &#123; tagName: \"ul\", attributes: &#123; \"class\": \"list\" &#125;, children: [ &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item\" &#125; ]&#125;; 虚拟 Dom 如何使用？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们见识过了虚拟dom的样子，那么它是如何处理dom操作的性能问题？ 正如我所提到的，虚拟 dom 可以专门用来对你需要改变的元素进行操作。（不影响没有改变的元素）让我们重回无序列表的例子。 第一件事我们应该复制dom来产生虚拟dom，然后对需要改变的元素在虚拟dom中进行改变操作。如下： 12345678910111213141516const copy = &#123; tagName: \"ul\", attributes: &#123; \"class\": \"list\" &#125;, children: [ &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item one\" &#125;, &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item two\" &#125; ]&#125;; 这个复制出来的虚拟 dom 用来和原生 dom 进行比较，从而把比较出来的差异用创建的 diff 来保存。 diff 是像这个样子的： 1234567891011const diffs = [ &#123; newNode: &#123; /* new version of list item one */ &#125;, oldNode: &#123; /* original version of list item one */ &#125;, index: /* index of element in parent's list of child nodes */ &#125;, &#123; newNode: &#123; /* list item two */ &#125;, index: &#123; /* */ &#125; &#125;] 这个 diff 提供了一个结构，这个结构可以用来更新原生的 dom。一旦所有的 diff 检测完毕，我们可以对原生 dom 只进行一次更新操作即可。 在下面的例子中，我们对 diff 进行循环，不论是添加新的元素还是更新旧的元素，我们都可以像下面这样做： 123456789101112131415const domElement = document.getElementsByClassName(\"list\")[0];diffs.forEach((diff) =&gt; &#123; const newElement = document.createElement(diff.newNode.tagName); /* Add attributes ... */ if (diff.oldNode) &#123; // If there is an old version, replace it with the new version domElement.replaceChild(diff.newNode, diff.index); &#125; else &#123; // If no old version exists, create a new node domElement.appendChild(diff.newNode); &#125;&#125;) 总结 虚拟dom是让我们与dom交互更加高效的且性能更好一种方法 虚拟dom是一个js对象，它允许我们对js对象进行频繁的修改 所有的修改在虚拟dom中结束后，我们可以一次性对原生dom中需要改变的地方进行更新 附录：snabbdom实现 vdom 的库不多，snabbdom 算是佼佼者。vue 中集成了它的核心代码，在每次修改数据后，都会执行函数进行 diff。下面总结一下非框架下vdom的使用方法： 123456789&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;button id=\"btn-submit\"&gt;change&lt;/button&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/h.js\"&gt;&lt;/script&gt; 以上是html结构，引入不同的snabbdom文件是对应解析绑定的事件、属性等。首先使用 patch(c, vnode) 创建无序列表如下： 单击按钮再次调用 patch 函数即可生成： 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435const snabbdom = window.snabbdom // init snabbdom let patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners ]) //define h() let h = snabbdom.h let c = document.getElementById('container') let btn = document.getElementById('btn-submit') // create vnode let vnode = h('ul#list', &#123;&#125;, [ h('li.item', &#123;&#125;, 'item1'), h('li.item', &#123;&#125;, 'item2') ]) // first time create vdom and transform it to dom patch(c, vnode) btn.addEventListener('click', () =&gt; &#123; // define new node let newNode = h('ul#list', &#123;&#125;, [ h('li.item', &#123;&#125;, 'item1'), h('li.item', &#123;&#125;, 'item22'), h('li.item', &#123;&#125;, 'item3') ]) // find diffs , update diffs into original DOM patch(vnode, newNode) vnode = newNode &#125;) h 函数的作用是将传入的数据转化为vnode（vnode具体格式参照上述译文中的 copy），patch 函数先判断是否存在 vnode，不存在的话直接将 vnode，生成 dom，插入目标中；若存在进行 diff 算法，找出差异后对原生 dom 进行更新。 动手模拟 patch 实现过程patch 函数有俩种用法： patch(container, vnode) patch(vnode, newNode) 先来看第一种： 123456789101112131415&#123; tag: 'ul', attrs: &#123; id: 'list' &#125;, children: [ &#123; tag: 'li', attrs: &#123; classname: 'item' &#125;, children: ['item1'] &#125; ]&#125; 123&lt;ul id=\"list\"&gt; &lt;li class=\"item\"&gt;item 1&lt;/li&gt;&lt;/ul&gt; 首先得将vnode转化为html结构，才能加入到container种，那么如何将上述js对象（vnode）转化为 html 呢？ 1234567891011121314151617181920function createEl(vnode) &#123; let tag = vnode.tag let attrs = vnode.attrs || &#123;&#125; let children = vnode.children || [] if(!tag) return null; let el = document.createElement(tag) for(let attrName in attrs) &#123; if(attrs.hasOwnProperty(attrName))&#123; el.setAttribute(attrName, attrs[attrName]) &#125; &#125; children.forEach(v =&gt; &#123; el.append(createElement(v)) &#125;) return el;&#125; 大概就是这样，利用递归循环遍历 children，设置 !tag 为终止条件。 第二种： 12345678910111213141516171819202122&#123; tag: 'ul', attrs: &#123; id: 'list' &#125;, children: [ &#123; tag: 'li', attrs: &#123; classname: 'item' &#125;, children: ['item12'] &#125;, &#123; tag: 'li', attrs: &#123; classname: 'item' &#125;, children: ['item2'] &#125; ]&#125; 1234&lt;ul id=\"list\"&gt; &lt;li class=\"item\"&gt;item 12&lt;/li&gt; &lt;li class=\"item\"&gt;item 2&lt;/li&gt;&lt;/ul&gt; 这里我们想要将列表更新为上述结构，使用 patch(vnode, newNode) 方法，这个方法中肯定是要不断的去对比，不断的对比children肯定还会用到递归，模拟代码（只考虑最简单的情况）如下： 12345678910111213141516function updateEl(vnode, newNode) &#123; let children = vnode.children || [] let newChildren = newNode.children || [] children.forEach((child, idx) =&gt; &#123; let newChild = newChildren[idx] if(newChild === null) return ; if(child.tag === newChild.tag) &#123; // the same tag updateEl(child, newChild) &#125;else&#123; // the different tag replaceNode(child, newChild) &#125; &#125;)&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"虚拟Dom","slug":"虚拟Dom","permalink":"https://i7eo.com/tags/虚拟Dom/"}]},{"title":"Event Loop总结","slug":"Event-Loop总结","date":"2018-11-11T14:33:12.000Z","updated":"2019-01-05T03:57:58.091Z","comments":true,"path":"2018/11/11/Event-Loop总结.html","link":"","permalink":"https://i7eo.com/2018/11/11/Event-Loop总结.html","excerpt":"之前也有 event loop 的概念，但一直都是琐碎的。直到阅读以下三篇文章后，琐碎的点串在了一起。 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 这一次，彻底弄懂 JavaScript 执行机制 Event Loop的规范和实现 为了印象深刻，还是决定自己写一写。总结如下： 1、进程与线程的区别1、什么是进程？在计算机操作系统中，只有进程才能在系统中运行。所以要使程序运行就必须为其创建进程。当我们打开浏览器时就已经创建了进程。创建进程之后，系统会为其分配资源(内存等)供其使用。 进程是程序（指令和数据）的真正运行实例。若干进程有可能 …","text":"之前也有 event loop 的概念，但一直都是琐碎的。直到阅读以下三篇文章后，琐碎的点串在了一起。 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 这一次，彻底弄懂 JavaScript 执行机制 Event Loop的规范和实现 为了印象深刻，还是决定自己写一写。总结如下： 1、进程与线程的区别1、什么是进程？在计算机操作系统中，只有进程才能在系统中运行。所以要使程序运行就必须为其创建进程。当我们打开浏览器时就已经创建了进程。创建进程之后，系统会为其分配资源(内存等)供其使用。 进程是程序（指令和数据）的真正运行实例。若干进程有可能 … 与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。 2、什么是线程？线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 总的来说进程是资源分配的最小单位，线程是计算机系统调度和分派的基本单位。线程基本上不拥有资源（也有一点必不可少的资源）它只专注于调度和分派，提高系统并发程度，但是它可以访问其隶属进程的资源。 2、浏览器是多进程上图来阐述，进入浏览器（chrome等）打开多个标签页，然后打开浏览器的 task manager。如下图： 从图上来看，我们首先可以确定的是我打开的4个页面都是进程，因为它们有不同的 process id（进程标识符），这个是存在 PCB 中的，系统分配且唯一的数字标识符。PCB 是进程控制块，具体可搜索计算机操作系统-进程。 浏览器的主要进程有四个，分别为：主进程、GPU进程、浏览器渲染（render）进程（每个标签页都会一个渲染进程）、第三方插件进程。 主要来说说这四个进程的职责： 1. 主进程： 用户的前进、后退操作 每个标签页的创建与销毁 将渲染进程执行后生成的位图（bitmap）绘制在对应标签页上，呈现给用户 书签、下载等功能的管理 2. 浏览器渲染进程 页面渲染 脚本执行（事件、task） 3. GPU进程：用于3D绘制等4. 第三方插件进程：使用插件时创建主要来说下浏览器渲染进程，这个进程是当前标签的控制者。js 代码的执行、事件的触发、页面的展示等都由它负责。那么这一个进程可以同时干这么多事情吗？它一个当然是可以的，但是如果一个人来做就会浪费资源而且一旦执行脚本文件后会不断阻塞页面执行。至此，引入了线程来解决这个问题。 3、Javascript 的单线程在渲染进程中划分了很多个线程，这里介绍一些常驻线程： 1. JS 线程（引擎线程，即常说的那个js单线程） 运行环境（v8），负责处理 js 脚本 每个标签页只有一个 js 线程在执行代码 js 线程与 Gui 渲染线程互斥，js 执行时间过长会导致页面渲染的阻塞（互斥原因下面阐述 2. GUI 渲染线程 负责渲染页面（构建dom 树 &amp; cssparser 树 &amp; renderobject 树） 当页面出现重绘或回流（repaint/reflow）时，会调用该线程 与 js 线程互斥 3. 事件触发线程：遵循先进先出的原则在异步队列中等待 js 线程处理。（异步队列下面会解释）4. 定时器触发线程 定时器并不是在某段时间后执行，而是在某时间后被添加至异步队列，等 js 线程空闲后执行 W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms 5. http 请求线程：请求成功后会把回调放入异步队列中。6. 备注：上述执行环境是在浏览器中，如果执行环境换为 node 的话，还有 I/O 线程与 setImmediate3、为什么说 JS 线程与 GUI 渲染线程互斥（js 代码会阻塞渲染）？GUI 渲染线程第一个构建的是 dom 树，js 代码也有可能会修改 dom 结构，一旦修改就会引起 重绘或回流，这就会导致 GUI 线程的再次从头开始。为了避免这样的事情发生所以采用了这种互斥的策略。俩者并不能在同一时间进行。 4、异步的实现方案 - event loop针对于 js 引擎单线程这种情况，为了不让程序（被 http 请求、定时器等）阻塞，所以有了异步的概念。但是在现代 web 程序开发中，代码量越来越大。为了能让越来越多的定时器、事件、请求有序且规范的执行，event loop 方案出现了。 123456789101112131415console.log('1');setTimeout(function() &#123; console.log('2');&#125;, 0);console.log('3');Promise.resolve().then(function() &#123; console.log('4');&#125;).then(function() &#123; console.log('5');&#125;);console.log('6'); 上述代码的执行结果是：1 3 6 4 5 2 首先介绍 task &amp; microtask： task 主要包括：setTimeout、setInterval、setImmediate、I/O、UI交互事件 microtask 主要包括：Promise、process.nextTick、MutationObserver（在node中 process.nextTick 的优先级高于 promise） task &amp; microtask 在当前标签页中拥有俩个队列来分别存储 task &amp; microtask除了 js &amp; gui 线程，其他每个线程执行时都会按照 task都有一个异步队列来控制顺序。如下图 Event Loop 过程如下： 整个script代码作为 task 执行时先判断是同步任务还是异步任务 同步任务依次进入 js 线程，依次执行 异步任务先在 table 中注册，然后当任务完成时按照 task/microtask 区分开来，依次进入不同的异步队列 js 线程执行完毕后（执行栈为空）先读取 microtask 的异步队列，全部执行完毕（队列为空后），再去读取 task 的异步队列，task 异步队列中的任务若包含 microtask 则再次去读取 microtask 异步队列。 上述过程不断重复，直至 task 异步队列为空。整个过程即为 Event Loop。 还是直接来看代码： 123456789101112131415161718192021222324252627console.log('1');setTimeout(function() &#123; console.log('2'); new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 详细过程请参考： Event Loop的规范和实现 输出：1 7 8 2 4 5 9 11 12 那如果执行环境切换为 node，node 的 Event loop的实现与浏览器稍有差异。具体如下： 需要注意的是： expired timers and intervals queue 这个异步队列专门来存储所有的 setTimeout/setInterval immediates queue 这个异步队列专门来存储所有的 setImmediate next tick queue 专门来存储所有的 process.nextTick node 清空 queue 时会执行所有 task（不论时 task 还是 microtask） 那么以下代码的结果呢？ 1234567891011121314151617181920212223242526272829303132333435363738console.log(1)setTimeout(() =&gt; &#123; console.log(2) new Promise(resolve =&gt; &#123; console.log(4) resolve() &#125;).then(() =&gt; &#123; console.log(5) &#125;) process.nextTick(() =&gt; &#123; console.log(3) &#125;)&#125;)new Promise(resolve =&gt; &#123; console.log(7) resolve()&#125;).then(() =&gt; &#123; console.log(8)&#125;)process.nextTick(() =&gt; &#123; console.log(6)&#125;)setTimeout(() =&gt; &#123; console.log(9) process.nextTick(() =&gt; &#123; console.log(10) &#125;) new Promise(resolve =&gt; &#123; console.log(11) resolve() &#125;).then(() =&gt; &#123; console.log(12) &#125;)&#125;) js 执行栈为空，microtask queue 为空时，去检查 task queue，发现俩个 settimeout 这时依次执行。这里与浏览器环境不同，浏览器环境是从 task queue 读出一个 task 先执行，执行完后去检查 microtask queue，而 node 中是一次性执行完 task queue，再去检查 micrtask queue（比如 process.nextTick、promise 等） 输出：1 7 6 8 2 4 9 11 3 10 5 12 分析过程请参考： Event Loop的规范和实现 5.总结 js 是一门单线程语言 event loop 是 js 的执行机制 参考资料： Tasks, microtasks, queues and schedules What you should know to really understand the Node.js Event Loop Timers, Immediates and Process.nextTick","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://i7eo.com/tags/EventLoop/"}]},{"title":"HTTP笔记(下)","slug":"HTTP1-02","date":"2018-11-06T14:48:44.000Z","updated":"2019-01-13T08:15:50.703Z","comments":true,"path":"2018/11/06/HTTP1-02.html","link":"","permalink":"https://i7eo.com/2018/11/06/HTTP1-02.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域、缓存这些都是开发中常常遇到的，做些笔记供日后查阅。 CORS（Cross-Origin Resource Sharing）跨源资源分享同源策略同源策略（same-origin policy）是浏览器保障安全的一种方法。主要指的是在同协议，同域名，同端口下才能访问资源。为什么要这样限制？假设某用户登陆了自己的网上网上银行，接着去访问了其他网站，如果没有同源策略的限制，那么其他网站就可以访问银行网站的cookie，而cookie一般存放着与用户相关的某些信息，这样用户的信息就会被泄漏或者被冒名顶替去访问网上银行。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域、缓存这些都是开发中常常遇到的，做些笔记供日后查阅。 CORS（Cross-Origin Resource Sharing）跨源资源分享同源策略同源策略（same-origin policy）是浏览器保障安全的一种方法。主要指的是在同协议，同域名，同端口下才能访问资源。为什么要这样限制？假设某用户登陆了自己的网上网上银行，接着去访问了其他网站，如果没有同源策略的限制，那么其他网站就可以访问银行网站的cookie，而cookie一般存放着与用户相关的某些信息，这样用户的信息就会被泄漏或者被冒名顶替去访问网上银行。 CORS &amp; JSONP正是源于上述的策略，导致在开发中出现跨域的问题。那么如何跨过这个限制呢？常见的有： cors jsonp websocket postMessage iframe … 具体可以参考这篇文章：前端常见跨域解决方案（全）这里主要说一说常见的 cors 与 jsonp CROSCORS 指的是跨源资源分享，具体的实现分为俩类： 简单请求（simple request） 预请求（preflight request） 对于能满足以下俩大条件的即为简单请求： 请求方法是以下三种之一： GET HEAD POST http 的头信息不能超出以下几种字段： Accept Accept - Language Content - Language Content - type text/plain multipart/form-data application/x-www-form-urlencoded Viewport-Width DPR Downlink Save-Data Width 而不满足如上条件的即为预请求。 假设现在开启了端口8888、8887 俩个 node 服务，当8888上的页面请求8887的时候，请求其实是已经发送到了8887。请求头中多出了 origin 字段，但是此时服务器中并没有设置相应的 Access-Control-Allow-Origin 所以当请求从8887返回给浏览器后，浏览器阻挡了该请求: 解决办法就是在8887上的响应头中添加 &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; 这里的 * 表示通配符，当然你还可以根据需要设置成单一的地址，比如：&#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39; 。 当你在请求头中设置了 PUT 或者 自定义信息（token 等）这个时候需要在响应头上添加：&#39;Access-Control-Allow-Methods&#39;: &#39;PUT, Delete&#39;, &#39;Access-Control-Allow-Headers&#39;: &#39;Token&#39;,这是为了让服务器支持对应的信息，这里需要注意的是在8888发送请求前会多发送一条方法为 OPTIONS的请求来进行预请求。还可以设置时间使接下来的请求中不带有这条预请求，即：&#39;Access-Control-Max-Age&#39;: &#39;1000&#39;（单位为秒）在 1000s 内不会再发送预请求。 JSONP浏览器允许跨域资源的嵌入。具体如下： &lt;script src=&quot;...&quot;&gt;&lt;/script&gt; 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。 &lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt; 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头 &lt;img&gt;嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG… &lt;video&gt;和 &lt;audio&gt;嵌入多媒体资源。 &lt;frame&gt; 和 &lt;iframe&gt; @font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 &lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt; 的插件。 jsonp 正式运用了第一条规则,将数据利用如下形式包装在请求的js文件中：cors({}) 然后在发出请求的地址后面加上 callback=cors 即可通过 cors 获得数据。 缓存浏览器的缓存有俩种，即强缓存与协商缓存。具体选用哪一种由 header 的设置来决定。 强缓存强缓存有浏览器设置在内存中，直接从内存中读取，而不去服务器拉取数据。 强缓存的具体设置有俩种： http 1.0 中设置 expires。如：&#39;expires&#39;: &#39;Mon, 10 Jun 2015 21:31:12 GMT&#39; 发送请求的时间在此之前，缓存均有效。 http 1.1 中设置 cache-control 。如：&#39;cache-control&#39;: &#39;max-age=20&#39;（单位为秒）这里需要注意的是，一般使用 cache-control （客户端缓存）时，设置的时间都较长。此时如果修改js文件的话，是不会生效的。解决方法就是在项目构建文件中跟js文件的内容生成hash值，这样强缓存就会及时更新。还可以设置其他属性，如下： 可缓存性： public 除了浏览器与服务器，代理服务器也可以缓存 private 只有发起请求的浏览器才可以缓存 no-cache 需要与服务器进行协商，是否能使用本地缓存 no-store 本地与缓存服务器均不能使用缓存 到期 max-age s-maxage 只有在代理服务器中生效 max-stale 指发起请求方缓存过期后还可以使用过期缓存的时间 重新验证 must-revalidate 在max-age过期后，重新发送请求验证是否真正过期 proxy-revalidate 在max-age过期后，重新发送请求至缓存服务器验证是否真正过期 其他 no-transform 告诉proxy不要压缩缓存 例子：&#39;cache-control&#39;: &#39;public, max-age=200, no-cache&#39; 协商缓存Last-Modified/Etag 是协商缓存的俩种方式，都是在服务器端的响应头中设置。不同之处在于： 一些文件可能会定时的更新，但是内容未被更改。这个时候如果使用 Last-Modified 的话就会被认为文件被修改了，而 etag 则不会，因为 etag 是服务器上每个资源的唯一标识。可以根据文件内容生成 hash 来设置 etag。 对于某些修改频繁的文件来说，频率在秒以内。Last-Modified 只能精确到秒，所以这种情况无法判断。 这俩者的值可以随便设置，没有具体的规定。 Last-Modified/If-Modified-Since具体过程： 在服务端响应头上设置 &#39;Last-Modified&#39;: &#39;&#39; 请求再次发送到服务器后，请求头中会出现 &#39;If-Modified-Since&#39;: &#39;&#39; (这个值与上述设置的值相同) 再次发送请求到服务器后会判断俩者的值，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，浏览器就会从内存中读取缓存。这个动作就是协商后的结果。 如果缓存没有命中，就直接从服务器加载数据。此时会更新响应头中的 Last-Modified的信息，供下次对比使用。 Etag/If-None-Matchetag 具体过程与上相同。 总结虽说没有具体规定要设置的值，但是 Last-Modified 一般设置为时间，即文件最后一次的更新时间。而 Etag 则设置为根据内容生成的 hash 值。 参考文章： HTTP访问控制（CORS） Fetch Standard","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://i7eo.com/categories/HTTP/"}],"tags":[{"name":"CORS","slug":"CORS","permalink":"https://i7eo.com/tags/CORS/"},{"name":"缓存","slug":"缓存","permalink":"https://i7eo.com/tags/缓存/"}]},{"title":"HTTP笔记(上)","slug":"HTTP1-0","date":"2018-11-03T02:02:35.000Z","updated":"2019-01-06T15:45:24.533Z","comments":true,"path":"2018/11/03/HTTP1-0.html","link":"","permalink":"https://i7eo.com/2018/11/03/HTTP1-0.html","excerpt":"HTTP 基础网络间通信的大体流程 名称 概念 常用协议 应用层 为应用程序提供服务 HTTP/FTP/SMTP 表示层 定义数据格式及加密 会话层 定义了如何开始、控制和结束一个会话 SSL 传输层 向用户提供端到端的服务 TCP/UDP 网络层 数据在俩个机器间创建逻辑链路 IP(IPV4/IPV6)、ARP 数据链路层 通信实体间建立数据链路连接 物理层 定义物理设备间如何传输比特流的规范（网线、光缆等硬件） osi 模型较为复杂，一般常说的是五层模型： 物理层 -&gt; 数据链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层","text":"HTTP 基础网络间通信的大体流程 名称 概念 常用协议 应用层 为应用程序提供服务 HTTP/FTP/SMTP 表示层 定义数据格式及加密 会话层 定义了如何开始、控制和结束一个会话 SSL 传输层 向用户提供端到端的服务 TCP/UDP 网络层 数据在俩个机器间创建逻辑链路 IP(IPV4/IPV6)、ARP 数据链路层 通信实体间建立数据链路连接 物理层 定义物理设备间如何传输比特流的规范（网线、光缆等硬件） osi 模型较为复杂，一般常说的是五层模型： 物理层 -&gt; 数据链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层 下面这张图用来简单描述俩台通过路由器联系起来的主机的数据是如何传输的。 假设主机1的程序ap1向主机2的程序ap2传送数据。ap1先将数据交给第5层（应用层）。第5层加上必要的控制信息h5传递给下一层，以此类推。需要注意的是数据到达第2层（数据链路层）后，控制信息分成俩部分，分别加到本层数据单元的首部（h2）和尾部（t2）；而第1层由于是比特流传送即0101…所以不必加上控制信息，但是物理层是从首部开始传递数据。 这一串比特流离开主机1后通过物理媒介传递到路由器，从路由器的第1层（物理层）依次上升至第3层（网络层）每一层都会对控制信息进行操作，操作后将控制信息剥去将剩下的数据向上传送，当到达第3层后就会根据首部的目的地址查找路由器中的路由表，找出转发分组的接口，然后从第3层向下传递至第1层，转为比特流之后传递给主机2，主机2的过程与上类似，最终程序ap2收到传输的数据。 在我们平时上网浏览网页时，通常都是我们的电脑与服务器的数据交互，中间过程不是像上述描述的只经过一个路由器这么简单，期间会经过dns服务器、cdn服务器等等。这里着重记录关于 http 部分的知识。 HTTP 不同版本特点对比HTTP/0.9 ： 只有一个 GET 命令 没有 header 等描述信息 服务器发送完毕，tcp连接被关闭 HTTP/1.0 增加 POST/PUT 等命令 增加 header &amp; status code 信息 支持多字符集、多部分发送，缓存等 HTTP/1.1 使tcp连接持久化 pipeline（客户端可以发送多个http请求，但是服务端必须按顺序返回） 增加host与其他命令（利用host中的端口判断具体属于node还是java等） HTTP/2.0 数据以二进制传输（2.0之前数据传输是已字符串传输） 对于客户端发送的多个http请求，服务器返回时不用按照顺序返回，可以并行返回 头信息压缩，增加了推送等提高效率的功能 需要注意的是： 理论上来说一个tcp连接中可以存在多个http请求，但是目前的做法是http1.1中一个tcp链接上同时最多只有一个http请求 并发量一般指的是tcp连接的并发量 各个浏览器对应的tcp并发数量详情可查看：主流浏览器的HTTP最大并发连接数 HTTP 的三次握手 具体情况如上图，这里的 syn 代表同步位，seq 代表序号，ack 代表确认号。需要注意的是当首次握手发生时，即客户端进入 SYN-SENT状态前，不能携带数据，当发生二次握手时，即服务器进入SYN-RECV状态前，也是不能携带数据的，当发生第三次握手时即客户端进入ESTAB-LISHED状态前，可以携带数据。 为什么需要三次握手？因为tcp要保证传输的数据可靠性，但是信道（数据链路层）传输是不可靠的。如何保证tcp传输的数据是可靠的？只能在tcp连接建立前保证通道畅通。因为在三次握手的过程中有网络延迟、包丢失等原因，所以才有了三次握手，三次握手是理论上的最小值。具体分析请参考：TCP 为什么是三次握手，而不是两次或四次？ 、tcp建立连接为什么需要三次握手 补充：套接字（socket）平常我们在使用自己电脑测试移动端页面或者是自己在写程序连接某项服务时都会使用 ip + 端口号 来连接，这是为什么呢？ 因为这些做法都使用了tcp连接，而tcp把连接作为最基本的抽象。在tcp的俩端分别有俩个端点，端点叫做套接字。rfc 793 定义：端口号拼接到 ip 地址构成了套接字。如下图： 同一个ip地址可以有多个tcp连接，而同一个端口号也可以出现在多个不同的tcp连接中。 HTTP 报文格式 这是一个很简单的请求与响应报文格式图。需要注意的是响应报文的首部结尾是空行。响应报文中具体的status code 请参考：常见的HTTPRequest状态码说明","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://i7eo.com/categories/HTTP/"}],"tags":[]},{"title":"CSS元素嵌套问题","slug":"CSS元素嵌套问题","date":"2018-09-05T13:30:39.000Z","updated":"2019-01-05T06:45:07.511Z","comments":true,"path":"2018/09/05/CSS元素嵌套问题.html","link":"","permalink":"https://i7eo.com/2018/09/05/CSS元素嵌套问题.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回顾了一下之前的代码，发现一个css中的坑即层叠顺序。什么叫层叠顺序？简单来说就是在屏幕上某一个位置堆积了很多 div 这些块哪个在上哪个在下的关系就是层叠顺序。（下面代码演示了三层堆叠）","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回顾了一下之前的代码，发现一个css中的坑即层叠顺序。什么叫层叠顺序？简单来说就是在屏幕上某一个位置堆积了很多 div 这些块哪个在上哪个在下的关系就是层叠顺序。（下面代码演示了三层堆叠） 123456789101112131415161718192021222324252627282930.test2&#123; position: absolute; width: 300px; height: 260px; top: 50%; left: 50%; margin-left: -150px; margin-top: -130px; background-color: blue;&#125;.test3&#123; position: absolute; width: 200px; height: 200px; top: 50%; left: 50%; margin-left: -100px; margin-top: -100px; background-color: black;&#125;.test4&#123; position: absolute; width: 150px; height: 150px; top: 50%; left: 50%; margin-left: -75px; margin-top: -75px; background-color: gray;&#125; 对应的html结构如下： 12345&lt;div class=\"test2\"&gt; &lt;div class=\"test3\"&gt; &lt;div class=\"test4\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 如图所示，都是水平垂直居中的。这里我们主要关注层叠顺序。此时三者均为绝对定位，由test2开始从下到上依次是 test2 -&gt; test3 -&gt; test4 这样的顺序。test4位于最上方，此时想让test3与test4位置颠倒且test2位置不变（由下到上的顺序为test2 -&gt; test4 -&gt; test3），应该怎么做？肯定首先想到使用 z-index： 123456789.test3 &#123; //... z-index: 3&#125;.test4 &#123; //.. z-index: 2&#125; 这样修改结果并不会改变。为什么？既然 z-index 不生效那我们肯定先去查 z-index 。 对于一个已经定位的元素（即position属性值是非static的元素），z-index 属性指定：元素在当前堆叠上下文中的堆叠层级。元素是否创建一个新的本地层叠上下文。 MDN : z-index 根据mdn的介绍来看，我们设定了堆叠层级，这样来说是应该可以的。但是结果却不尽人意。留意一下层叠上下文，是否跟创建的层叠上下文有关呢？常见的创建层叠上下文（stacking context）的方式有： z-index 值不为 “auto”的 绝对/相对定位 一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex 可能你并没有意识，但你确实会常常这样为html标签创建样式并为它创建了层叠上下文。 层叠上下文的特点：(mdn) 给一个 HTML 元素定位和 z-index 赋值创建一个层叠上下文，（opacity 值不为 1 的也是相同）。 层叠上下文可以包含在其他层叠上下文中，并且一起创建一个有层级的层叠上下文。 每个层叠上下文完全独立于它的兄弟元素：当处理层叠时只考虑子元素。 每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会 在父层叠上下文中 按顺序进行层叠。 具体的层叠关系如下图： 深入理解CSS中的层叠上下文和层叠顺序 对于当前代码来说，我创建了三个层叠上下文元素并且一一嵌套。当我们设置test3的z-index时，test4是test3的子元素（层叠上下文特点3），会影响到test4。此时test3与test4一同来到了test2上方（其实也就是保持了原位置，因为test2没有设置zindex所以没有层叠上下文）。这个时候再设置test4的z-index，相当于俩个层叠上下文元素在比较z-index，那按照上图所示的比较规则，test3的z-index只要大于test4就能在上面了，那为什么还是不变呢？我们来看看大神的解释： 层叠上下文元素有如下特性：（理解元素层叠上下文-张鑫旭） 1、层叠上下文的层叠水平要比普通元素高（原因后面会说明）； 2、层叠上下文可以阻断元素的混合模式； 3、层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。 4、每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。 5、每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。 根据上面第3点我们知道了内部层叠受制于外部层叠，结合代码也就是说只要test3设置了z-index，那它就会带着test4一起走。当test4设置z-index时，首先要判断设置的值和test3的z-index正负是否相同，如果都为正（同为负），无论大小test3与test4的位置永不会变。既然设置俩个正值作为z-index行不通，那我们试试一正一负行得通吗？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先设置test4的z-index为-1，此时只有一个层叠上下文test4，并且层叠顺序为：由test4开始从下到上依次是 test4 -&gt; test2 -&gt; test3 这样的顺序。test3位于最上方，此时如果给test3的z-index赋正值会导致test4重回原位置（test3上方），赋负值会导致test3来到了test2之下，不符合要求。既然父级元素没有操作空间了，试试父父级元素test2，根据特点3我们猜想如果test2的z-index设置正值那么会把test3（包括test4）这个整体共同带到test2之上的位置。如下： 在改变test4的z-index之后（为了看得更清晰我手动改变了长宽）我们发现达到了效果。设置父父级（test2）的z-index为1之后拥有了层叠上下文，test4设置z-index为-1也拥有了层叠上下文。此时test3作为普通的绝对定位元素保留在原位置（为了方便理解所以这样描述，这里test3其实是bfc发挥了作用），因为test2是父父级符合特点3，所以将位于底下的test4带了上来，但是test4属于test3的子元素，上来后就去和test3比较，因为test3不拥有层叠上下文保留在原位置，而此时test4的z-index为负值，所以在test3之下，test2之上显示。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里说了三个块级元素，大家还可以试试嵌套行内元素是什么效果。需要注意的是伪元素创建层叠上下文的表现是否和上面一样呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445.test&#123; position: absolute; width: 300px; height: 260px; top: 50%; left: 50%; margin-left: -150px; margin-top: -130px; background-color: blue; z-index: 1;&#125;.test1 &#123; position: absolute; width: 200px; height: 200px; top: 50%; left: 50%; margin-left: -100px; margin-top: -100px; background-color: black;&#125;.test1:after&#123; content: ''; position: absolute; width: 100%; height: 100%; background-color: gray; animation: breathe infinite ease-in-out 2s; opacity: 0; z-index: -1;&#125;@keyframes breathe&#123; 0% &#123; transform:scale(.5); opacity:.9; &#125; 95% &#123; transform:scale(1.5); opacity:0; &#125; 100% &#123; transform:scale(.9); opacity:0; &#125;&#125; html如下： 123&lt;div class=\"test\"&gt; &lt;div class=\"test1\"&gt;&lt;/div&gt;&lt;/div&gt; 这个其实就是我遇到的问题，用伪元素创建了层叠上下文，我想让伪元素动画出现在test1的下方test的上方。和上面一样分别设置z-index为-1和1即可达到效果。 参考资料： 深入理解CSS中的层叠上下文和层叠顺序 CSS深入理解流体特性和BFC特性下多栏自适应布局 层叠上下文 Stacking_context_example_2 Stacking_context_example_3","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://i7eo.com/categories/HTML-CSS/"}],"tags":[{"name":"层叠上下文","slug":"层叠上下文","permalink":"https://i7eo.com/tags/层叠上下文/"}]},{"title":"Nuxt.js踩坑实录","slug":"Nuxt.js踩坑实录","date":"2018-07-04T15:22:36.000Z","updated":"2019-01-05T03:57:01.319Z","comments":true,"path":"2018/07/04/Nuxt.js踩坑实录.html","link":"","permalink":"https://i7eo.com/2018/07/04/Nuxt.js踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ?","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ? SSR =&gt; server-side-render，即服务器端渲染。具体过程如下： 用户请求页面 后端取到准备好的数据，渲染到我们自己写的服务器模版（next/nuxt/ejs）中，准备好html结构与相应数据后返回给浏览器 CSR &amp; SSR 优缺点对比 优点 缺点 CSR 减轻服务器压力，前后端分离 对seo不友（不利于爬虫爬取），首页渲染存在白屏问题 SSR 对seo友好，首页渲染完美无白屏问题 对服务器性能有一定要求，不利于前后端分离 其实在真正开发中通常是 csr 与 ssr 相结合使用，前端使用cdn缓存，后端使用nginx缓存。这样是最优的解决方案。上两张图大家对比理解： Nuxt.js什么是 Nuxt ?Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。 Nuxt 流程 nuxtServerInit请求先到达 nuxtServerInit 方法，图中也表明了适用场景是对 store 的 action 操作即（vuex）： middleware下来请求到达 middleware 属性，虽然这里叫做中间件属性，但还是做着同中间件一样的事。官方给出的定义：1中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。 也就是说，定义 middleware 属性后你可以在 匹配布局（layout 组件）前执行某种操作，也可以在解析完 layout 之后，解析 page 组件前 执行某种操作。 validate下来请求到达 validate 方法，在这里可以对 page 组件或者 page 中的子组件 component 进行动态路由对应的页面组件中动态路由参数的有效性。 asyncData &amp; fetch接下来达到 asyncData &amp; fetch 方法，asyncData() 适用于在渲染组件前获取异步数据，fetch() 适用于在渲染页面前填充 vuex 中维护的数据。 render最后进行渲染。将渲染后的页面返回给浏览器，用户在页面进行操作，如果再次请求新的页面，此时只会回到生命周期中的 middlerware 中，而非 nuxtServerInit ，所以如果不同页面间需要操作相同的数据请用 vuex 来维护。 Nuxt 笔记Nuxt 项目结构 通过 12npm install npxnpx create-nuxt-app xxx 生成如上结构，布局组件（layout）用来存放页面整体布局，在 layout 中我们可以放入一些每个页面都会以用到的组件，比如 header &amp; footer。当然如果你不想使用已生成的 layout 组件，你可以重新创建一个，比如 blank.vue 一般不需要引入 header&amp;footer 的页面可以使用 blank.vue 这个 layout 组件。代码如下： 1layout: &apos;blank&apos; 在 nuxt 中引入 layout 不用写路径，nuxt 已经帮我们做了映射，同理在 nuxt 中不用写路由，pages 中文件名映射为了路由。 nuxt 中的钩子函数nuxt 中提供很多钩子函数，参考文档：nuxt hooks 这里我们主要来看 vue 组件生命周期中钩子函数，服务器端的 vue 组件也是有生命周期的，只不过只有 beforeCreate 和 created 俩个。也就是说，我们把服务器端创建的 .vue 文件全部理解成组件，在服务器端环境（node）通过 beforeCreate 和 created 这俩个生命周期节点后服务器端 vue 组件生命周期结束。返回页面给浏览器，在客户端环境（v8）中这个 vue 组件实例创建后会在客户端再次拥有生命周期，此时生命周期中有 mounted 等钩子函数。 需要特别注意的是 nuxt 中没有 mounted 钩子函数也没有组件实例，只有 beforeCreate/created 钩子与 context 对象。 asyncData() 传递服务器数据至客户端在 asyncData() 中可以处理请求得来的数据，通过 return 将处理后的数据返回给当前 vue 组件的 data 。再次强调这里不能使用 this ，因为没有组件实例，asyncData() 默认的参数是 ctx 即 content 对象。 对于打开网页要立即显示的内容，如首页中的 geo 组件（显示当前位置）来说有俩种方式实现，如下： ssr nuxtServerInit 方法 middleware 属性 vue 组件 mounted 函数发送请求 no-ssr 即 mounted 函数方式实现相信大家都很熟悉。主要来说说 ssr 对应的俩种实现方式。 nuxtServerInit() 前面也说过，搭配 vuex 使用，所以顾名思义，在 nuxtServerInit 函数中准备好首页 geo 组件需要的数据存入 vuex，这样 vuex 实例化后的 store 会贯穿整个服务器端与客户端的生命周期。可能有的同学会问这是怎么传过去的？文末会截图说明。所以在首页返回客户端时数据存在 store 实例中可直接获取即可。获取方式如下： 服务器端： 12ctx.store.state.xxx.xxx.xxx// eg: ctx.store.state.home.position.city 客户端： 12this.$store.state.xxx.xxx.xxx// eg: this.$store.state.home.position.city middleware 属性是在 vue 组件中直接定义即可，如下： 1234middleware: async (ctx) =&gt; &#123; let &#123;status, data: &#123;province, city&#125;&#125; = await ctx.$axios.get(&apos;/geo/getPosition&apos;) ... &#125; 问题来了，如何将获取的 data 赋值给组件中的 data 呢？上面在 nuxt流程图 部分我们分析过，渲染前的最后一步是 asyncData&amp;fetch ，这里我们还是需要用 asyncData 方法把 data 给组件 return 即可。具体做法见官方给出的 issue &amp; 例子： issue：#1738 nuxt/fn-midd.vue 解答上面遗留的问题，ssr 生成的页面如何把 vuex 实例后的 store 传给客户端？ 其实在服务器返回页面给浏览器时会传一个名为 __NUXT__ 的对象挂载在 window 上，这里面存储了 store 。如下： 如图可以找到 $store.state.home.position.city 这个数据。 参考文章： The Benefits of Server Side Rendering Over Client Side Rendering NUXT-Universal Vue.js Applications","categories":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://i7eo.com/categories/Vuejs/"}],"tags":[{"name":"Nuxt.js","slug":"Nuxt-js","permalink":"https://i7eo.com/tags/Nuxt-js/"},{"name":"SSR","slug":"SSR","permalink":"https://i7eo.com/tags/SSR/"}]},{"title":"Javascript面向对象笔记","slug":"Javascript面向对象笔记","date":"2018-03-25T02:29:48.000Z","updated":"2018-12-30T13:44:35.875Z","comments":true,"path":"2018/03/25/Javascript面向对象笔记.html","link":"","permalink":"https://i7eo.com/2018/03/25/Javascript面向对象笔记.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。 Javascript 中创建对象new 关键字做了什么？利用 new &amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步： 声明新的变量 basketball","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。 Javascript 中创建对象new 关键字做了什么？利用 new &amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步： 声明新的变量 basketball new 将新变量的 _proto_ 属性指向了构造函数（Ball）的 prototype 属性，这时内存为 basketball 分配了内存，其成为了对象。basketball._proto_ = ball.prototype 利用 call 函数将新产生的对象 basketball 的 this 指向 ball。即绑定 this。 prototype/_proto_ 是什么？有的书上别别用显示原型/隐示原型来分别代 prototype/_proto_ 还有的用原型对象/对象原型。其实不论哪一种说法，代表的东西都是一样的。这里我们使用第二种说法。俩者区别如下表： 解释 备注 prototype 指向函数的原型对象（包括拥有的变量与方法，constructor ，_proto_） 只有函数拥有此属性 _proto_ 指向构造器的原型对象 不论对象或者函数都有此属性 来看下面代码： 1234567891011121314151617181920212223242526272829303132function Ball(name)&#123; this.name = name;&#125;var basketball = new Ball('basketball');console.log(basketball.__proto__);/* 输出 constructor: ƒ ball(name) arguments: null caller: null length: 1 name: \"ball\" prototype: &#123;constructor: ƒ&#125; __proto__: ƒ ()*/console.log(ball.prototype)/* 输出 constructor: ƒ ball(name) arguments: null caller: null length: 1 name: \"ball\" prototype: &#123;constructor: ƒ&#125; __proto__: ƒ ()*/console.log(basketball.__proto__ === ball.prototype)// true 从结果来看确实跟我们上述的 new 创建对象过程一致。 面向对象 — 继承1、call/apply该方式采取的办法是将父对象的构造函数绑定在子对象上。具体如下： 1234567891011121314function Ball() &#123; this.general = \"球类运动\";&#125;function Basketball(name, space) &#123; Ball.apply(this, arguments); this.name = name; this.space = space;&#125;let bb = new Basketball('耐克7号球', '室内')console.log(bb.general)// 球类运动 2、原型链继承使子类原型对象指向父类的原型对象以实现继承。具体如下： 123456789101112131415161718192021222324function Ball() &#123; this.general = \"球类运动\"; this.ballprint = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();let bb = new Basketball('耐克7号球', '室内');console.log(bb.general) // 1、球类运动console.log(bb.ballprint()) // 2、ballconsole.log(bb.name) // 3、耐克7号球console.log(bb.print()) // 4、basketballconsole.log(Basketball.prototype == Ball.prototype) // 5、trueconsole.log(Basketball.prototype.__proto__ == Ball.prototype) // 6、true 调试语句5更深层次的意思是说:1Basketball.prototype.constuctor = Ball.prototype.constuctor 因为前面说过每个函数特有 prototype 这个原型对象属性，而在这个原型对象中存有 constuctor ，所以要使俩函数的 prototype 相等，那么其中的 constuctor 必定也想等。所以 bb 作为子类才可以访问到 ball 中的属性与方法。语句1&amp;2证明了这一点。 语句6结果符合 new 操作符的操作。 如果子类与父类中的属性、方法同名那么结果怎样呢？结果如下： 12345678910111213141516171819202122function Ball() &#123; this.name = \"球类运动\"; this.print = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();let bb = new Basketball('耐克7号球', '室内');console.log(bb.name) // 1、耐克7号球console.log(bb.print()) // 2、basketballconsole.log(Basketball.prototype == Ball.prototype) // 3、trueconsole.log(Basketball.prototype.__proto__ == Ball.prototype) // 4、true 此时虽然 bb._proto_ = Basketball.prototype = Ball.prototype 但是同名采取的就近访问的原则，所以执行 Basketball 中的语句。而不会通过 _proto_ 原型链去去上级父类寻找变量与方法。 3、改进后的原型继承因为上述2中的方法会修改构造函数，所以我们应该手动置回。具体如下： 123456789101112131415161718function Ball() &#123; this.name = \"球类运动\"; this.print = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();Basketball.prototype.constructor = Basketball;let bb = new Basketball('耐克7号球', '室内'); 这样即可。当然这样的继承方式是多占用了些内存，Basketball.prototype = new Ball(); ，当然还有不占内存的方式，比如利用空对象作为中介的方式。创建了一个临时的对象，理解起来不难。具体请参考： Javascript面向对象编程（二）：构造函数的继承 阮老师这里介绍的空对象方法，没什么问题。但是我觉得没有把临时对象使用完后手动置空的操作，自己加上即可。 4、class/extends 关键字实现继承es6中引入了类的概念，用 class 关键字声明的函数作为对象模版。具体如下： 12345678910111213141516171819202122232425262728293031class Ball&#123; constructor(name) &#123; this.name = name &#125; play() &#123; console.log('Ball is: ', this.name) &#125;&#125;class Basketball extends Ball &#123; constructor(name) &#123; super(name) this.name = name &#125; playb() &#123; console.log('Basketball is: ', this.name) &#125;&#125;let bb = new Basketball('nikeball')bb.play(); // Ball is: nikeballbb.playb(); // Basketball is: nikeballconsole.log(typeof Ball) // 1、functionconsole.log(typeof Basketball) // 2、functionconsole.log(bb.__proto__ == Basketball.prototype) // 3、trueconsole.log(Basketball.prototype)/* 4、constructor: class Basketballplayb: ƒ playb()__proto__: Object*/ 由打印出的结果1&amp;2我们可以看出，class 好像是包在 function 上的语法糖；由3慢慢确定了这一点；由4我们更加确定了这一点，而且结合前面说的改进原型继承的方式，还可以尝试分析 class 继承的关键步骤： 123456Basketball.prototype = new Ball()Basketball.prototype.constructor = Basketball// playb() &#123;...&#125; 相当于:Basketball.prototype.playb = function() &#123;...&#125; 使用 class 时一定要注意在使用 this 或者子类构造函数返回前，一定要在子类中使用 super 关键字调用父类的构造函数。说白了就是在子类中一定要使用 super 。 参考资料： JS当中的new关键字都干了些什么？ 作用域链与原型链 详解prototype与_proto_","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"prototype/_proto_","slug":"prototype-proto","permalink":"https://i7eo.com/tags/prototype-proto/"},{"name":"面向对象","slug":"面向对象","permalink":"https://i7eo.com/tags/面向对象/"},{"name":"继承","slug":"继承","permalink":"https://i7eo.com/tags/继承/"}]},{"title":"Mac下利用Alfred与七牛搭建markdown图床","slug":"Mac下利用Alfred与七牛搭建markdown图床","date":"2018-01-13T12:57:58.000Z","updated":"2019-01-05T05:29:01.883Z","comments":true,"path":"2018/01/13/Mac下利用Alfred与七牛搭建markdown图床.html","link":"","permalink":"https://i7eo.com/2018/01/13/Mac下利用Alfred与七牛搭建markdown图床.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后）","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后） 七牛账号&amp;七牛自动化工具qshell 截图工具（这个也可以没有，可以利用电脑自带的截图功能，只要保证截图动作后的结果处于剪切板中即可） 第一部分：（七牛操作）第一步：注册成功登陆后，单击 管理控制台 -&gt; 对象存储 -&gt; 内容管理 找到外链默认域名，复制并保存。 第二步：返回首页，单击 服务与支持 -&gt; 开发者中心 -&gt; sdk与工具 -&gt; 开发者工具 -&gt; qshell 进入后按照提示下载并安装。 第三步：创建账户时，除了ak&amp;sk 现在还需要输入七牛账户名；配置upload.conf文件时需要注意如果本地新增文件七牛默认不会自动检查，你需要设置 rescan_local: true ;如果你在七牛空间（web页）中手动删除某个文件，再次上传该文件的时候七牛默认该文件已经存在空间中，不会再上传该文件，你需要配置 check_exists: true 。 第二部分：（alfred workflow操作）第一步： 点击 + ，创建blank workflow即可，注意bundle id必填一个唯一值，能够在alfred中标示你这个workflow即可，其余选项正常填写，category默认选项即可。 第二步： 创建热键hotkey，其余默认选项不变，完成后save。 创建热键触发后需要执行的脚本文件，当然run script创建的脚本是后台运行不需要先调出terminal（控制台），如果需要调出terminal（控制台），选择terminal command。根据脚本语言对应选择language，这里提供一个as版本代码：12345678910111213141516171819202122232425262728293031323334353637383940414243property fileTypes : &#123;¬ &#123;«class PNGf», \".png\"&#125;, ¬ &#123;JPEG picture, \".jpg\"&#125;&#125;on getType() --判断剪贴板中的数据类型，暂时只支持png和jpg，优先用png repeat with aType in fileTypes repeat with theInfo in (clipboard info) if (first item of theInfo) is equal to (first item of aType) then return aType end repeat end repeat return missing valueend getTypeset theType to getType()if theType is not missing value then set filePath to \"/Users/xxx/Documents/screenCaptures/\" --这里换成你自己放置图片的路径 set fileName to do shell script \"date \\\"+%Y%m%d%H%M%S\\\" | md5\" --用当前时间的md5值做文件名 set prefix to \"i7eo_\" -- 改成自己的前缀 if fileName does not end with (second item of theType) then set fileName to (fileName &amp; second item of theType as text) set markdownUrl to \"![截图](http://xxx.com/i7eo_\" &amp; fileName &amp; \")\" --这里如果没有用到图床，就把前面前缀去掉，用到的话换成你自己图床的url set filePath to filePath &amp; prefix &amp; fileName try set imageFile to (open for access filePath with write permission) set eof imageFile to 0 write (the clipboard as (first item of theType)) to imageFile -- as whatever close access imageFile set the clipboard to markdownUrl try tell application \"System Events\" keystroke \"v\" using command down end tell end try on error try close access imageFile end try return \"\" end tryelse return \"\"end if 把 http://xxx.com/改为之前从七牛默认外链处复制出来的地址。 第三步：再次创建一个blank workflow，热键自己设置；再次创建一个as脚本，具体代码如下：1do shell script \"/usr/local/bin/qshell qupload ~/.qshell/upload.conf\" 把qupload前的路径换成自己存放七牛qshell文件的位置。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法适合写博客时，把该篇博客需要的图片都存放在同一个文件下，写完后一次性上传至七牛空间。然后在把博客推至gitpage即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想每次插入一张图片就上传，可以使用插件 Mac 版本的 Markdown 一键贴图工具 alfred3 Powerpack","categories":[{"name":"自动化","slug":"自动化","permalink":"https://i7eo.com/categories/自动化/"}],"tags":[{"name":"Alfred3 workflow","slug":"Alfred3-workflow","permalink":"https://i7eo.com/tags/Alfred3-workflow/"},{"name":"图床","slug":"图床","permalink":"https://i7eo.com/tags/图床/"},{"name":"qshell","slug":"qshell","permalink":"https://i7eo.com/tags/qshell/"}]},{"title":"为git page开通https踩坑实录","slug":"为gitPages开通https踩坑实录","date":"2017-10-01T08:37:27.000Z","updated":"2018-12-28T18:56:19.680Z","comments":true,"path":"2017/10/01/为gitPages开通https踩坑实录.html","link":"","permalink":"https://i7eo.com/2017/10/01/为gitPages开通https踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合自己的代码发现引用的图片全是http协议下的，而且在input（即使type≠keyword）输入内容时感叹号变成了红字叉。我所用的是阿里的域名所以去网站查询https的信息，发现有免费的赛门铁克（Symantec）证书试用。果断申请后，发现： gitPages注意事项 git page自带https，在对应rep的设置中，点击 Enforce HTTPS 即可。 git page绑定自定义域名后无法添加ssl证书。这个时候有点懵了，不过检索多次相关关键字后，发现了cloudflare这个好东西。大概了解了下后就确定用它了，好处如下： 安利cloudflare的原因 有免费套 cloudflare的dns服务器风评还是不错的-cloudflare提供 Universal SSL 服务，简单来说就是让任意http站点支持https。 （具体原理指的是，用cloudflare的dns服务器，当你访问网页时，网页 -&gt; cloudflare 这个过程是加密的，而 cloudflare -&gt; git page这个过程是非加密（http）） 具体可参考官方文档： how Cloudflare’s servers connect to your origin for HTTPS requests cloudflare配置的具体步骤第一步：设置dns把自己对应的dns服务器改为cloudflare的，下面以阿里来举例。阿里云 -&gt; 域名 -&gt; 管理 -&gt; 修改dns，出现一下界面： 这是我已经修改后的，单击右边的修改dns服务器即可，把cloudflare给出的俩个dns地址换上来就好。cloudflare给出的dns地址位于：cloudflare -&gt; dns -&gt; Cloudflare Nameservers。 如何判断更换dns成功？回到cloudflare后，单击overview，如果成功会出现： 第二步：设置dns信息cloudflare -&gt; dns -&gt; DNS Records 如果这里没设置时有记录先删除，新增一条记录: 第三步：设置ssl&amp;强制跳转cloudflare -&gt; crypto -&gt; SSL 勾选flexible cloudflare -&gt; crypto -&gt; Always Use HTTPS 勾选on 第四步：坐等&amp;排错大概10mins - 30mins左右就会生效，可以在等待的时候使用ping命令来ping个人的域名查看ip。 如果你的博客出现以下情况： 检查gitpage的设置，取消掉勾选的Enforce HTTPS选项，这个设置是有缓存的 可以切换source或者theme chooser这样可以清理掉缓存的Enforce HTTPS选项信息。 参考文章： 使用Cloudflare为自定义域名的GithubPages实现HTTPS化 解决Cloudflare产生的“ERR_TOO_MANY_REDIRECTS”错误","categories":[{"name":"运维","slug":"运维","permalink":"https://i7eo.com/categories/运维/"}],"tags":[{"name":"cloudflare","slug":"cloudflare","permalink":"https://i7eo.com/tags/cloudflare/"},{"name":"https","slug":"https","permalink":"https://i7eo.com/tags/https/"}]},{"title":"手撕值传递&对象深浅拷贝","slug":"手撕值传递","date":"2017-05-20T13:42:48.000Z","updated":"2019-01-05T08:55:09.286Z","comments":true,"path":"2017/05/20/手撕值传递.html","link":"","permalink":"https://i7eo.com/2017/05/20/手撕值传递.html","excerpt":"值传递 JS 中的基本类型&amp;引用类型分别是什么？ 基本类型&amp;引用类型如何存储？ 值传递的由来&amp;举例说明值传递的过程 扩展阅读（call-by-sharing） JS 中的基本类型JS 中的基本类型分别是：Number、String、Boolean、undefined、null；引用类型分别是：Function、Object、Array 等。 基本类型&amp;引用类型存储基本类型均存储在栈中而且","text":"值传递 JS 中的基本类型&amp;引用类型分别是什么？ 基本类型&amp;引用类型如何存储？ 值传递的由来&amp;举例说明值传递的过程 扩展阅读（call-by-sharing） JS 中的基本类型JS 中的基本类型分别是：Number、String、Boolean、undefined、null；引用类型分别是：Function、Object、Array 等。 基本类型&amp;引用类型存储基本类型均存储在栈中而且 在栈中的大小是在引擎中固定的，所以基本类型的包装类型（Number&amp;String&amp;Boolean）的生命周期很短，因为一旦包装类型的生命周期变长，对应的栈中内存会发生变化，导致内存出现问题。而引用类型的存储分为俩部分，在栈中存储对应变量的引用（理解为地址好一点），堆中存放真正的数据。每次都是根据栈中的地址而找到对应的堆中存放的位置，进行读写。代码和图示如下： 123var pen = 'hero';var pencil = 'zhonghua';var pencil_box = &#123; eraser: 'xiaoxiao' &#125;; 这里补充一个关于包装对象的问题。代码如下： 123var test = 'test';test.color = 'red';console.log(test.color); // test.color 输出什么？ 输出 undefined，引用类型与基本包装类型的主要区别就是对象的生命周期（在上述已经说明生命周期过长会发生什么）。自动创建的基本包装类型的对象只存在于执行代码后的瞬间，然后被销毁。 值传递的过程ECMAScript 中所有函数的参数都是按值传递。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。访问变量有按值和按引用俩种方式，而参数只能按值传递。值传递代码和图示如下： 12345678function addTen (num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(count); // 20console.log(result); // 30 改为对象再试试看： 123456function setName (obj) &#123; obj.name = 'Nicholas';&#125;var person = &#123;&#125;;setName(person);console.log(person.name); // \"Nicholas\" 因为 person 指向的对象在堆内存中只有一个，而且是全局的。有很多人错误地认为：在局部作用域中（setName 中）修改的对象会在全局作用域中（console.log( person.name )）反映出来就说明参数按引用传递。为了证明对象是按值传递，再来看下面的例子： 12345678function setName (obj) &#123; obj.name = 'Nicholas'; obj = new Object(); obj.name = 'Greg';&#125;var person = new Object();setName(person);console.log(person.name); 这个时候输出的会是什么？是 “Nicholas”？还是 “Greg”？好吧，先来一个错误答案 “Greg”（即引用传递） 的图示： 调用 setName 执行到 obj = new Object(); 时会断开 person 原先指向堆中的连接（图中红叉处）从而指向新开辟的内存空间（new Object()），然后设置 obj 的 name 属性。正确的结果应该是 “Nicholas” 图示如下： 传入的 obj 只是对 person 对象的引用进行了复制，执行 obj = new Object(); 时只是让复制后的 person 对象的引用指向了 新开辟的空间（new Object()）。 引用类型的深浅拷贝浅拷贝最简单的方法就是直接利用 = 赋值，这样的话改变一个值，另一个也跟着变化。原理就是因为这样简单地赋值结果共用的是同一块内存。这个不管是 Array 还是 Object都很简单就不举例了。在这里想着重说的一个知识点是关于 Array 的 slice&amp;concat 方法，很多很多网文都把这俩个方法说成了 Array 的深拷贝方法，其实这是错的。为什么？请看下例： 12345var arr1 = [1, 2, [3, 4] ];var arr2 = arr1.slice(); // 换成 var arr2 = arr1.concat(); 结果不变console.log(arr1,arr2);arr1[2][0] = 'ss';console.log(arr1,arr2); // arr1[2][0] = 'ss' , arr2[2][0] = 'ss' 如果是二维数组，如上代码。通过查看 arr1[2][0]&amp;arr2[2][0] 的结果我们可以发现这并不是深拷贝，因为改变了 arr1[2][0] 后 arr2[2][0] 也顺势改变。但如果是一维数组，则不会有任何问题。如下代码： 12345var arr1 = [1, 2, 3];var arr2 = arr1.slice();console.log(arr1,arr2);arr1[0] = 'ss';console.log(arr1,arr2); // arr1 = ['ss', 2, 3] , arr2 = [1, 2, 3] 难道只是因为数组的维数不同吗？不是的，应该说是我们并没有深层次地明白什么叫浅拷贝？什么叫深拷贝？ 浅拷贝只复制一层引用类型对象的属性。深拷贝不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。代码和图示，请查看知乎上关于这个问题的回答 javascript中的深拷贝和浅拷贝？通吃数组与对象的深拷贝代码： 123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== 'object')&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === 'object' ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; JSON.stringify()&amp;JSON.parse()可以进行引用对象的拷贝，但是对古老浏览器（IE6—IE8）的兼容性问题即你得先查看（window.JSON）浏览器是否有 JSON 对象。如果没有可以引用 json2.js 文件。如果数组值为函数，该方法也是不行的。 补充 尽管 pass-by-reference（引用传递）与 pass-by-value （值传递）存在了很长一段时间，但是外国小哥提出了一种 pass-by-sharing 的说法，感兴趣的同学可以看看。Is JavaScript a pass-by-reference or pass-by-value language?","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"值传递","slug":"值传递","permalink":"https://i7eo.com/tags/值传递/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://i7eo.com/tags/深拷贝/"}]},{"title":"手撕闭包","slug":"手撕闭包","date":"2017-05-12T11:24:19.000Z","updated":"2019-01-05T08:57:58.908Z","comments":true,"path":"2017/05/12/手撕闭包.html","link":"","permalink":"https://i7eo.com/2017/05/12/手撕闭包.html","excerpt":"既然说到了手撕那么我们就按照下列顺序一步步来看。 闭包是什么? 闭包产生过程详解 闭包常用场景示例 闭包是什么？ 高程三：闭包是指有权访问另一个函数作用域中的变量的函数。 Javasript Ninja：闭包是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域。 …总结一下，闭包是有权操作除自己外函数作用域中变量的函数。","text":"既然说到了手撕那么我们就按照下列顺序一步步来看。 闭包是什么? 闭包产生过程详解 闭包常用场景示例 闭包是什么？ 高程三：闭包是指有权访问另一个函数作用域中的变量的函数。 Javasript Ninja：闭包是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域。 …总结一下，闭包是有权操作除自己外函数作用域中变量的函数。 这里对于上面的总结我们需要注意的有三点，也就是闭包的三个特点。首先闭包是一个 函数，其次闭包具有操作（读写）除自己外函数作用域的能力，最后闭包可以操作（读写）的是 变量。 闭包产生过程详解这里还是取大家常看的高程三上的例子来举例说明。 1234567891011121314151617function createComparisonFunction (propertyName) &#123; return function (obj1, obj2) &#123; var val1 = obj1[propertyName]; var val2 = obj2[propertyName]; if (val1 &lt; val2) &#123; return -1; &#125; else if (val1 &gt; val2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;var compareNames = createComparisonFunction(\"name\");var result = compareName(&#123; name: \"Nicholas\" &#125;, &#123; name: \"Greg\" &#125;); 下列 AO，代表执行环境中创建的 activity object，可以对应 variable object（VO） 来记忆。此时 js 引擎中的处理顺序如下图： 此时匿名函数中的val1/val2 获得了 propertyName ，拥有了读的能力，所以形成了闭包。而且在匿名函数的执行环境中不仅包括了自己的 AO 还包括了 createComparsonFunction 执行环境的 AO（分别有 createComparson AO&amp;Global AO），如下图： 什么是 VO? 什么是执行环境？可以参考我的上一篇文章手撕作用域&amp;上下文由上我们知道了 闭包其实在形成的过程中携带了包含它的函数的作用域，正因为如此，所以闭包才有读写除自己外函数作用域中变量的能力。但这样拥有过多作用域会占用大量内存 ，我们可以通过 compareNames = null;来手动释放内存。如果大量使用闭包的话，我们不可能一个个手动去释放内存，所以还是请大家慎用闭包。 闭包应用场景私有变量 —— 限制变量作用域说得简单点就是模拟其他面向对象语言中的变量修饰符 private，给变量增加权限控制。示例如下： 123456789101112function Ninja () &#123; var feints = 0; this.getFeints = function () &#123; return feints; &#125;; this.feint = function () &#123; feints++; &#125;;&#125;var ninja = new Ninja();ninja.feint();console.log(ninja.getFeints() == 1); // true 使变量 feints 私有，让外部不能直接访问。如果想访问只能通过 getFeints 方法访问，这里的 getFeints 方法即形成了闭包，因为在这个函数中拥有访问 feints 变量的能力。这里如果将 var feints = 0; 改为 this.feints = 0; 外部即可访问 =。= 聪明的你一定一眼就看出了为什么吧？就是因为上下文！可以参考我的上一篇文章 手撕作用域&amp;上下文 回调（callback）与计时器（timer）来看一个回调的例子。如下： 1234567891011$('#btn').click(function () &#123; var elem = $('btnObject'); elem.html(\"Loading ...\"); $.ajax(&#123; url: 'test.html', success: function (data) &#123; elem.html(data); &#125; &#125;);&#125;); 在 success 回调中有能力操作 elem ，即形成了闭包。计时器类似，大家可以自己去写写类似的。 即时函数与闭包的组合 由于即时函数是立即执行，其内部所有的函数、所有的变量都局限于其内部作用域&gt;。我们可以使用即时函数创建一个临时作用域，用于存储数据状态。想起一到经典的 JS题目。代码如下： 123456789function createFuntcions () &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; return i; &#125;; &#125; return result; &#125; 为什么 result 总是10？因为每个函数的作用域链中都保存着createFunction 的活动对象，所以他们引用的都是同一个变量 i 。当 createFunction 返回后 i 的值为 10 ，此时每个函数都引用着保存变量 i 的同一个变量对象，所以每个函数内部 i 的值都是10。(所有函数都拥有的是同一个词法作用域，要想使每一个闭包保留当时的对i的引用，我们需要对每一个闭包新建一个作用域。)可以使用立即执行函数&amp;let创建函数作用域&amp;块级作用域改进代码如下： 123456789function createFuntcions () &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = (function (i) &#123; return i; &#125;)(i); &#125; return result; &#125; 12345for (let i = 0; i &lt; 10; i++) &#123; result[i] = function (i) &#123; return i; &#125;;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"https://i7eo.com/tags/闭包/"}]},{"title":"手撕作用域与上下文","slug":"手撕作用域与上下文","date":"2017-05-10T11:37:58.000Z","updated":"2019-01-05T08:21:05.623Z","comments":true,"path":"2017/05/10/手撕作用域与上下文.html","link":"","permalink":"https://i7eo.com/2017/05/10/手撕作用域与上下文.html","excerpt":"先来抛出结论： 作用域与上下文肯定不是一回事。 作用域是由 function 进行声明的而非代码块（{ }）。 除了全局作用域，函数只要被声明（创建了），它就有了独立的作用域。 我们常说的上下文指的是 this，这里其实对 this 更准确的说法应该被称为函数上下文（function context）。 各大网文与部分书籍中所讲解的上下文，其实是执行环境（execution context）有的地方也称为执行上下文/执行上下文环境。这个执行环境不仅确定了 this （即我们常说的上下文对象），还确定了将各个作用域联系起来的作用域链。 执行环境并不是我们常说的上下文，而是用来确定它的指向。 本文中将采用高程3的说法 — 执行环境。 作用域在 Javascript 中，作用域是由 function 声明的，而不是代码块。声明的作用域创建于代码块，但不终于代码块（其他语言终于代码块）。查看以下代码： 1234if (window) &#123; var x = '123'; &#125; alert(x); 在其它语言中，x 终结于大括号关闭处，alert 弹出 undefined。","text":"先来抛出结论： 作用域与上下文肯定不是一回事。 作用域是由 function 进行声明的而非代码块（{ }）。 除了全局作用域，函数只要被声明（创建了），它就有了独立的作用域。 我们常说的上下文指的是 this，这里其实对 this 更准确的说法应该被称为函数上下文（function context）。 各大网文与部分书籍中所讲解的上下文，其实是执行环境（execution context）有的地方也称为执行上下文/执行上下文环境。这个执行环境不仅确定了 this （即我们常说的上下文对象），还确定了将各个作用域联系起来的作用域链。 执行环境并不是我们常说的上下文，而是用来确定它的指向。 本文中将采用高程3的说法 — 执行环境。 作用域在 Javascript 中，作用域是由 function 声明的，而不是代码块。声明的作用域创建于代码块，但不终于代码块（其他语言终于代码块）。查看以下代码： 1234if (window) &#123; var x = '123'; &#125; alert(x); 在其它语言中，x 终结于大括号关闭处，alert 弹出 undefined。 但是这里还是会出现 123，这是因为Javascript 中并没有块级作用域的概念。这样看起来很简单，但是其中还是有一些细微的差别。如下： 变量声明的作用域开始于声明开始的地方，结束于所在函数的结尾。 函数可以在其作用域范围内被提前引用（被提升），但变量不行。 对于作用域声明，全局作用域就像一个包含页面所有代码的超大型函数。 函数提升的详细原因参照下述的 三、执行环境 中的内容。 来看下面代码： 对于这段代码，执行调用 outer() 时，outer 函数中按照从上到下的顺序执行代码，当进入第2行时（在 outer 中，变量 a 声明前），inner 已经在作用域（scope）中，此时作用域中有 outer () 与 inner()。之后执行第 2 行，现在 a 也在 scope 中。当进入第 4 行时（在 outer 中，inner() 与 a 之后），由于函数声明提前这里第 3 行相当于已经提前执行，所以越过第 3 行，直接执行第 4 行。后面过程以此类推。 上下文（即我们常说的 this）在开始上下文之前我们需要明白我们研究的 this 是从哪里来的。其实这个问题很简单，在我们调用函数的时候关注点总是在可以看到的函数参数上面，而没有注意到俩个隐式（implicit）参数—— arguments 与 this。arguments 参数是传递给函数的一个所有参数的集合，它本质不是数组但是有 length 属性，所以我们更喜欢叫它类数组。this 参数引用了与该函数调用进行隐式关联的一个对象（这里需要注意，上下文是一个对象！），被称为函数上下文（function context）。 不同的方法进行函数调用决定了函数上下文的不同。总结如下： 作为普通函数进行调用时，其上下文是全局对象（window）。 作为方法调用的时候，其上下文是拥有该方法的对象。 作为构造器进行调用时，其上下文是一个新分配的对象。 通过函数的 apply/call 方法进行调用时，上下文可以设置成任意值。 对于上述的 1、2 点我们来看以下代码： 1-4 行代码，都是作为普通函数调用，上下文为window。6-12 行代码，都是做为方法调用，上下文是拥有该方法的对象（ninja1、ninja2）。对于第 3 点我们来看下列代码： 这时的上下文指新创建的 ninja ，通过第 8 行代码测试，我们发现 skulk 方法返回的是构造器对象本身。对于第 4 点我们来看下列代码： 通过 apply&amp;call 我们可以分别将上下文从 juggle 切换至 ninja1&amp;ninja2。 对于 apply&amp;call 我们很常用，所以扩展也很多。下面列出一个自定义 forEach 函数： 这个例子，列出了如何在回调中指定上下文，而在这里的9-12行我们也验证了如上所说的，this （上下文）是一个对象。因为在第 3 行代码处，我们传入的 List[i] 的类型是 string，但是经过 call 将其指定成上下文对象后在第 10 行我们比较时发现 this === heroList[index] 结果为 false，第 11 行验证了上下文确实是一个对象。这里是一个 String 对象具体信息就不再深究了，有兴趣的同学可以打印 this 出来看看。 执行环境（执行上下文/执行上下文环境） 这里再次重新声明，执行环境并不是我们常说的上下文，我们常说的上下文指的是 this（函数上下文）。该执行环境确定了作用域链（scope chain）与 this 。来一段高程三中对于执行环境的介绍如下： 执行环境（execution context，为简单起见，有时也称为“环境”）是Javascript中最重要的一个概念。执行环境定义了变量和函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据ECMAScript 实现所在宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行环境流入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正在由这个方便的机制控制着。 简洁明了，这里对于纯文字看着可能比较苦涩。来个图片以及例子，大家可以结合着消化。下面先给出 js 引擎执行函数时的进出栈图。 根据这幅图，大家结合下面代码与 executionContextAction.gif 可以很清楚的理解js线程工作的方式。代码片段： 12345678(function foo(i) &#123; if (i === 3) &#123; return; &#125; else &#123; foo(++i); &#125;&#125;(0)); 这个代码对应引擎处理函数的过程如下： 在搞清楚了引擎工作的方式后，我们还得知道执行环境在建立的时候发生的详细过程。建立阶段以及代码执行阶段的详细分析如下： 确切地说，执行环境是在函数被调用时，但是在函数体被真正执行以前所创建的。函数被调用时，就处于第一个阶段——建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行环境中。在这个阶段，variableObject 对象，作用域链，以及 this 所指向的对象都会被确定。 具体过程如下： 找到当前上下文中的调用函数的代码 在执行被调用的函数体中的代码以前（编译阶段），开始创建执行环境（执行上下文/执行上下文环境） 进入第一个阶段-建立阶段: 建立variableObject对象: 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值 确定参数变量，若有重名，以已有的变量为准。用已有的变量去覆盖参数变量 检查当前执行环境中的函数声明： 每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用。 如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。 检查当前执行环境中的变量声明： 每找到一个变量的声明，就在variableObject下，用变量名建立一个属性，属性值为undefined。 如果该变量名已经存在于variableObject属性中，直接跳过（防止指向函数的属性的值被变量属性覆盖为undefined），原属性值不会被修改。 初始化作用域链 确定上下文 — this（确定指向） 代码执行阶段: 执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。 来个例子来模拟引擎的执行过程。如下： 在调用 testEC(11) 时，真正执行 testEC(11) 之前，建立以下阶段： 由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段。如下： 那么通过上面例子中的三张图片我们能否发现在函数作用域中关于提升的一些秘密呢？答案是肯定的！在 testEC-prev.png 中 c 函数 是被提升的！因为在建立阶段c: pointer to function c ()，而 b 与 a 均是 undefined，由图上显而易见。 补充执行环境与作用域的关系 在执行环境中首先我们将参数、变量等都存在 VO（变量对象中），这是确确实实存在的，只能供内部使用。 执行环境只在函数被调用时创建 执行函数时 VO -&gt; AO（活动对象） 这时我们就可以使用了 一个作用域下可以没有执行环境（未被调用）；可以有1个；还可以有若干个（存在闭包） 如何在 callback 中绑定this在 div 节点事件函数内部，有一个局部的 callback 方法，callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往想让它指向该 div 节点。如下代码： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=\"test\"&gt;I am a div!&lt;/div&gt; &lt;script&gt; window.id = 'window'; document.getElementById('test').onclick = function () &#123; alert(this.id); // test var callback = function () &#123; alert(this.id); // window &#125;; callback(); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这种情况下我们需要一个变量保存 div 节点的引用： 1234567document.getElementById('test').onclick = function () &#123; var that = this; // 保存 div 节点引用 var callback = function () &#123; alert(that.id); // test &#125;; callback(); &#125;; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=utf-8 /&gt; &lt;title&gt;Events in JavaScript: Removing event listeners&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"element\"&gt;Click Me&lt;/button&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//var element = document.getElementById('element');var element = $('#element');var user = &#123; firstname: 'Bob', greeting: function()&#123; alert('My name is ' + this.firstname); &#125;&#125;;function bind (obj, name) &#123; return obj[name].apply(obj);&#125;// Attach user.greeting as a callback//element.addEventListener('click', bind(user, 'greeting'));element.on('click', user.greeting.bind(user))&lt;/script&gt; 这个例子是告诉我们无论原生js还是jquery在使用事件函数调用执行方法时函数上下文（this）默认指当前获取的dom元素（jq对象）所以当我们希望当前函数上下文指向user时我们应该改变函数上下文即改变this的指向。改变的方法有三种apply/call/bind。 参考资料： Javascript高级程序设计（第3版） Javascript Ninja 深入理解Javascript之执行上下文(Execution Context) 深入理解javascript原型和闭包（18）——补充：上下文环境和作用域的关系 最详细的JavaScript和事件解读","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"https://i7eo.com/tags/作用域/"},{"name":"上下文","slug":"上下文","permalink":"https://i7eo.com/tags/上下文/"},{"name":"执行环境","slug":"执行环境","permalink":"https://i7eo.com/tags/执行环境/"}]},{"title":"css水平垂直居中","slug":"css水平垂直居中","date":"2017-04-01T12:52:22.000Z","updated":"2019-01-05T06:05:26.310Z","comments":true,"path":"2017/04/01/css水平垂直居中.html","link":"","permalink":"https://i7eo.com/2017/04/01/css水平垂直居中.html","excerpt":"水平垂直居中水平垂直居中是老生常谈的话题，也是面试官比较喜欢问的问题。下面我对在实际中常常运用的几种方式做总结。HTML结构如下(这里我默认wrapper水平垂直居中)： 123 &lt;div class=\"wrapper\"&gt;&lt;div class=\"goal\"&gt;&lt;/div&gt; &lt;/div&gt;","text":"水平垂直居中水平垂直居中是老生常谈的话题，也是面试官比较喜欢问的问题。下面我对在实际中常常运用的几种方式做总结。HTML结构如下(这里我默认wrapper水平垂直居中)： 123 &lt;div class=\"wrapper\"&gt;&lt;div class=\"goal\"&gt;&lt;/div&gt; &lt;/div&gt; 有确定的宽高一般常用在包含众多div的容器层(常称为wrapper，这里一般美工都会标注好宽高)。 123456789101112131415161718 .wrapper &#123; position: absolute; top: 50%; left: 50%; margin: -100px 0 0 -100px; width: 200px; height: 200px; background-color: #ccc;&#125;.goal &#123; position: relative; top: 50%; left: 50%; margin: -50px 0 0 -50px; width: 100px; height: 100px; background-color: deeppink; &#125; 这样就实现了goal水平垂直居中。 宽高不确定可能更多地时候我们并不知道div的宽高，我们还需要实现水平垂直居中。那么我们可以这样做： 12345678910111213141516 .wrapper &#123; position: absolute; top: 50%; left: 50%; margin: -100px 0 0 -100px; width: 200px; height: 200px; background-color: #ccc;&#125;.goal &#123; position: absolute; top: 50%; left: 50%; background-color: deeppink; transform: translate(-50%, -50%); &#125; 而对于手机端来说我们更多的是采用flex布局的方式来实现水平垂直居中。代码如下： 12345678910111213141516171819202122 .wrapper &#123; display: -webkit-flex; display: flex; position: absolute; top: 50%; left: 50%; margin: -100px 0 0 -100px; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; width: 200px; height: 200px; background-color: #ccc;&#125;.goal &#123; position: absolute; top: 50%; left: 50%; background-color: deeppink; transform: translate(-50%, -50%); &#125; 也就是为.wrapper这个容器div设置水平/垂直(justify-content/align-items)的对齐方式，均设置为居中后容器中的.goal项目div自然水平垂直居中。(在flex布局中常把外层称为容器，内层div称为项目。) 利用伪元素来实现利用伪元素可以避免使用margin时在IE中的bug问题。 123456789101112131415161718192021 .wrapper &#123; width: 200px; height: 200px; text-align: center; background-color: #ccc;&#125;.goal &#123; display: inline-block; width: 100px; height: 100px; vertical-align: middle; background-color: deeppink; &#125; .wrapper:after &#123; content: ' '; display: inline-block; width: 0; height: 100%; vertical-align: middle; background-color: deeppink; &#125; 该方法的重点在于利用伪元素给goal这个div提供vertical-align所需的对齐中心点。详情可以参考我的上一篇微研究：CSS：使用伪元素做水平垂直居中的微深入研究 常用技巧左边栏 左边栏的常用实现方式有很多，这里我们介绍几种常用方式： 边框法：border-left: 5px solid blue; 伪元素法： 123456789 div:after &#123; content: ' '; position: absolute; top: 0; left: 0; width: 5px; height: 60px; background-color: blue; &#125; 内/外/四周阴影法：12box-shadow:-5px 0px 0 0 blue;/box-shadow:inset 5px 0px 0 0 blue;/ box-shadow: 0 0 5px blue(box-shaow 不占用元素的宽高哦) 单行居中，俩行居左，超过俩行省略。 主要实现依靠： 123display: -webkit-box; // 设置display，将对象作为弹性伸缩盒子模型显示 -webkit-line-clamp: 2; // 限制在一个块元素显示的文本的行数 -webkit-box-orient: vertical; // 规定框的子元素应该被水平或垂直排列 具体实现可以参考这篇文章：单行居中，两行居左，超过两行省略 短小标题的快速水平垂直居中法练手的项目中要实现一列菜单，菜单中的小标题需要水平垂直居中： 对于这种情况常用table布局。如下： 1234567891011121314 .menu-item &#123; display: table; width: 56px; height: 49px; padding: 0 12px; text-align: center; .text &#123; display: table-cell; width: 56px; vertical-align: middle; .border_1px(rgba(7, 17, 27, .1)); font-size: 12px; &#125;&#125; 只需要在父元素.menu-item中添加display:table，在子元素(需要水平垂直居中的元素)中添加display:table-cell;vertical-align:middle即可。","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://i7eo.com/categories/HTML-CSS/"}],"tags":[{"name":"水平垂直居中","slug":"水平垂直居中","permalink":"https://i7eo.com/tags/水平垂直居中/"}]},{"title":"webpack笔记","slug":"webpack笔记","date":"2017-03-05T10:41:08.000Z","updated":"2019-01-05T09:15:20.928Z","comments":true,"path":"2017/03/05/webpack笔记.html","link":"","permalink":"https://i7eo.com/2017/03/05/webpack笔记.html","excerpt":"webpack 2.0 用了小一个月了，一直都是照猫画虎。这俩天开始细读官网的部分文章结合一些讲解视频，深入学习一下。小结一发来汇总知识点。 webpack 的由来? 已存在的模块打包器对于大型应用（大型的SPA）来说并不适合。发展另一个模块打包器最迫切的原因那就是代码分割（Code Splitting）并且可以让静态资源能够无缝的适用于模块化。 webpack 可以做的事情？ 将项目间的依赖分割成代码块并按需加载","text":"webpack 2.0 用了小一个月了，一直都是照猫画虎。这俩天开始细读官网的部分文章结合一些讲解视频，深入学习一下。小结一发来汇总知识点。 webpack 的由来? 已存在的模块打包器对于大型应用（大型的SPA）来说并不适合。发展另一个模块打包器最迫切的原因那就是代码分割（Code Splitting）并且可以让静态资源能够无缝的适用于模块化。 webpack 可以做的事情？ 将项目间的依赖分割成代码块并按需加载 将初始化载入时间保持在最低 每一个静态资源都应被作为一个模块 有将第三方的库整合为模块的能力 有定制模块的能力 适合大型的单页应用- webpack 的特点有？ 代码分割：webapck 在它的依赖树中有俩种依赖关系，同步与异步！异步依赖可以分割成许多不同的点（部分）并且这些依赖来自于新的代码块。在块级树生效后，一个文件会被传递给每一个代码块。 加载器：webpack 是唯一的与生俱来就具有处理 JS 代码的能力，但是加载器被用来将其他源文件转换为 JS 文件。这样来做我们就可以处理来自不同模块的源文件。 智能解析：webpack 可以智能解析第三方库文件。它甚至允许在依赖中出现解释性的描述例如：require(&quot;./templates/&quot; + name + &quot;.jade&quot;)。具有 CMD&amp;AMD&amp;es6 三种处理模式。 插件系统：webpack 最有特点的就是它生态丰富的插件系统。许多内部的特性都建立在这个插件系统之上。它允许你定制你自己的需求并且可以将其开源。 以上是我对 what-is-webpack 的部分翻译，这些对于快速了解 webpack 来说足够了。 总所周知对于自动化构建这部分来说，我们可以使用的工具很多，比如：grunt 、gulp 等，那么这俩者与 webpack 有什么区别呢？ Grunt&amp;Gulp 是流程工具，其工作方式是在一个配置文件中，指明对某些文件进行的操作（诸如编译，组合，压缩等任务）的具体步骤，之后可以自动完成这些任务。流程如下： WebPack则是一个模块打包器，其工作方式通过主文件（index.js）找到全部依赖（自己设置的代码块、第三方库等）使用loaders 处理，最终打包为可执行的 Javascript 文件。流程如下： 下面通过实例来看看 webpack 的威力。 1&gt; 简单使用 1234mkdir webpack-1cd webpack-1npm initnpm install -d webpack --save-dev 安装完 webpack 2.0 后，新建 js&amp;html&amp;css 文件我的目录如下： hello.js 中的代码如下： 12345678require('./world.js');require('./style.css');function hello () &#123; alert('test!');&#125;hello(); style.css 中的代码如下： 1234567html , body&#123; padding: 0; margin: 0;&#125;body&#123; background-color: red;&#125; 在 webpack 能做的事情中我们了解到 webpack 具有识别 js 的能力，那 css 呢？答案是不能！那怎么解决呢？利用 loaders 来处理。对于 css 文件我们使用 css-loader&amp;style-loader 先利用 npm 分别安装。之后在当前目录下打开 cmd 键入以下命令：webpack hello.js hello.bundle.js --module-bind css=style-loader!css-loader --watch module-bind 命令用于启用 loader 处理主文件，watch 用来监视 hello.js 文件的变化，若变化则自动更新 hello.bundle.js 文件。 在项目中我们如果每次都要敲一长串命令的话很麻烦，我们只需要在package.json 的 script 中配上 webpack 命令。我得配置如下： &quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot; 其中 progress&amp;modules&amp;reasons分别代表过程百分比 / 各模块 / 打包原因。 我们可以将webpack的配置单独放在一个配置文件（webpack.config.js）中会自动读取该文件，如果该文件不存在或者名称不一致则需要通过命令行来运行（不存在的话通过 webpack 命令，名称不一致通过–config 来指定文件）。 对于 webpack 来说入口与出口肯定是必不可少的，那么在配置文件中我们这样写： 1234567module.exports = &#123; entry: './src/index.js', // entry: ['./src/index-1.js' , './src/index-2.js'] 多入口 output: &#123; //配置文件输出位置 filename: 'bundle.js', path: './dist/js' &#125;&#125;; 还有 entry 传入对象的形式入口： 12345678910module.exports = &#123; entry:&#123; main1: './src/index1.js', main2: './src/index2.js' &#125;, output: &#123; //配置文件输出位置 filename: '[name]-[chunkhash].js', // 这里如果还这样写filename: 'bundle.js'的结果是index2会把index1覆盖，所以我们利用内置的占位符 name &amp; chunkhash 来命名 path: './dist/js' &#125;&#125;; 这样的话在 index.html中引入的 js 文件名我们不可能每次打包完都要手动修改，这样很麻烦。所以我们需要使用插件来自动帮我们设置。npm install html-webpack-plugin 安装后修改配置文件为： 1234567891011121314151617181920212223242526272829var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; main: './src/scripts/main.js', mainA: './src/scripts/mainA.js' &#125;, output: &#123; //配置文件输出位置 filename: '[name]-[chunkhash]-bundle.js' //打包的文件名称*/ path : './dist', filename: 'js/[name]-[chunkhash].js', //把html与js分开存放 publicPath: 'http://bluespace/' //上线地址的绝对路径，自动替换当前项目中相对路径 &#125;, plugins: [ new htmlWebpackPlugin(&#123; //filename: '[hash].index.html', //名称 template: 'index.html', //以什么为模板，一般以配置文件下的index.html为模板 //inject: 'head' //scripts存放的位置 title: 'webpack is good!', inject: false, date: new Date(), minify: &#123; //压缩html文件，去除空格，去除注释 collapseWhitespace: true, removeComments: true &#125; &#125;) ]&#125;; 而 index.html 模板的代码如下（html-webpack-plugin支持ejs写法）： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/title&gt; &lt;script src=\"&lt;%= htmlWebpackPlugin.files.chunks.main.entry%&gt;\"&gt;&lt;/script&gt; &lt;!-- 把脚本分开放 --&gt; &lt;!-- htmlWebpackPlugin.options.date --&gt; &lt;/head&gt; &lt;body&gt; &lt;em&gt;&lt;%= htmlWebpackPlugin.options.date%&gt;&lt;/em&gt; &lt;script src=\"&lt;%= htmlWebpackPlugin.files.chunks.mainA.entry%&gt;\"&gt;&lt;/script&gt;&lt;!--如果想更加优化的话为了减少一次post请求，这里可以直接把script代码放进来，方法如下： &lt;script&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.mainA.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source()%&gt; &lt;/script&gt;--&gt; &lt;/body&gt;&lt;/html&gt; 2&gt; 利用 htmlwebpackplugin 构建多页应用 （已上传至 i7eo-github）3&gt; 配置常见的 loader 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var htmlWebpackPlugin = require('html-webpack-plugin'); var path = require('path'); module.exports = &#123; entry: './src/app.js', output: &#123; path: './dist', filename: 'js/[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: [&#123; loader: 'babel-loader', options: &#123; presets: ['es2015'] &#125; &#125;], include: path.resolve(__dirname , './src'), exclude: path.resolve(__dirname , './node_modules') //尽量使用绝对路径会提高打包速度在configruation里面通过exclude和include来提高打包速度 &#125;, &#123; test: /\\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; plugins: function()&#123; return [ require('autoprefixer') ]; &#125; &#125; &#125; ] &#125;, &#123; test: /.\\.less$/, use: [ 'style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: function()&#123; return [ require('autoprefixer') // postcss下的自动补全浏览器前缀的插件 ]; &#125; &#125; &#125;, 'less-loader' //使用less或者sass时不用为@import的less/sass添加importLoaders:1因为自动添加。因为less/sass支持import ] &#125;, &#123; test: /\\.html$/, use: 'html-loader' // 将html当做字符串处理，对应innerhtml。坏处是不能使用for等模板语法 &#125;, &#123; test: /\\.ejs$/, use: 'ejs-loader' // 把html当做模板处理 &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/i, //用包管理工具除了模板外的文件放置相对路径没有问题，但是在模板文件中应该![]($&#123;require('../../assets/George.jpg')&#125;) use: [ &#123; loader: 'url-loader', //url-loader可以设置limit若图片体积小于limit的话则通过url-loader转化为base64代码，若大于则调用file-loader options: &#123; name: 'assets/[name]-[hash:5].[ext]', limit: 4000 //经常需要加载的图片利用http请求较好，因为可以享受到缓存，而base64则需每次读取 &#125; &#125;, 'image-webpack-loader' //压缩图片体积 ] &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: 'body' &#125;) ] &#125;; 参考资料： webpack 入门webpack，看这篇就够了 html-webpack-plugin","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://i7eo.com/tags/webpack/"}]},{"title":"浅谈响应式布局&自适应布局","slug":"浅谈响应式布局-自适应布局","date":"2017-02-15T04:35:53.000Z","updated":"2019-01-05T06:08:06.668Z","comments":true,"path":"2017/02/15/浅谈响应式布局-自适应布局.html","link":"","permalink":"https://i7eo.com/2017/02/15/浅谈响应式布局-自适应布局.html","excerpt":"一、响应式布局1、什么是响应式页面？响应式布局可以一统pc&amp;mobile吗？响应式与自适应式布局的区别？ 响应式简单来说是一个网站的布局 能够兼容多个不同终端， 而并不是传统的pc端一套页面，移动端一套页面。 当初Ethan Marcotte在2010年5月份提出的这个概念的时候是希望响应式可以一统pc&amp;mobile页面，同时我们也做到了。但是这样带来的问题也越发让开发者心烦意乱，最重要的一点就是兼容各种设备会导致 大量累赘的代码，维护与重构较麻烦。 响应式布局讲究的是使用一套布局代码来在不同终端展示，根据屏幕尺寸的大小对页面的布局进行改造（即当屏幕变小时，开发者可能会让标题栏中原本显示10个子标题现在只显示5个，隐藏剩下的5个或者让其在第二行出现），而","text":"一、响应式布局1、什么是响应式页面？响应式布局可以一统pc&amp;mobile吗？响应式与自适应式布局的区别？ 响应式简单来说是一个网站的布局 能够兼容多个不同终端， 而并不是传统的pc端一套页面，移动端一套页面。 当初Ethan Marcotte在2010年5月份提出的这个概念的时候是希望响应式可以一统pc&amp;mobile页面，同时我们也做到了。但是这样带来的问题也越发让开发者心烦意乱，最重要的一点就是兼容各种设备会导致 大量累赘的代码，维护与重构较麻烦。 响应式布局讲究的是使用一套布局代码来在不同终端展示，根据屏幕尺寸的大小对页面的布局进行改造（即当屏幕变小时，开发者可能会让标题栏中原本显示10个子标题现在只显示5个，隐藏剩下的5个或者让其在第二行出现），而 自适应布局则相反，它使用一套布局代码不会根据屏幕大小改变还改变布局结构，它只是会等比缩小或者放大对应内容的尺寸。 ２、响应式布局采用的技术 控制视口（viewport） 控制视口这一点不论是响应式、自适应还是移动端布局都是最重要的。我们常常会使用这一句： 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no\"\"&gt; 视口宽度等于设备宽度，初始缩放比最大缩放比与最小缩放比均为1，禁止用户缩放。详细描述可查看 MDN-meta。在这里可能有的朋友会见到设备像素比（dpr 即 deivcePixelRatio）也就是物理像素与设备独立像素的比值，常见的有retina屏等。详情可以参考张鑫旭老师的这篇 设备像素比devicePixelRatio简单介绍 文章。 CSS的媒体查询（media query） 使用@media 查询，你可以针对不同的媒体类型定义不同的样式。请看下例： 1234567@media only screen and (max-width: 480px)&#123; header .top .tel, header .top ul li:nth-child(3), header .top ul li:nth-child(4)&#123; display: none; &#125;&#125; 这个代码片意思是当设备视口宽度达到480px时对 li 于.tel 进行处理。media query的详情可以查看 MDN-media 。这里需要注意的一点是很多人编写响应式布局时都喜欢由pc大屏开始，慢慢到pad再到mobile，这里我建议设计的时候可以从小屏的mobile开始，先确定内容然后逐级向大屏设计。对于IE9以下浏览器我们需要引入一个关于media query 的 polyfill（可以理解为补丁包）， css3-mediaqueries.js 或者 respond.js。 自适应图片等素材 这里我们常对图片做处理，处理的方法有很多我们可以采用HTML5 picture 标签，利用该标签可以在不同设备中显示不同的图片。如下代码：1234567&lt;picture&gt; &lt;source media=\"(max-width: 36rem)\" srcset=\"img/ad001-l-480w.png\"/&gt; &lt;source srcset=\"img/ad001-l-1600w.png\"/&gt; ![](img/ad001-l.png) &lt;/picture&gt; source 代表你要显示图片的源，media代表你需要什么条件下显示该图片，srcset 须填写图片路径d s代码片意思是当设备视口宽度大于36rem 时显示 ad001-l-480w.png 这张图片，若小于 36rem 则使用ad001-l-1600w.png 这张图片，要是浏览器不支持 picture 则使用 img 标签中的图片。picture 详细信息可查看 MDN-picture 同样的这里需要注意在 IE9&amp;IE9以下 浏览器想使用 picture 须导入 polyfill ，这里我使用的是 html5shiv.js 。 二、自适应布局１、自适应的布局的前世今生 很多人还是喜欢把自适应称为百分比布局，而我认为自适应是百分比的增强版，这个概念包括了很多新技术与小技巧而并非单纯的使用百分比实现页面布局。请看下图： 这个结构很简单，如下： 12345678&lt;div class=\"main about\"&gt; &lt;span class=\"title\"&gt;&lt;span class=\"icon\"&gt;&lt;/span&gt;&lt;a href=\"aboutUs\"&gt;关于我们&lt;/a&gt;&lt;/span&gt; &lt;div class=\"mainText\"&gt; &lt;a href=\"aboutUs\"&gt; &lt;p class=\"content\"&gt;&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;` 对应的样式为： 12345678910111213141516171819202122232425262728293031.container .main&#123; width: 90%; margin: 0 auto;&#125;.container .main .title&#123; display: inline-block; margin: 1.425rem 0; font-size: 1.25rem; color: rgb(13,76,187);&#125;.container .main .title .icon&#123; margin-right: 1rem; vertical-align: middle;&#125;.container .main .icon&#123; display: inline-block; width: .25rem; height: 1.3rem; background: url(../img/indexPage/mainBtn.png);&#125;.container .main .mainText img&#123; width: 100%; height: 100%;&#125;.container .main .content&#123; margin: 1.2rem 0 1.425rem 0; text-indent: 1.7rem; font-size: .9rem; line-height: 1.35rem; color: #3d3d3d;&#125; 在项目中更多的使用的都是组合计，百分比控制各个容器的宽和少量的高度，用 rem 来控制 padding/margin/font/height 等。至此，利用百分比布局的方式即“前世”，而“今生”则是在不断的混合新的技术不断增强。对于今生，显然我们还有 web App 没有说，那我们就来看看移动端的 web 页面。 2、rem 上面出现了一个单位rem，那么rem到底是什么？ rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 对于一个网页来说，rem的初始值为 16px，当然这个值是可以根据当前项目中的需要来改变的，设置html的font-size即可。比如说：拿到了一份宽度为680px，rem为20px的设计稿其中某元素宽度为200px，但是如果要在宽度为375与414的屏幕上显示，那么我们应该设置为多少呢？ 宽度 宽度比 html(font-size) 某元素宽度(px) 某元素宽度(rem) 384 384/640=0.6 12px 120px 10rem 480 480/640=0.75 15px 150px 10rem 重点是要计算出html的font-size，如果是retina屏还需注意dpr。如果我们想快速上手不想计算的话可以引入flexible.js，这个脚本主要是根据媒体查询来动态设置html font-size，兼容性还不错。 3、webApp 中的自适应利器 - flex弹性布局 由于 media query的出现影响了很大一部分开发人员，所以在早些时候的 webApp 页面中还是会出现众多的 media query 。直到 flex 流行开来后我们逐步认识到 flex 的强大，因为 flex 上手简单，代码精简，一小段就可以完成我们常说的“圣杯布局”等，也可以完成常考的水平垂直问题。关于 flex 大家可以参考阮一峰老师的教程，讲解的十分详细。Flex 布局教程：语法篇。请看下例： 顺手拉来自己练手的 vue2 中用 flex 布局后的页面，可以看到 pc&amp;mobile 完美驾驭。因为目前各大浏览器对 flex 的支持度在增加所以 pc&amp;mobile 均可使用就在不久的将来 ，不过一般还是更多的用在移动端。","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://i7eo.com/categories/HTML-CSS/"}],"tags":[{"name":"flex","slug":"flex","permalink":"https://i7eo.com/tags/flex/"},{"name":"rem","slug":"rem","permalink":"https://i7eo.com/tags/rem/"}]},{"title":"底部固定(sticky footer)","slug":"sticky-footer","date":"2017-01-03T11:59:34.000Z","updated":"2019-01-05T06:07:31.495Z","comments":true,"path":"2017/01/03/sticky-footer.html","link":"","permalink":"https://i7eo.com/2017/01/03/sticky-footer.html","excerpt":"滚动条的出现总是在浏览器的最右边和最下方，牢牢的 fixed在页面上。大多数时候我们看到的是这样的","text":"滚动条的出现总是在浏览器的最右边和最下方，牢牢的 fixed在页面上。大多数时候我们看到的是这样的 这样子很明显登录的小人按钮被挡住了，而且真的不太美观。这时我们就希望头部吸顶，滚动条出现在下方的div内。如下图： 其实实现很简单，在头部（header）和内容（section）外面再包裹一层（.wrapper），给 .wrapper 层高度 100%；然后让内层 section 绝对定位，设置 top/overflow-y 即可。HTML 结构如下： 12345678&lt;div class=\"wrapper\"&gt; &lt;header&gt; &lt;span class=\"title\"&gt;This is header!&lt;/span&gt; &lt;/header&gt; &lt;section&gt; 这里添加超过页面高度的内容 &lt;/section&gt;&lt;/div&gt; 样式代码如下： 12345678910111213141516171819202122232425body &#123; overflow: hidden; &#125;.wrapper &#123; position: relative; height: 100%; min-height: 100%; overflow: hidden; &#125;header &#123; position: relative; padding: 0 90px; height: 48px; background: #efeff0; border-bottom: 1px solid #fff; text-align: center; &#125;section &#123; position: absolute; top: 48px; left: 0; bottom: 0; right: 0; overflow-y: scroll; &#125; 但是这样显示section中的内容是显示不出来的。如下： 这里的原因是因为我们在 .wrapper 中设置 height: 100%，而设置高度百分比时这个百分比时根据父元素的高度来计算的，这里的父元素是 body&amp;html，没有设置 height 时父元素 body&amp;html 的 height: auto，这时要求浏览器根据这样一个缺省值来计算百分比高度时，只能得到 undefined 的结果。也就是一个 null 值，浏览器不会对这个值有任何的反应（详情见下面链接）。所以我们需要在将样式修改为： 12345678910111213141516171819202122232425262728html,body &#123; height: 100%; &#125;body &#123; overflow: hidden; &#125;.wrapper &#123; position: relative; height: 100%; min-height: 100%; overflow: hidden; &#125;header &#123; position: relative; padding: 0 90px; height: 48px; background: #efeff0; border-bottom: 1px solid #fff; text-align: center; &#125;section &#123; position: absolute; top: 48px; left: 0; bottom: 0; right: 0; overflow-y: scroll; &#125; 效果如下： 底部固定又叫 css sticky footer，网上的实现方式有很多。下来介绍一个简单实用的方式，对应的 HTML 结构如下： 123456789&lt;div class=\"content-wrapper\"&gt; &lt;header&gt; &lt;span class=\"title\"&gt;This is header!&lt;/span&gt; &lt;/header&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;div class=\"close\"&gt; × &lt;/div&gt;&lt;/div&gt; CSS 代码如下： 123456789101112131415161718192021222324252627282930313233343536html,body &#123; height: 100%; &#125; .content-wrapper &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; min-height: 100%; overflow: auto; background: rgba(7, 17, 27, .8); z-index: 100; &#125; header &#123; position: relative; width: 100%; height: 48px; background: #efeff0; text-align: center; &#125; .content &#123; width: 90%; margin: 0 auto; padding-bottom: 64px; &#125; .close &#123; position: relative; width: 100%; height: 64px; margin: -64px auto 0; padding-top: 16px; font-size: 32px; clear: both; text-align: center; &#125; 效果如下： 我们的关闭 icon 均在文字的最下方，根据内容的高度变化而改变。显然这并不是我们想要的效果，我们想要的是不论内容是否撑满屏幕高度这个关闭的 icon 都要固定在最下方，而 exhibition-1.png 中的现象是出现在了内容的底部而不是屏幕的底部。所以我们应该对为这个整体再包裹一层，然后把 .close 这个 div 放出去与 content-wrapper 同级即可。修改后的 HTML/CSS 代码如下： 123456789101112&lt;div class=\"wrapper\"&gt; &lt;div class=\"content-wrapper\"&gt; &lt;header&gt; &lt;span class=\"title\"&gt;This is header!&lt;/span&gt; &lt;/header&gt; &lt;div class=\"content\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"close\"&gt; × &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536.wrapper &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; background: rgba(7, 17, 27, .8); z-index: 100; &#125; .content-wrapper &#123; width: 100%; min-height: 100%; &#125; header &#123; position: relative; width: 100%; height: 48px; background: #efeff0; text-align: center; &#125; .content &#123; width: 90%; margin: 0 auto; padding-bottom: 64px; &#125; .close &#123; position: relative; width: 100%; height: 64px; margin: -64px auto 0; padding-top: 16px; font-size: 32px; clear: both; text-align: center; &#125; 最终效果如下： 完成效果。 最后我们来总结一下 css sticky footer 的步骤。第一步需要一个大容器（.content-wrapper）设置 min-height 为100%，撑满整个可视区域，不然你需要 sticky 的 footer 就不会出现在你的视线里;第二步在 content-wrapper 中创建你的内容区域，在内容区内建立了一个 content ，这时的内容区域（content）一定要设置 padding-bottom 来为你的 footer（.close） 占位;第三步在 content-wrapper 同级下创建你的 footer（.close），然后相对定位（相对于content-wrapper）然后这里的 margin-top 必须为负（填充你在第二步中所占的空间这里的负值必须与第二步中设置的值相同，锁死 footer 的位置）。","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://i7eo.com/categories/HTML-CSS/"}],"tags":[{"name":"sticky footer","slug":"sticky-footer","permalink":"https://i7eo.com/tags/sticky-footer/"}]}]}