{"meta":{"title":"Solitude is freedom","subtitle":"Articles on front-end development by George Tan","description":"A man who dreams of being a full stack engineer","author":"George Tan","url":"https://i7eo.com"},"pages":[{"title":"关于我","date":"2017-09-28T00:09:53.000Z","updated":"2018-12-30T07:41:58.142Z","comments":true,"path":"about/index.html","permalink":"https://i7eo.com/about/index.html","excerpt":"","text":"一个梦想成为全栈的前端工程师。喜欢： Javascript NodeJs Java 常用技术： Vue&amp;Vuex Nuxt JQuery Mongodb redis koa&amp;express 联系我： Weibo: @SrilamoM GitHub: GeorgeTan Gmail: georgetan704t@gmail.com"}],"posts":[{"title":"Javascript面向对象笔记","slug":"Javascript面向对象笔记","date":"2018-12-30T02:29:48.000Z","updated":"2018-12-30T02:29:48.500Z","comments":true,"path":"2018/12/30/Javascript面向对象笔记.html","link":"","permalink":"https://i7eo.com/2018/12/30/Javascript面向对象笔记.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mac下利用Alfred与七牛搭建markdown图床","slug":"Mac下利用Alfred与七牛搭建markdown图床","date":"2018-07-04T07:57:58.000Z","updated":"2018-12-30T07:41:58.143Z","comments":true,"path":"2018/07/04/Mac下利用Alfred与七牛搭建markdown图床.html","link":"","permalink":"https://i7eo.com/2018/07/04/Mac下利用Alfred与七牛搭建markdown图床.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后）","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后） 七牛账号&amp;七牛自动化工具qshell 截图工具（这个也可以没有，可以利用电脑自带的截图功能，只要保证截图动作后的结果处于剪切板中即可） 第一部分：（七牛操作）第一步：注册成功登陆后，单击 管理控制台 -&gt; 对象存储 -&gt; 内容管理 找到外链默认域名，复制并保存。 第二步：返回首页，单击 服务与支持 -&gt; 开发者中心 -&gt; sdk与工具 -&gt; 开发者工具 -&gt; qshell 进入后按照提示下载并安装。 第三步：创建账户时，除了ak&amp;sk 现在还需要输入七牛账户名；配置upload.conf文件时需要注意如果本地新增文件七牛默认不会自动检查，你需要设置 rescan_local: true ;如果你在七牛空间（web页）中手动删除某个文件，再次上传该文件的时候七牛默认该文件已经存在空间中，不会再上传该文件，你需要配置 check_exists: true 。 第二部分：（alfred workflow操作）第一步： 点击 + ，创建blank workflow即可，注意bundle id必填一个唯一值，能够在alfred中标示你这个workflow即可，其余选项正常填写，category默认选项即可。 第二步： 创建热键hotkey，其余默认选项不变，完成后save。 创建热键触发后需要执行的脚本文件，当然run script创建的脚本是后台运行不需要先调出terminal（控制台），如果需要调出terminal（控制台），选择terminal command。根据脚本语言对应选择language，这里提供一个as版本代码：12345678910111213141516171819202122232425262728293031323334353637383940414243property fileTypes : &#123;¬ &#123;«class PNGf», \".png\"&#125;, ¬ &#123;JPEG picture, \".jpg\"&#125;&#125;on getType() --判断剪贴板中的数据类型，暂时只支持png和jpg，优先用png repeat with aType in fileTypes repeat with theInfo in (clipboard info) if (first item of theInfo) is equal to (first item of aType) then return aType end repeat end repeat return missing valueend getTypeset theType to getType()if theType is not missing value then set filePath to \"/Users/xxx/Documents/screenCaptures/\" --这里换成你自己放置图片的路径 set fileName to do shell script \"date \\\"+%Y%m%d%H%M%S\\\" | md5\" --用当前时间的md5值做文件名 set prefix to \"i7eo_\" -- 改成自己的前缀 if fileName does not end with (second item of theType) then set fileName to (fileName &amp; second item of theType as text) set markdownUrl to \"![截图](https://xxx.com/i7eo_\" &amp; fileName &amp; \")\" --这里如果没有用到图床，就把前面前缀去掉，用到的话换成你自己图床的url set filePath to filePath &amp; prefix &amp; fileName try set imageFile to (open for access filePath with write permission) set eof imageFile to 0 write (the clipboard as (first item of theType)) to imageFile -- as whatever close access imageFile set the clipboard to markdownUrl try tell application \"System Events\" keystroke \"v\" using command down end tell end try on error try close access imageFile end try return \"\" end tryelse return \"\"end if 把 https://xxx.com/改为之前从七牛默认外链处复制出来的地址。 第三步：再次创建一个blank workflow，热键自己设置；再次创建一个as脚本，具体代码如下：1do shell script \"/usr/local/bin/qshell qupload ~/.qshell/upload.conf\" 把qupload前的路径换成自己存放七牛qshell文件的位置。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法适合写博客时，把该篇博客需要的图片都存放在同一个文件下，写完后一次性上传至七牛空间。然后在把博客推至gitpage即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想每次插入一张图片就上传，可以使用插件 Mac 版本的 Markdown 一键贴图工具 alfred3 Powerpack","categories":[{"name":"自动化","slug":"自动化","permalink":"https://i7eo.com/categories/自动化/"}],"tags":[{"name":"Alfred3 workflow","slug":"Alfred3-workflow","permalink":"https://i7eo.com/tags/Alfred3-workflow/"},{"name":"图床","slug":"图床","permalink":"https://i7eo.com/tags/图床/"},{"name":"qshell","slug":"qshell","permalink":"https://i7eo.com/tags/qshell/"}]},{"title":"Nuxt.js踩坑实录","slug":"Nuxt.js踩坑实录","date":"2018-05-01T15:22:36.000Z","updated":"2018-12-28T18:53:22.940Z","comments":true,"path":"2018/05/01/Nuxt.js踩坑实录.html","link":"","permalink":"https://i7eo.com/2018/05/01/Nuxt.js踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ?","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ? SSR =&gt; server-side-render，即服务器端渲染。具体过程如下： 用户请求页面 后端取到准备好的数据，渲染到我们自己写的服务器模版（next/nuxt/ejs）中，准备好html结构与相应数据后返回给浏览器 CSR &amp; SSR 优缺点对比 优点 缺点 CSR 减轻服务器压力，前后端分离 对seo不友（不利于爬虫爬取），首页渲染存在白屏问题 SSR 对seo友好，首页渲染完美无白屏问题 对服务器性能有一定要求，不利于前后端分离 其实在真正开发中通常是 csr 与 ssr 相结合使用，前端使用cdn缓存，后端使用nginx缓存。这样是最优的解决方案。上两张图大家对比理解： Nuxt.js什么是 Nuxt ?Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。 Nuxt 流程 nuxtServerInit请求先到达 nuxtServerInit 方法，图中也表明了适用场景是对 store 的 action 操作即（vuex）： middleware下来请求到达 middleware 属性，虽然这里叫做中间件属性，但还是做着同中间件一样的事。官方给出的定义：1中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。 也就是说，定义 middleware 属性后你可以在 匹配布局（layout 组件）前执行某种操作，也可以在解析完 layout 之后，解析 page 组件前 执行某种操作。 validate下来请求到达 validate 方法，在这里可以对 page 组件或者 page 中的子组件 component 进行动态路由对应的页面组件中动态路由参数的有效性。 asyncData &amp; fetch接下来达到 asyncData &amp; fetch 方法，asyncData() 适用于在渲染组件前获取异步数据，fetch() 适用于在渲染页面前填充 vuex 中维护的数据。 render最后进行渲染。将渲染后的页面返回给浏览器，用户在页面进行操作，如果再次请求新的页面，此时只会回到生命周期中的 middlerware 中，而非 nuxtServerInit ，所以如果不同页面间需要操作相同的数据请用 vuex 来维护。 Nuxt 笔记Nuxt 项目结构 通过 12npm install npxnpx create-nuxt-app xxx 生成如上结构，布局组件（layout）用来存放页面整体布局，在 layout 中我们可以放入一些每个页面都会以用到的组件，比如 header &amp; footer。当然如果你不想使用已生成的 layout 组件，你可以重新创建一个，比如 blank.vue 一般不需要引入 header&amp;footer 的页面可以使用 blank.vue 这个 layout 组件。代码如下： 1layout: &apos;blank&apos; 在 nuxt 中引入 layout 不用写路径，nuxt 已经帮我们做了映射，同理在 nuxt 中不用写路由，pages 中文件名映射为了路由。 nuxt 中的钩子函数nuxt 中提供很多钩子函数，参考文档：nuxt hooks 这里我们主要来看 vue 组件生命周期中钩子函数，服务器端的 vue 组件也是有生命周期的，只不过只有 beforeCreate 和 created 俩个。也就是说，我们把服务器端创建的 .vue 文件全部理解成组件，在服务器端环境（node）通过 beforeCreate 和 created 这俩个生命周期节点后服务器端 vue 组件生命周期结束。返回页面给浏览器，在客户端环境（v8）中这个 vue 组件实例创建后会在客户端再次拥有生命周期，此时生命周期中有 mounted 等钩子函数。 需要特别注意的是 nuxt 中没有 mounted 钩子函数也没有组件实例，只有 beforeCreate/created 钩子与 context 对象。 asyncData() 传递服务器数据至客户端在 asyncData() 中可以处理请求得来的数据，通过 return 将处理后的数据返回给当前 vue 组件的 data 。再次强调这里不能使用 this ，因为没有组件实例，asyncData() 默认的参数是 ctx 即 content 对象。 对于打开网页要立即显示的内容，如首页中的 geo 组件（显示当前位置）来说有俩种方式实现，如下： ssr nuxtServerInit 方法 middleware 属性 vue 组件 mounted 函数发送请求 no-ssr 即 mounted 函数方式实现相信大家都很熟悉。主要来说说 ssr 对应的俩种实现方式。 nuxtServerInit() 前面也说过，搭配 vuex 使用，所以顾名思义，在 nuxtServerInit 函数中准备好首页 geo 组件需要的数据存入 vuex，这样 vuex 实例化后的 store 会贯穿整个服务器端与客户端的生命周期。可能有的同学会问这是怎么传过去的？文末会截图说明。所以在首页返回客户端时数据存在 store 实例中可直接获取即可。获取方式如下： 服务器端： 12ctx.store.state.xxx.xxx.xxx// eg: ctx.store.state.home.position.city 客户端： 12this.$store.state.xxx.xxx.xxx// eg: this.$store.state.home.position.city middleware 属性是在 vue 组件中直接定义即可，如下： 1234middleware: async (ctx) =&gt; &#123; let &#123;status, data: &#123;province, city&#125;&#125; = await ctx.$axios.get(&apos;/geo/getPosition&apos;) ... &#125; 问题来了，如何将获取的 data 赋值给组件中的 data 呢？上面在 nuxt流程图 部分我们分析过，渲染前的最后一步是 asyncData&amp;fetch ，这里我们还是需要用 asyncData 方法把 data 给组件 return 即可。具体做法见官方给出的 issue &amp; 例子： issue：#1738 nuxt/fn-midd.vue 解答上面遗留的问题，ssr 生成的页面如何把 vuex 实例后的 store 传给客户端？ 其实在服务器返回页面给浏览器时会传一个名为 __NUXT__ 的对象挂载在 window 上，这里面存储了 store 。如下： 如图可以找到 $store.state.home.position.city 这个数据。 参考文章： The Benefits of Server Side Rendering Over Client Side Rendering NUXT-Universal Vue.js Applications","categories":[{"name":"Vue SSR","slug":"Vue-SSR","permalink":"https://i7eo.com/categories/Vue-SSR/"}],"tags":[{"name":"Nuxt.js","slug":"Nuxt-js","permalink":"https://i7eo.com/tags/Nuxt-js/"},{"name":"SSR","slug":"SSR","permalink":"https://i7eo.com/tags/SSR/"}]},{"title":"为git page开通https踩坑实录","slug":"为gitPages开通https踩坑实录","date":"2017-10-01T08:37:27.000Z","updated":"2018-12-28T18:56:19.680Z","comments":true,"path":"2017/10/01/为gitPages开通https踩坑实录.html","link":"","permalink":"https://i7eo.com/2017/10/01/为gitPages开通https踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合自己的代码发现引用的图片全是http协议下的，而且在input（即使type≠keyword）输入内容时感叹号变成了红字叉。我所用的是阿里的域名所以去网站查询https的信息，发现有免费的赛门铁克（Symantec）证书试用。果断申请后，发现： gitPages注意事项 git page自带https，在对应rep的设置中，点击 Enforce HTTPS 即可。 git page绑定自定义域名后无法添加ssl证书。这个时候有点懵了，不过检索多次相关关键字后，发现了cloudflare这个好东西。大概了解了下后就确定用它了，好处如下： 安利cloudflare的原因 有免费套 cloudflare的dns服务器风评还是不错的-cloudflare提供 Universal SSL 服务，简单来说就是让任意http站点支持https。 （具体原理指的是，用cloudflare的dns服务器，当你访问网页时，网页 -&gt; cloudflare 这个过程是加密的，而 cloudflare -&gt; git page这个过程是非加密（http）） 具体可参考官方文档： how Cloudflare’s servers connect to your origin for HTTPS requests cloudflare配置的具体步骤第一步：设置dns把自己对应的dns服务器改为cloudflare的，下面以阿里来举例。阿里云 -&gt; 域名 -&gt; 管理 -&gt; 修改dns，出现一下界面： 这是我已经修改后的，单击右边的修改dns服务器即可，把cloudflare给出的俩个dns地址换上来就好。cloudflare给出的dns地址位于：cloudflare -&gt; dns -&gt; Cloudflare Nameservers。 如何判断更换dns成功？回到cloudflare后，单击overview，如果成功会出现： 第二步：设置dns信息cloudflare -&gt; dns -&gt; DNS Records 如果这里没设置时有记录先删除，新增一条记录: 第三步：设置ssl&amp;强制跳转cloudflare -&gt; crypto -&gt; SSL 勾选flexible cloudflare -&gt; crypto -&gt; Always Use HTTPS 勾选on 第四步：坐等&amp;排错大概10mins - 30mins左右就会生效，可以在等待的时候使用ping命令来ping个人的域名查看ip。 如果你的博客出现以下情况： 检查gitpage的设置，取消掉勾选的Enforce HTTPS选项，这个设置是有缓存的 可以切换source或者theme chooser这样可以清理掉缓存的Enforce HTTPS选项信息。 参考文章： 使用Cloudflare为自定义域名的GithubPages实现HTTPS化 解决Cloudflare产生的“ERR_TOO_MANY_REDIRECTS”错误","categories":[{"name":"运维","slug":"运维","permalink":"https://i7eo.com/categories/运维/"}],"tags":[{"name":"cloudflare","slug":"cloudflare","permalink":"https://i7eo.com/tags/cloudflare/"},{"name":"https","slug":"https","permalink":"https://i7eo.com/tags/https/"}]}]}