{"meta":{"title":"Solitude is freedom","subtitle":"Articles on front-end development by George Tan","description":"A man who dreams of being a full stack engineer","author":"George Tan","url":"https://i7eo.com"},"pages":[{"title":"关于我","date":"2017-09-28T00:09:53.000Z","updated":"2018-12-30T07:41:58.142Z","comments":true,"path":"about/index.html","permalink":"https://i7eo.com/about/index.html","excerpt":"","text":"一个梦想成为全栈的前端工程师。喜欢： Javascript NodeJs Java 常用技术： Vue&amp;Vuex Nuxt JQuery Mongodb redis koa&amp;express 联系我： Weibo: @SrilamoM GitHub: GeorgeTan Gmail: georgetan704t@gmail.com"}],"posts":[{"title":"Nuxt.js踩坑实录","slug":"Nuxt.js踩坑实录","date":"2018-05-01T15:22:36.000Z","updated":"2018-12-28T18:53:22.940Z","comments":true,"path":"2018/05/01/Nuxt.js踩坑实录.html","link":"","permalink":"https://i7eo.com/2018/05/01/Nuxt.js踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ?","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ? SSR =&gt; server-side-render，即服务器端渲染。具体过程如下： 用户请求页面 后端取到准备好的数据，渲染到我们自己写的服务器模版（next/nuxt/ejs）中，准备好html结构与相应数据后返回给浏览器 CSR &amp; SSR 优缺点对比 优点 缺点 CSR 减轻服务器压力，前后端分离 对seo不友（不利于爬虫爬取），首页渲染存在白屏问题 SSR 对seo友好，首页渲染完美无白屏问题 对服务器性能有一定要求，不利于前后端分离 其实在真正开发中通常是 csr 与 ssr 相结合使用，前端使用cdn缓存，后端使用nginx缓存。这样是最优的解决方案。上两张图大家对比理解： Nuxt.js什么是 Nuxt ?Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。 Nuxt 流程 nuxtServerInit请求先到达 nuxtServerInit 方法，图中也表明了适用场景是对 store 的 action 操作即（vuex）： middleware下来请求到达 middleware 属性，虽然这里叫做中间件属性，但还是做着同中间件一样的事。官方给出的定义：1中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。 也就是说，定义 middleware 属性后你可以在 匹配布局（layout 组件）前执行某种操作，也可以在解析完 layout 之后，解析 page 组件前 执行某种操作。 validate下来请求到达 validate 方法，在这里可以对 page 组件或者 page 中的子组件 component 进行动态路由对应的页面组件中动态路由参数的有效性。 asyncData &amp; fetch接下来达到 asyncData &amp; fetch 方法，asyncData() 适用于在渲染组件前获取异步数据，fetch() 适用于在渲染页面前填充 vuex 中维护的数据。 render最后进行渲染。将渲染后的页面返回给浏览器，用户在页面进行操作，如果再次请求新的页面，此时只会回到生命周期中的 middlerware 中，而非 nuxtServerInit ，所以如果不同页面间需要操作相同的数据请用 vuex 来维护。 Nuxt 笔记Nuxt 项目结构 通过 12npm install npxnpx create-nuxt-app xxx 生成如上结构，布局组件（layout）用来存放页面整体布局，在 layout 中我们可以放入一些每个页面都会以用到的组件，比如 header &amp; footer。当然如果你不想使用已生成的 layout 组件，你可以重新创建一个，比如 blank.vue 一般不需要引入 header&amp;footer 的页面可以使用 blank.vue 这个 layout 组件。代码如下： 1layout: &apos;blank&apos; 在 nuxt 中引入 layout 不用写路径，nuxt 已经帮我们做了映射，同理在 nuxt 中不用写路由，pages 中文件名映射为了路由。 nuxt 中的钩子函数nuxt 中提供很多钩子函数，参考文档：nuxt hooks 这里我们主要来看 vue 组件生命周期中钩子函数，服务器端的 vue 组件也是有生命周期的，只不过只有 beforeCreate 和 created 俩个。也就是说，我们把服务器端创建的 .vue 文件全部理解成组件，在服务器端环境（node）通过 beforeCreate 和 created 这俩个生命周期节点后服务器端 vue 组件生命周期结束。返回页面给浏览器，在客户端环境（v8）中这个 vue 组件实例创建后会在客户端再次拥有生命周期，此时生命周期中有 mounted 等钩子函数。 需要特别注意的是 nuxt 中没有 mounted 钩子函数也没有组件实例，只有 beforeCreate/created 钩子与 context 对象。 asyncData() 传递服务器数据至客户端在 asyncData() 中可以处理请求得来的数据，通过 return 将处理后的数据返回给当前 vue 组件的 data 。再次强调这里不能使用 this ，因为没有组件实例，asyncData() 默认的参数是 ctx 即 content 对象。 对于打开网页要立即显示的内容，如首页中的 geo 组件（显示当前位置）来说有俩种方式实现，如下： ssr nuxtServerInit 方法 middleware 属性 vue 组件 mounted 函数发送请求 no-ssr 即 mounted 函数方式实现相信大家都很熟悉。主要来说说 ssr 对应的俩种实现方式。 nuxtServerInit() 前面也说过，搭配 vuex 使用，所以顾名思义，在 nuxtServerInit 函数中准备好首页 geo 组件需要的数据存入 vuex，这样 vuex 实例化后的 store 会贯穿整个服务器端与客户端的生命周期。可能有的同学会问这是怎么传过去的？文末会截图说明。所以在首页返回客户端时数据存在 store 实例中可直接获取即可。获取方式如下： 服务器端： 12ctx.store.state.xxx.xxx.xxx// eg: ctx.store.state.home.position.city 客户端： 12this.$store.state.xxx.xxx.xxx// eg: this.$store.state.home.position.city middleware 属性是在 vue 组件中直接定义即可，如下： 1234middleware: async (ctx) =&gt; &#123; let &#123;status, data: &#123;province, city&#125;&#125; = await ctx.$axios.get(&apos;/geo/getPosition&apos;) ... &#125; 问题来了，如何将获取的 data 赋值给组件中的 data 呢？上面在 nuxt流程图 部分我们分析过，渲染前的最后一步是 asyncData&amp;fetch ，这里我们还是需要用 asyncData 方法把 data 给组件 return 即可。具体做法见官方给出的 issue &amp; 例子： issue：#1738 nuxt/fn-midd.vue 解答上面遗留的问题，ssr 生成的页面如何把 vuex 实例后的 store 传给客户端？ 其实在服务器返回页面给浏览器时会传一个名为 __NUXT__ 的对象挂载在 window 上，这里面存储了 store 。如下： 如图可以找到 $store.state.home.position.city 这个数据。 参考文章： The Benefits of Server Side Rendering Over Client Side Rendering NUXT-Universal Vue.js Applications","categories":[{"name":"Vue SSR","slug":"Vue-SSR","permalink":"https://i7eo.com/categories/Vue-SSR/"}],"tags":[{"name":"Nuxt.js","slug":"Nuxt-js","permalink":"https://i7eo.com/tags/Nuxt-js/"},{"name":"SSR","slug":"SSR","permalink":"https://i7eo.com/tags/SSR/"}]},{"title":"Javascript面向对象笔记","slug":"Javascript面向对象笔记","date":"2018-03-25T02:29:48.000Z","updated":"2018-12-30T13:44:35.875Z","comments":true,"path":"2018/03/25/Javascript面向对象笔记.html","link":"","permalink":"https://i7eo.com/2018/03/25/Javascript面向对象笔记.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。 Javascript 中创建对象new 关键字做了什么？利用 new &amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步： 声明新的变量 basketball","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。 Javascript 中创建对象new 关键字做了什么？利用 new &amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步： 声明新的变量 basketball new 将新变量的 _proto_ 属性指向了构造函数（Ball）的 prototype 属性，这时内存为 basketball 分配了内存，其成为了对象。basketball._proto_ = ball.prototype 利用 call 函数将新产生的对象 basketball 的 this 指向 ball。即绑定 this。 prototype/_proto_ 是什么？有的书上别别用显示原型/隐示原型来分别代 prototype/_proto_ 还有的用原型对象/对象原型。其实不论哪一种说法，代表的东西都是一样的。这里我们使用第二种说法。俩者区别如下表： 解释 备注 prototype 指向函数的原型对象（包括拥有的变量与方法，constructor ，_proto_） 只有函数拥有此属性 _proto_ 指向构造器的原型对象 不论对象或者函数都有此属性 来看下面代码： 1234567891011121314151617181920212223242526272829303132function Ball(name)&#123; this.name = name;&#125;var basketball = new Ball('basketball');console.log(basketball.__proto__);/* 输出 constructor: ƒ ball(name) arguments: null caller: null length: 1 name: \"ball\" prototype: &#123;constructor: ƒ&#125; __proto__: ƒ ()*/console.log(ball.prototype)/* 输出 constructor: ƒ ball(name) arguments: null caller: null length: 1 name: \"ball\" prototype: &#123;constructor: ƒ&#125; __proto__: ƒ ()*/console.log(basketball.__proto__ === ball.prototype)// true 从结果来看确实跟我们上述的 new 创建对象过程一致。 面向对象 — 继承1、call/apply该方式采取的办法是将父对象的构造函数绑定在子对象上。具体如下： 1234567891011121314function Ball() &#123; this.general = \"球类运动\";&#125;function Basketball(name, space) &#123; Ball.apply(this, arguments); this.name = name; this.space = space;&#125;let bb = new Basketball('耐克7号球', '室内')console.log(bb.general)// 球类运动 2、原型链继承使子类原型对象指向父类的原型对象以实现继承。具体如下： 123456789101112131415161718192021222324function Ball() &#123; this.general = \"球类运动\"; this.ballprint = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();let bb = new Basketball('耐克7号球', '室内');console.log(bb.general) // 1、球类运动console.log(bb.ballprint()) // 2、ballconsole.log(bb.name) // 3、耐克7号球console.log(bb.print()) // 4、basketballconsole.log(Basketball.prototype == Ball.prototype) // 5、trueconsole.log(Basketball.prototype.__proto__ == Ball.prototype) // 6、true 调试语句5更深层次的意思是说:1Basketball.prototype.constuctor = Ball.prototype.constuctor 因为前面说过每个函数特有 prototype 这个原型对象属性，而在这个原型对象中存有 constuctor ，所以要使俩函数的 prototype 相等，那么其中的 constuctor 必定也想等。所以 bb 作为子类才可以访问到 ball 中的属性与方法。语句1&amp;2证明了这一点。 语句6结果符合 new 操作符的操作。 如果子类与父类中的属性、方法同名那么结果怎样呢？结果如下： 12345678910111213141516171819202122function Ball() &#123; this.name = \"球类运动\"; this.print = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();let bb = new Basketball('耐克7号球', '室内');console.log(bb.name) // 1、耐克7号球console.log(bb.print()) // 2、basketballconsole.log(Basketball.prototype == Ball.prototype) // 3、trueconsole.log(Basketball.prototype.__proto__ == Ball.prototype) // 4、true 此时虽然 bb._proto_ = Basketball.prototype = Ball.prototype 但是同名采取的就近访问的原则，所以执行 Basketball 中的语句。而不会通过 _proto_ 原型链去去上级父类寻找变量与方法。 3、改进后的原型继承因为上述2中的方法会修改构造函数，所以我们应该手动置回。具体如下： 123456789101112131415161718function Ball() &#123; this.name = \"球类运动\"; this.print = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();Basketball.prototype.constructor = Basketball;let bb = new Basketball('耐克7号球', '室内'); 这样即可。当然这样的继承方式是多占用了些内存，Basketball.prototype = new Ball(); ，当然还有不占内存的方式，比如利用空对象作为中介的方式。创建了一个临时的对象，理解起来不难。具体请参考： Javascript面向对象编程（二）：构造函数的继承 阮老师这里介绍的空对象方法，没什么问题。但是我觉得没有把临时对象使用完后手动置空的操作，自己加上即可。 4、class/extends 关键字实现继承es6中引入了类的概念，用 class 关键字声明的函数作为对象模版。具体如下： 12345678910111213141516171819202122232425262728293031class Ball&#123; constructor(name) &#123; this.name = name &#125; play() &#123; console.log('Ball is: ', this.name) &#125;&#125;class Basketball extends Ball &#123; constructor(name) &#123; super(name) this.name = name &#125; playb() &#123; console.log('Basketball is: ', this.name) &#125;&#125;let bb = new Basketball('nikeball')bb.play(); // Ball is: nikeballbb.playb(); // Basketball is: nikeballconsole.log(typeof Ball) // 1、functionconsole.log(typeof Basketball) // 2、functionconsole.log(bb.__proto__ == Basketball.prototype) // 3、trueconsole.log(Basketball.prototype)/* 4、constructor: class Basketballplayb: ƒ playb()__proto__: Object*/ 由打印出的结果1&amp;2我们可以看出，class 好像是包在 function 上的语法糖；由3慢慢确定了这一点；由4我们更加确定了这一点，而且结合前面说的改进原型继承的方式，还可以尝试分析 class 继承的关键步骤： 123456Basketball.prototype = new Ball()Basketball.prototype.constructor = Basketball// playb() &#123;...&#125; 相当于:Basketball.prototype.playb = function() &#123;...&#125; 使用 class 时一定要注意在使用 this 或者子类构造函数返回前，一定要在子类中使用 super 关键字调用父类的构造函数。说白了就是在子类中一定要使用 super 。 参考资料： JS当中的new关键字都干了些什么？ 作用域链与原型链 详解prototype与_proto_","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"prototype/_proto_","slug":"prototype-proto","permalink":"https://i7eo.com/tags/prototype-proto/"},{"name":"面向对象","slug":"面向对象","permalink":"https://i7eo.com/tags/面向对象/"},{"name":"继承","slug":"继承","permalink":"https://i7eo.com/tags/继承/"}]},{"title":"Mac下利用Alfred与七牛搭建markdown图床","slug":"Mac下利用Alfred与七牛搭建markdown图床","date":"2017-11-03T12:57:58.000Z","updated":"2018-12-30T13:42:42.810Z","comments":true,"path":"2017/11/03/Mac下利用Alfred与七牛搭建markdown图床.html","link":"","permalink":"https://i7eo.com/2017/11/03/Mac下利用Alfred与七牛搭建markdown图床.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后）","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后） 七牛账号&amp;七牛自动化工具qshell 截图工具（这个也可以没有，可以利用电脑自带的截图功能，只要保证截图动作后的结果处于剪切板中即可） 第一部分：（七牛操作）第一步：注册成功登陆后，单击 管理控制台 -&gt; 对象存储 -&gt; 内容管理 找到外链默认域名，复制并保存。 第二步：返回首页，单击 服务与支持 -&gt; 开发者中心 -&gt; sdk与工具 -&gt; 开发者工具 -&gt; qshell 进入后按照提示下载并安装。 第三步：创建账户时，除了ak&amp;sk 现在还需要输入七牛账户名；配置upload.conf文件时需要注意如果本地新增文件七牛默认不会自动检查，你需要设置 rescan_local: true ;如果你在七牛空间（web页）中手动删除某个文件，再次上传该文件的时候七牛默认该文件已经存在空间中，不会再上传该文件，你需要配置 check_exists: true 。 第二部分：（alfred workflow操作）第一步： 点击 + ，创建blank workflow即可，注意bundle id必填一个唯一值，能够在alfred中标示你这个workflow即可，其余选项正常填写，category默认选项即可。 第二步： 创建热键hotkey，其余默认选项不变，完成后save。 创建热键触发后需要执行的脚本文件，当然run script创建的脚本是后台运行不需要先调出terminal（控制台），如果需要调出terminal（控制台），选择terminal command。根据脚本语言对应选择language，这里提供一个as版本代码：12345678910111213141516171819202122232425262728293031323334353637383940414243property fileTypes : &#123;¬ &#123;«class PNGf», \".png\"&#125;, ¬ &#123;JPEG picture, \".jpg\"&#125;&#125;on getType() --判断剪贴板中的数据类型，暂时只支持png和jpg，优先用png repeat with aType in fileTypes repeat with theInfo in (clipboard info) if (first item of theInfo) is equal to (first item of aType) then return aType end repeat end repeat return missing valueend getTypeset theType to getType()if theType is not missing value then set filePath to \"/Users/xxx/Documents/screenCaptures/\" --这里换成你自己放置图片的路径 set fileName to do shell script \"date \\\"+%Y%m%d%H%M%S\\\" | md5\" --用当前时间的md5值做文件名 set prefix to \"i7eo_\" -- 改成自己的前缀 if fileName does not end with (second item of theType) then set fileName to (fileName &amp; second item of theType as text) set markdownUrl to \"![截图](http://xxx.com/i7eo_\" &amp; fileName &amp; \")\" --这里如果没有用到图床，就把前面前缀去掉，用到的话换成你自己图床的url set filePath to filePath &amp; prefix &amp; fileName try set imageFile to (open for access filePath with write permission) set eof imageFile to 0 write (the clipboard as (first item of theType)) to imageFile -- as whatever close access imageFile set the clipboard to markdownUrl try tell application \"System Events\" keystroke \"v\" using command down end tell end try on error try close access imageFile end try return \"\" end tryelse return \"\"end if 把 http://xxx.com/改为之前从七牛默认外链处复制出来的地址。 第三步：再次创建一个blank workflow，热键自己设置；再次创建一个as脚本，具体代码如下：1do shell script \"/usr/local/bin/qshell qupload ~/.qshell/upload.conf\" 把qupload前的路径换成自己存放七牛qshell文件的位置。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法适合写博客时，把该篇博客需要的图片都存放在同一个文件下，写完后一次性上传至七牛空间。然后在把博客推至gitpage即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想每次插入一张图片就上传，可以使用插件 Mac 版本的 Markdown 一键贴图工具 alfred3 Powerpack","categories":[{"name":"自动化","slug":"自动化","permalink":"https://i7eo.com/categories/自动化/"}],"tags":[{"name":"Alfred3 workflow","slug":"Alfred3-workflow","permalink":"https://i7eo.com/tags/Alfred3-workflow/"},{"name":"图床","slug":"图床","permalink":"https://i7eo.com/tags/图床/"},{"name":"qshell","slug":"qshell","permalink":"https://i7eo.com/tags/qshell/"}]},{"title":"为git page开通https踩坑实录","slug":"为gitPages开通https踩坑实录","date":"2017-10-01T08:37:27.000Z","updated":"2018-12-28T18:56:19.680Z","comments":true,"path":"2017/10/01/为gitPages开通https踩坑实录.html","link":"","permalink":"https://i7eo.com/2017/10/01/为gitPages开通https踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合自己的代码发现引用的图片全是http协议下的，而且在input（即使type≠keyword）输入内容时感叹号变成了红字叉。我所用的是阿里的域名所以去网站查询https的信息，发现有免费的赛门铁克（Symantec）证书试用。果断申请后，发现： gitPages注意事项 git page自带https，在对应rep的设置中，点击 Enforce HTTPS 即可。 git page绑定自定义域名后无法添加ssl证书。这个时候有点懵了，不过检索多次相关关键字后，发现了cloudflare这个好东西。大概了解了下后就确定用它了，好处如下： 安利cloudflare的原因 有免费套 cloudflare的dns服务器风评还是不错的-cloudflare提供 Universal SSL 服务，简单来说就是让任意http站点支持https。 （具体原理指的是，用cloudflare的dns服务器，当你访问网页时，网页 -&gt; cloudflare 这个过程是加密的，而 cloudflare -&gt; git page这个过程是非加密（http）） 具体可参考官方文档： how Cloudflare’s servers connect to your origin for HTTPS requests cloudflare配置的具体步骤第一步：设置dns把自己对应的dns服务器改为cloudflare的，下面以阿里来举例。阿里云 -&gt; 域名 -&gt; 管理 -&gt; 修改dns，出现一下界面： 这是我已经修改后的，单击右边的修改dns服务器即可，把cloudflare给出的俩个dns地址换上来就好。cloudflare给出的dns地址位于：cloudflare -&gt; dns -&gt; Cloudflare Nameservers。 如何判断更换dns成功？回到cloudflare后，单击overview，如果成功会出现： 第二步：设置dns信息cloudflare -&gt; dns -&gt; DNS Records 如果这里没设置时有记录先删除，新增一条记录: 第三步：设置ssl&amp;强制跳转cloudflare -&gt; crypto -&gt; SSL 勾选flexible cloudflare -&gt; crypto -&gt; Always Use HTTPS 勾选on 第四步：坐等&amp;排错大概10mins - 30mins左右就会生效，可以在等待的时候使用ping命令来ping个人的域名查看ip。 如果你的博客出现以下情况： 检查gitpage的设置，取消掉勾选的Enforce HTTPS选项，这个设置是有缓存的 可以切换source或者theme chooser这样可以清理掉缓存的Enforce HTTPS选项信息。 参考文章： 使用Cloudflare为自定义域名的GithubPages实现HTTPS化 解决Cloudflare产生的“ERR_TOO_MANY_REDIRECTS”错误","categories":[{"name":"运维","slug":"运维","permalink":"https://i7eo.com/categories/运维/"}],"tags":[{"name":"cloudflare","slug":"cloudflare","permalink":"https://i7eo.com/tags/cloudflare/"},{"name":"https","slug":"https","permalink":"https://i7eo.com/tags/https/"}]}]}