{"meta":{"title":"Solitude is freedom","subtitle":"Articles on front-end development by George Tan","description":"A man who dreams of being a full stack engineer","author":"George Tan","url":"https://i7eo.com"},"pages":[{"title":"关于我","date":"2017-09-28T00:09:53.000Z","updated":"2019-01-03T09:32:32.507Z","comments":true,"path":"about/index.html","permalink":"https://i7eo.com/about/index.html","excerpt":"","text":"一个梦想成为全栈的前端工程师。喜欢： Javascript NodeJs Java 常用技术： Vue&amp;Vuex Nuxt JQuery Mongodb/redis koa&amp;express 联系我： GitHub: GeorgeTan Gmail: georgetan704t@gmail.com"}],"posts":[{"title":"Vue 的响应式/模版解析/渲染","slug":"vuesc","date":"2019-01-03T15:04:45.000Z","updated":"2019-01-04T06:47:00.200Z","comments":true,"path":"2019/01/03/vuesc.html","link":"","permalink":"https://i7eo.com/2019/01/03/vuesc.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于使用 vue 的同学来说，响应式、模版解析/渲染应该都很熟悉，vue 开发离不开这些特性。用了 vue 挺长时间了，写写总结。 响应式创建一个普通的对象： 12345let t = &#123; name: 't1' age: 19&#125;console.log(t.age) // 19 那么如何监听age属性的访问与设置呢？ 在es5中加入了一个api叫 Object.defineProperty,该api允许 …","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于使用 vue 的同学来说，响应式、模版解析/渲染应该都很熟悉，vue 开发离不开这些特性。用了 vue 挺长时间了，写写总结。 响应式创建一个普通的对象： 12345let t = &#123; name: 't1' age: 19&#125;console.log(t.age) // 19 那么如何监听age属性的访问与设置呢？ 在es5中加入了一个api叫 Object.defineProperty,该api允许 … 创建对象的属性自定义 get/set 函数。修改上面代码： 1234567891011121314151617let t = &#123;&#125;let name = 't1'Object.defineProperty(obj, 'name', &#123; get() &#123; console.log('get') return name &#125;, set(newVal) &#123; console.log('set') name = newVal &#125;&#125;)console.log(obj.name)// get// t1obj.name = 'george'// set 在vue中我们可以模拟一下，大概过程如下： 123456789101112131415161718let vm = &#123;&#125;let data = &#123; name: 'lyn', age: 20&#125;for(let v in data) &#123; (function(v) &#123; Object.defineProperty(vm, v, &#123; get() &#123; return data[v] &#125;, set(newVal) &#123; data[v] = newVal &#125; &#125;) &#125;)(v)&#125; 为什么要将data的值全部代理至vm对象上？vue中就是这么写的 …，而且模版解析的时候会用到。 模板解析我们经常在vue中使用vue模板，比如： 1234567&lt;div id=\"app\"&gt; &lt;input v-model=\"title\"&gt; &lt;button @click=\"add\"&gt;&lt;/button&gt;&lt;/div&gt;&lt;ul&gt; &lt;li v-for=\"v in list\"&gt;&#123;&#123; v &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 模板的本质是字符串，其特点有： 包含 if/for 等逻辑指令 动态的（动态生成 dom ） 最终转换为 html 综上，要将模板转换为 html ，只能使用 js 来操作。在 html/css/js 中，只有js能处理逻辑和渲染页面。 在当前文件引入vue文件，打开控制台，在源码中搜索code.render 在 return 前打印 code.render，观察模板被解析后生成的render函数，render函数最终返回vnode。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758with(this)&#123; // this 就是 vm return _c( 'div', &#123; attrs:&#123;\"id\":\"app\"&#125; &#125;, [_c( 'div', [ _c( 'input', &#123; directives:[ &#123; name:\"model\", rawName:\"v-model\", value:(title), // vm.title 在这里就将model中的的值通过vm与view中的input数据联系了起来 expression:\"title\" &#125; ], domProps:&#123; \"value\":(title) &#125;, on:&#123; \"input\":function($event)&#123; // 在这里可以发现v-model 其实在vue模版内被封装了进去 if($event.target.composing)return; title=$event.target.value 在这里就将view中的input中的值通过vm与model中的数据联系了起来与上面相对应实现双向绑定 &#125; &#125; &#125; ), _v(\" \"), // 因为html中俩个标签间我们换行所以这里是空 _c( 'button', &#123; on:&#123; \"click\":add // 相当于 vm.add这里直接调用methods中定义的add函数 &#125; &#125;, [_v(\"submit\")] ) ]), _v(\" \"), _c('div', [ _c( 'ul', //v-for这里使用内部定义的 _l函数来处理 _l((list),function(item)&#123;return _c('li',[_v(_s(item))])&#125;) ) ] )] )&#125; _c 创建标签，_v创建文本元素，_s toString()，这个_c 和 snabbdom 中的 h 函数很像，那vue中更新的操作会不会和 snabbdom 中的逻辑页相似呢？vue 中的更新函数： 1234567891011121314vm._update(vnode) &#123; const prevNode = vm._vnode vm._node = vnode if(!prevNode) &#123; vm.$el = vm.__patch___(vm.$el, vnode) &#125;else&#123; vm.$el = vm.__patch__(prevNode, vnode) &#125;&#125;function updateComponent() &#123; vm._update(vm._render()) // vm._render 即生成上面包含 _c/_v/_s的模板解析函数&#125; 也就是说每次改变data，通过Object.defineProperty监听修改操作，一旦修改就调用 updateComponent 函数，利用vm._render方法生成新的 vnode。通过 vm._patch_ 将vnode转化为html并更新至原生dom中。 总结 解析模板生成render函数 响应式开始监听 首次渲染，显示页面且绑定依赖 data属性变化，再次渲染","categories":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://i7eo.com/categories/Vuejs/"}],"tags":[{"name":"模版解析","slug":"模版解析","permalink":"https://i7eo.com/tags/模版解析/"},{"name":"render 函数","slug":"render-函数","permalink":"https://i7eo.com/tags/render-函数/"}]},{"title":"Nuxt.js踩坑实录","slug":"Nuxt.js踩坑实录","date":"2018-05-01T15:22:36.000Z","updated":"2018-12-28T18:53:22.940Z","comments":true,"path":"2018/05/01/Nuxt.js踩坑实录.html","link":"","permalink":"https://i7eo.com/2018/05/01/Nuxt.js踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ?","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一阵子接触一个新项目，用了vue中的ssr解决方案 — Nuxt.js。也算是小有感受，记录一些经验留后备用。 CSR &amp; SSR什么是 CSR ?CSR =&gt; client-side-reder，即客户端渲染。具体过程如下： 用户请求页面，返回页面。此时页面只是模版页面 浏览器解析页面代码，读到js代码时，会根据我们所写的接口去请求数据 得到返回数据后使用模版（vue/react/ng/art-template）进行渲染什么是 SSR ? SSR =&gt; server-side-render，即服务器端渲染。具体过程如下： 用户请求页面 后端取到准备好的数据，渲染到我们自己写的服务器模版（next/nuxt/ejs）中，准备好html结构与相应数据后返回给浏览器 CSR &amp; SSR 优缺点对比 优点 缺点 CSR 减轻服务器压力，前后端分离 对seo不友（不利于爬虫爬取），首页渲染存在白屏问题 SSR 对seo友好，首页渲染完美无白屏问题 对服务器性能有一定要求，不利于前后端分离 其实在真正开发中通常是 csr 与 ssr 相结合使用，前端使用cdn缓存，后端使用nginx缓存。这样是最优的解决方案。上两张图大家对比理解： Nuxt.js什么是 Nuxt ?Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。 Nuxt 流程 nuxtServerInit请求先到达 nuxtServerInit 方法，图中也表明了适用场景是对 store 的 action 操作即（vuex）： middleware下来请求到达 middleware 属性，虽然这里叫做中间件属性，但还是做着同中间件一样的事。官方给出的定义：1中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。 也就是说，定义 middleware 属性后你可以在 匹配布局（layout 组件）前执行某种操作，也可以在解析完 layout 之后，解析 page 组件前 执行某种操作。 validate下来请求到达 validate 方法，在这里可以对 page 组件或者 page 中的子组件 component 进行动态路由对应的页面组件中动态路由参数的有效性。 asyncData &amp; fetch接下来达到 asyncData &amp; fetch 方法，asyncData() 适用于在渲染组件前获取异步数据，fetch() 适用于在渲染页面前填充 vuex 中维护的数据。 render最后进行渲染。将渲染后的页面返回给浏览器，用户在页面进行操作，如果再次请求新的页面，此时只会回到生命周期中的 middlerware 中，而非 nuxtServerInit ，所以如果不同页面间需要操作相同的数据请用 vuex 来维护。 Nuxt 笔记Nuxt 项目结构 通过 12npm install npxnpx create-nuxt-app xxx 生成如上结构，布局组件（layout）用来存放页面整体布局，在 layout 中我们可以放入一些每个页面都会以用到的组件，比如 header &amp; footer。当然如果你不想使用已生成的 layout 组件，你可以重新创建一个，比如 blank.vue 一般不需要引入 header&amp;footer 的页面可以使用 blank.vue 这个 layout 组件。代码如下： 1layout: &apos;blank&apos; 在 nuxt 中引入 layout 不用写路径，nuxt 已经帮我们做了映射，同理在 nuxt 中不用写路由，pages 中文件名映射为了路由。 nuxt 中的钩子函数nuxt 中提供很多钩子函数，参考文档：nuxt hooks 这里我们主要来看 vue 组件生命周期中钩子函数，服务器端的 vue 组件也是有生命周期的，只不过只有 beforeCreate 和 created 俩个。也就是说，我们把服务器端创建的 .vue 文件全部理解成组件，在服务器端环境（node）通过 beforeCreate 和 created 这俩个生命周期节点后服务器端 vue 组件生命周期结束。返回页面给浏览器，在客户端环境（v8）中这个 vue 组件实例创建后会在客户端再次拥有生命周期，此时生命周期中有 mounted 等钩子函数。 需要特别注意的是 nuxt 中没有 mounted 钩子函数也没有组件实例，只有 beforeCreate/created 钩子与 context 对象。 asyncData() 传递服务器数据至客户端在 asyncData() 中可以处理请求得来的数据，通过 return 将处理后的数据返回给当前 vue 组件的 data 。再次强调这里不能使用 this ，因为没有组件实例，asyncData() 默认的参数是 ctx 即 content 对象。 对于打开网页要立即显示的内容，如首页中的 geo 组件（显示当前位置）来说有俩种方式实现，如下： ssr nuxtServerInit 方法 middleware 属性 vue 组件 mounted 函数发送请求 no-ssr 即 mounted 函数方式实现相信大家都很熟悉。主要来说说 ssr 对应的俩种实现方式。 nuxtServerInit() 前面也说过，搭配 vuex 使用，所以顾名思义，在 nuxtServerInit 函数中准备好首页 geo 组件需要的数据存入 vuex，这样 vuex 实例化后的 store 会贯穿整个服务器端与客户端的生命周期。可能有的同学会问这是怎么传过去的？文末会截图说明。所以在首页返回客户端时数据存在 store 实例中可直接获取即可。获取方式如下： 服务器端： 12ctx.store.state.xxx.xxx.xxx// eg: ctx.store.state.home.position.city 客户端： 12this.$store.state.xxx.xxx.xxx// eg: this.$store.state.home.position.city middleware 属性是在 vue 组件中直接定义即可，如下： 1234middleware: async (ctx) =&gt; &#123; let &#123;status, data: &#123;province, city&#125;&#125; = await ctx.$axios.get(&apos;/geo/getPosition&apos;) ... &#125; 问题来了，如何将获取的 data 赋值给组件中的 data 呢？上面在 nuxt流程图 部分我们分析过，渲染前的最后一步是 asyncData&amp;fetch ，这里我们还是需要用 asyncData 方法把 data 给组件 return 即可。具体做法见官方给出的 issue &amp; 例子： issue：#1738 nuxt/fn-midd.vue 解答上面遗留的问题，ssr 生成的页面如何把 vuex 实例后的 store 传给客户端？ 其实在服务器返回页面给浏览器时会传一个名为 __NUXT__ 的对象挂载在 window 上，这里面存储了 store 。如下： 如图可以找到 $store.state.home.position.city 这个数据。 参考文章： The Benefits of Server Side Rendering Over Client Side Rendering NUXT-Universal Vue.js Applications","categories":[{"name":"Vue SSR","slug":"Vue-SSR","permalink":"https://i7eo.com/categories/Vue-SSR/"}],"tags":[{"name":"Nuxt.js","slug":"Nuxt-js","permalink":"https://i7eo.com/tags/Nuxt-js/"},{"name":"SSR","slug":"SSR","permalink":"https://i7eo.com/tags/SSR/"}]},{"title":"Javascript面向对象笔记","slug":"Javascript面向对象笔记","date":"2018-03-25T02:29:48.000Z","updated":"2018-12-30T13:44:35.875Z","comments":true,"path":"2018/03/25/Javascript面向对象笔记.html","link":"","permalink":"https://i7eo.com/2018/03/25/Javascript面向对象笔记.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。 Javascript 中创建对象new 关键字做了什么？利用 new &amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步： 声明新的变量 basketball","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到面向对象，大多数人都想到的是高级语言：c++、java，但是我认为对于一名coder来说不论什么语言，一定要有面向对象这种思想（封装、继承、多态），我们只需要用语言这个工具把思想表达出来即可。本文只讨论继承。 Javascript 中创建对象new 关键字做了什么？利用 new &amp; 构造函数 创建新的对象。这个创建新对象的过程分为三步： 声明新的变量 basketball new 将新变量的 _proto_ 属性指向了构造函数（Ball）的 prototype 属性，这时内存为 basketball 分配了内存，其成为了对象。basketball._proto_ = ball.prototype 利用 call 函数将新产生的对象 basketball 的 this 指向 ball。即绑定 this。 prototype/_proto_ 是什么？有的书上别别用显示原型/隐示原型来分别代 prototype/_proto_ 还有的用原型对象/对象原型。其实不论哪一种说法，代表的东西都是一样的。这里我们使用第二种说法。俩者区别如下表： 解释 备注 prototype 指向函数的原型对象（包括拥有的变量与方法，constructor ，_proto_） 只有函数拥有此属性 _proto_ 指向构造器的原型对象 不论对象或者函数都有此属性 来看下面代码： 1234567891011121314151617181920212223242526272829303132function Ball(name)&#123; this.name = name;&#125;var basketball = new Ball('basketball');console.log(basketball.__proto__);/* 输出 constructor: ƒ ball(name) arguments: null caller: null length: 1 name: \"ball\" prototype: &#123;constructor: ƒ&#125; __proto__: ƒ ()*/console.log(ball.prototype)/* 输出 constructor: ƒ ball(name) arguments: null caller: null length: 1 name: \"ball\" prototype: &#123;constructor: ƒ&#125; __proto__: ƒ ()*/console.log(basketball.__proto__ === ball.prototype)// true 从结果来看确实跟我们上述的 new 创建对象过程一致。 面向对象 — 继承1、call/apply该方式采取的办法是将父对象的构造函数绑定在子对象上。具体如下： 1234567891011121314function Ball() &#123; this.general = \"球类运动\";&#125;function Basketball(name, space) &#123; Ball.apply(this, arguments); this.name = name; this.space = space;&#125;let bb = new Basketball('耐克7号球', '室内')console.log(bb.general)// 球类运动 2、原型链继承使子类原型对象指向父类的原型对象以实现继承。具体如下： 123456789101112131415161718192021222324function Ball() &#123; this.general = \"球类运动\"; this.ballprint = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();let bb = new Basketball('耐克7号球', '室内');console.log(bb.general) // 1、球类运动console.log(bb.ballprint()) // 2、ballconsole.log(bb.name) // 3、耐克7号球console.log(bb.print()) // 4、basketballconsole.log(Basketball.prototype == Ball.prototype) // 5、trueconsole.log(Basketball.prototype.__proto__ == Ball.prototype) // 6、true 调试语句5更深层次的意思是说:1Basketball.prototype.constuctor = Ball.prototype.constuctor 因为前面说过每个函数特有 prototype 这个原型对象属性，而在这个原型对象中存有 constuctor ，所以要使俩函数的 prototype 相等，那么其中的 constuctor 必定也想等。所以 bb 作为子类才可以访问到 ball 中的属性与方法。语句1&amp;2证明了这一点。 语句6结果符合 new 操作符的操作。 如果子类与父类中的属性、方法同名那么结果怎样呢？结果如下： 12345678910111213141516171819202122function Ball() &#123; this.name = \"球类运动\"; this.print = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();let bb = new Basketball('耐克7号球', '室内');console.log(bb.name) // 1、耐克7号球console.log(bb.print()) // 2、basketballconsole.log(Basketball.prototype == Ball.prototype) // 3、trueconsole.log(Basketball.prototype.__proto__ == Ball.prototype) // 4、true 此时虽然 bb._proto_ = Basketball.prototype = Ball.prototype 但是同名采取的就近访问的原则，所以执行 Basketball 中的语句。而不会通过 _proto_ 原型链去去上级父类寻找变量与方法。 3、改进后的原型继承因为上述2中的方法会修改构造函数，所以我们应该手动置回。具体如下： 123456789101112131415161718function Ball() &#123; this.name = \"球类运动\"; this.print = function() &#123; console.log('ball'); &#125;;&#125;function Basketball(name, space) &#123; this.name = name; this.space = space; this.print = function() &#123; console.log('basketball'); &#125;;&#125;Basketball.prototype = new Ball();Basketball.prototype.constructor = Basketball;let bb = new Basketball('耐克7号球', '室内'); 这样即可。当然这样的继承方式是多占用了些内存，Basketball.prototype = new Ball(); ，当然还有不占内存的方式，比如利用空对象作为中介的方式。创建了一个临时的对象，理解起来不难。具体请参考： Javascript面向对象编程（二）：构造函数的继承 阮老师这里介绍的空对象方法，没什么问题。但是我觉得没有把临时对象使用完后手动置空的操作，自己加上即可。 4、class/extends 关键字实现继承es6中引入了类的概念，用 class 关键字声明的函数作为对象模版。具体如下： 12345678910111213141516171819202122232425262728293031class Ball&#123; constructor(name) &#123; this.name = name &#125; play() &#123; console.log('Ball is: ', this.name) &#125;&#125;class Basketball extends Ball &#123; constructor(name) &#123; super(name) this.name = name &#125; playb() &#123; console.log('Basketball is: ', this.name) &#125;&#125;let bb = new Basketball('nikeball')bb.play(); // Ball is: nikeballbb.playb(); // Basketball is: nikeballconsole.log(typeof Ball) // 1、functionconsole.log(typeof Basketball) // 2、functionconsole.log(bb.__proto__ == Basketball.prototype) // 3、trueconsole.log(Basketball.prototype)/* 4、constructor: class Basketballplayb: ƒ playb()__proto__: Object*/ 由打印出的结果1&amp;2我们可以看出，class 好像是包在 function 上的语法糖；由3慢慢确定了这一点；由4我们更加确定了这一点，而且结合前面说的改进原型继承的方式，还可以尝试分析 class 继承的关键步骤： 123456Basketball.prototype = new Ball()Basketball.prototype.constructor = Basketball// playb() &#123;...&#125; 相当于:Basketball.prototype.playb = function() &#123;...&#125; 使用 class 时一定要注意在使用 this 或者子类构造函数返回前，一定要在子类中使用 super 关键字调用父类的构造函数。说白了就是在子类中一定要使用 super 。 参考资料： JS当中的new关键字都干了些什么？ 作用域链与原型链 详解prototype与_proto_","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"prototype/_proto_","slug":"prototype-proto","permalink":"https://i7eo.com/tags/prototype-proto/"},{"name":"面向对象","slug":"面向对象","permalink":"https://i7eo.com/tags/面向对象/"},{"name":"继承","slug":"继承","permalink":"https://i7eo.com/tags/继承/"}]},{"title":"Event Loop总结","slug":"Event-Loop总结","date":"2018-03-08T14:33:12.000Z","updated":"2019-01-02T05:30:00.318Z","comments":true,"path":"2018/03/08/Event-Loop总结.html","link":"","permalink":"https://i7eo.com/2018/03/08/Event-Loop总结.html","excerpt":"之前也有 event loop 的概念，但一直都是琐碎的。直到阅读以下三篇文章后，琐碎的点串在了一起。 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 这一次，彻底弄懂 JavaScript 执行机制 Event Loop的规范和实现 为了印象深刻，还是决定自己写一写。总结如下： 1、进程与线程的区别1、什么是进程？在计算机操作系统中，只有进程才能在系统中运行。所以要使程序运行就必须为其创建进程。当我们打开浏览器时就已经创建了进程。创建进程之后，系统会为其分配资源(内存等)供其使用。 进程是程序（指令和数据）的真正运行实例。若干进程有可能 …","text":"之前也有 event loop 的概念，但一直都是琐碎的。直到阅读以下三篇文章后，琐碎的点串在了一起。 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 这一次，彻底弄懂 JavaScript 执行机制 Event Loop的规范和实现 为了印象深刻，还是决定自己写一写。总结如下： 1、进程与线程的区别1、什么是进程？在计算机操作系统中，只有进程才能在系统中运行。所以要使程序运行就必须为其创建进程。当我们打开浏览器时就已经创建了进程。创建进程之后，系统会为其分配资源(内存等)供其使用。 进程是程序（指令和数据）的真正运行实例。若干进程有可能 … 与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。 2、什么是线程？线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 总的来说进程是资源分配的最小单位，线程是计算机系统调度和分派的基本单位。线程基本上不拥有资源（也有一点必不可少的资源）它只专注于调度和分派，提高系统并发程度，但是它可以访问其隶属进程的资源。 2、浏览器是多进程上图来阐述，进入浏览器（chrome等）打开多个标签页，然后打开浏览器的 task manager。如下图： 从图上来看，我们首先可以确定的是我打开的4个页面都是进程，因为它们有不同的 process id（进程标识符），这个是存在 PCB 中的，系统分配且唯一的数字标识符。PCB 是进程控制块，具体可搜索计算机操作系统-进程。 浏览器的主要进程有四个，分别为：主进程、GPU进程、浏览器渲染（render）进程（每个标签页都会一个渲染进程）、第三方插件进程。 主要来说说这四个进程的职责： 1. 主进程： 用户的前进、后退操作 每个标签页的创建与销毁 将渲染进程执行后生成的位图（bitmap）绘制在对应标签页上，呈现给用户 书签、下载等功能的管理 2. 浏览器渲染进程 页面渲染 脚本执行（事件、task） 3. GPU进程：用于3D绘制等4. 第三方插件进程：使用插件时创建主要来说下浏览器渲染进程，这个进程是当前标签的控制者。js 代码的执行、事件的触发、页面的展示等都由它负责。那么这一个进程可以同时干这么多事情吗？它一个当然是可以的，但是如果一个人来做就会浪费资源而且一旦执行脚本文件后会不断阻塞页面执行。至此，引入了线程来解决这个问题。 3、Javascript 的单线程在渲染进程中划分了很多个线程，这里介绍一些常驻线程： 1. JS 线程（引擎线程，即常说的那个js单线程） 运行环境（v8），负责处理 js 脚本 每个标签页只有一个 js 线程在执行代码 js 线程与 Gui 渲染线程互斥，js 执行时间过长会导致页面渲染的阻塞（互斥原因下面阐述 2. GUI 渲染线程 负责渲染页面（构建dom 树 &amp; cssparser 树 &amp; renderobject 树） 当页面出现重绘或回流（repaint/reflow）时，会调用该线程 与 js 线程互斥 3. 事件触发线程：遵循先进先出的原则在异步队列中等待 js 线程处理。（异步队列下面会解释）4. 定时器触发线程 定时器并不是在某段时间后执行，而是在某时间后被添加至异步队列，等 js 线程空闲后执行 W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms 5. http 请求线程：请求成功后会把回调放入异步队列中。6. 备注：上述执行环境是在浏览器中，如果执行环境换为 node 的话，还有 I/O 线程与 setImmediate3、为什么说 JS 线程与 GUI 渲染线程互斥（js 代码会阻塞渲染）？GUI 渲染线程第一个构建的是 dom 树，js 代码也有可能会修改 dom 结构，一旦修改就会引起 重绘或回流，这就会导致 GUI 线程的再次从头开始。为了避免这样的事情发生所以采用了这种互斥的策略。俩者并不能在同一时间进行。 4、异步的实现方案 - event loop针对于 js 引擎单线程这种情况，为了不让程序（被 http 请求、定时器等）阻塞，所以有了异步的概念。但是在现代 web 程序开发中，代码量越来越大。为了能让越来越多的定时器、事件、请求有序且规范的执行，event loop 方案出现了。 123456789101112131415console.log('1');setTimeout(function() &#123; console.log('2');&#125;, 0);console.log('3');Promise.resolve().then(function() &#123; console.log('4');&#125;).then(function() &#123; console.log('5');&#125;);console.log('6'); 上述代码的执行结果是：1 3 6 4 5 2 首先介绍 task &amp; microtask： task 主要包括：setTimeout、setInterval、setImmediate、I/O、UI交互事件 microtask 主要包括：Promise、process.nextTick、MutationObserver（在node中 process.nextTick 的优先级高于 promise） task &amp; microtask 在当前标签页中拥有俩个队列来分别存储 task &amp; microtask除了 js &amp; gui 线程，其他每个线程执行时都会按照 task都有一个异步队列来控制顺序。如下图 Event Loop 过程如下： 整个script代码作为 task 执行时先判断是同步任务还是异步任务 同步任务依次进入 js 线程，依次执行 异步任务先在 table 中注册，然后当任务完成时按照 task/microtask 区分开来，依次进入不同的异步队列 js 线程执行完毕后（执行栈为空）先读取 microtask 的异步队列，全部执行完毕（队列为空后），再去读取 task 的异步队列，task 异步队列中的任务若包含 microtask 则再次去读取 microtask 异步队列。 上述过程不断重复，直至 task 异步队列为空。整个过程即为 Event Loop。 还是直接来看代码： 123456789101112131415161718192021222324252627console.log('1');setTimeout(function() &#123; console.log('2'); new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 详细过程请参考： Event Loop的规范和实现 输出：1 7 8 2 4 5 9 11 12 那如果执行环境切换为 node，node 的 Event loop的实现与浏览器稍有差异。具体如下： 需要注意的是： expired timers and intervals queue 这个异步队列专门来存储所有的 setTimeout/setInterval immediates queue 这个异步队列专门来存储所有的 setImmediate next tick queue 专门来存储所有的 process.nextTick node 清空 queue 时会执行所有 task（不论时 task 还是 microtask） 那么以下代码的结果呢？ 1234567891011121314151617181920212223242526272829303132333435363738console.log(1)setTimeout(() =&gt; &#123; console.log(2) new Promise(resolve =&gt; &#123; console.log(4) resolve() &#125;).then(() =&gt; &#123; console.log(5) &#125;) process.nextTick(() =&gt; &#123; console.log(3) &#125;)&#125;)new Promise(resolve =&gt; &#123; console.log(7) resolve()&#125;).then(() =&gt; &#123; console.log(8)&#125;)process.nextTick(() =&gt; &#123; console.log(6)&#125;)setTimeout(() =&gt; &#123; console.log(9) process.nextTick(() =&gt; &#123; console.log(10) &#125;) new Promise(resolve =&gt; &#123; console.log(11) resolve() &#125;).then(() =&gt; &#123; console.log(12) &#125;)&#125;) js 执行栈为空，microtask queue 为空时，去检查 task queue，发现俩个 settimeout 这时依次执行。这里与浏览器环境不同，浏览器环境是从 task queue 读出一个 task 先执行，执行完后去检查 microtask queue，而 node 中是一次性执行完 task queue，再去检查 micrtask queue（比如 process.nextTick、promise 等） 输出：1 7 6 8 2 4 9 11 3 10 5 12 分析过程请参考： Event Loop的规范和实现 5.总结 js 是一门单线程语言 event loop 是 js 的执行机制 参考资料： Tasks, microtasks, queues and schedules What you should know to really understand the Node.js Event Loop Timers, Immediates and Process.nextTick","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://i7eo.com/tags/EventLoop/"}]},{"title":"虚拟 Dom 到底是什么？","slug":"vdom","date":"2018-01-03T07:22:47.000Z","updated":"2019-01-04T02:17:45.773Z","comments":true,"path":"2018/01/03/vdom.html","link":"","permalink":"https://i7eo.com/2018/01/03/vdom.html","excerpt":"本文为译文，原文地址： Understanding the Virtual DOM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最近在写一些如何正确区分 dom 与 shadow dom 的文章。总的来说，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。shadow dom 可以被认为是轻量级版本的 dom。它同样是以原生对象为基础的 html document，但是它并不是完整的。可能有些难懂，换一种说法来看，shadow dom 允许我们去将我们的 dom 划分的更小，更轻，可以跨文档使用。（这里作者想表达的意思是我们可以根据需要截取部分 dom 生成 vdom，而不用每次从 html 标签开始写 vdom 直到 html 标签闭合） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个你可能遇到过的相似说法称 “shadow dom” 为 “virtual DOM”。尽管 …","text":"本文为译文，原文地址： Understanding the Virtual DOM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最近在写一些如何正确区分 dom 与 shadow dom 的文章。总的来说，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。shadow dom 可以被认为是轻量级版本的 dom。它同样是以原生对象为基础的 html document，但是它并不是完整的。可能有些难懂，换一种说法来看，shadow dom 允许我们去将我们的 dom 划分的更小，更轻，可以跨文档使用。（这里作者想表达的意思是我们可以根据需要截取部分 dom 生成 vdom，而不用每次从 html 标签开始写 vdom 直到 html 标签闭合） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个你可能遇到过的相似说法称 “shadow dom” 为 “virtual DOM”。尽管 … 这个说法已经存在了很多年，但是它真正的流行是在 react 使用它之后。在这篇文章中我将尽力阐述什么是虚拟 dom ，它与原生 dom 又什么不同以及如何使用它。 我们为什么需要虚拟 dom ？想要了解虚拟dom为什么会出现，让我们先回顾以下原生dom。正如我所提到的，dom 是HTML文档的基于对象的表示，以及操作该对象的接口。举个例子看看： 123456789&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"list__item\"&gt;List item&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 可以用如下 dom 树来表示： 让我们来进行以下操作： 修改第一个 li 的内容为 list item one 加上一个 li 要完成上述操作需要创建新节点，添加新属性与内容，最终完成更新： 12345678const listItemOne = document.getElementsByClassName(\"list__item\")[0];listItemOne.textContent = \"List item one\";const list = document.getElementsByClassName(\"list\")[0];const listItemTwo = document.createElement(\"li\");listItemTwo.classList.add(\"list__item\");listItemTwo.textContent = \"List item two\";list.appendChild(listItemTwo); Dom 并不是为此而生的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当1998年发布DOM的第一个规范时，我们以非常不同的方式构建和管理web页面。很少像今天这样依赖DOM api来创建和更新页面内容。 像 document.getElementsByClassName() 这个方法小规模使用没有问题，但是如果在同一页面间隔很短的情况下去更新多个元素，就会使对于 dom 的查询与更新操作变得很昂贵。此外，更新文档中较大一部分比更新特定元素的开销会小一些。回到我们列表例子中，从某种程度上来说用新元素替换整个无序列表比修改某个特定元素要简单一些。代码如下： 12345const list = document.getElementsByClassName(\"list\")[0];list.innerHTML = `&lt;li class=\"list__item\"&gt;List item one&lt;/li&gt;&lt;li class=\"list__item\"&gt;List item two&lt;/li&gt;`; 在这俩个例子中，性能差异并不大。但是随着页面数量的增加，选择、更新我们需要的代码会显得尤为重要。 虚拟 Dom 因此而出现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟 Dom 的出现是为了用更加高效的方式来处理频繁更新 dom 所产生的问题。与 dom 和 shadow dom 不同的是，虚拟 dom 不是一种正式的规范，它更像一种与 dom 交互的新方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟 dom 可以被认为是原生 dom 的一个复制品。在这个复制品上我们可以不通过 dom api 就能频繁更新数据。一旦对虚拟DOM进行了所有更新，我们就可以查看需要对原始DOM进行哪些特定更改，并且使这些改变更加具体与优化。 虚拟 Dom 张什么样呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一听到虚拟，可能会觉得有些神秘感。其实虚拟 dom 就是 js 对象。让我们再来回顾先前创建的 dom 树： 这个树可以表示为如下 js 对象： 12345678910111213141516171819202122const vdom = &#123; tagName: \"html\", children: [ &#123; tagName: \"head\" &#125;, &#123; tagName: \"body\", children: [ &#123; tagName: \"ul\", attributes: &#123; \"class\": \"list\" &#125;, children: [ &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item\" &#125; // end li ] &#125; // end ul ] &#125; // end body ]&#125; // end html 我们完全可以把这个 js 对象当作虚拟 dom 。我们可以根据需要自由的频繁操作它而不改变原生 dom。 相比于使用整个对象，我们通常的做法是使用部分虚拟 dom。举个例子，我们要操作一个 list 组件，这个组件与我们的无序列表元素相关联。具体如下： 1234567891011const list = &#123; tagName: \"ul\", attributes: &#123; \"class\": \"list\" &#125;, children: [ &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item\" &#125; ]&#125;; 虚拟 Dom 如何使用？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们见识过了虚拟dom的样子，那么它是如何处理dom操作的性能问题？ 正如我所提到的，虚拟 dom 可以专门用来对你需要改变的元素进行操作。（不影响没有改变的元素）让我们重回无序列表的例子。 第一件事我们应该复制dom来产生虚拟dom，然后对需要改变的元素在虚拟dom中进行改变操作。如下： 12345678910111213141516const copy = &#123; tagName: \"ul\", attributes: &#123; \"class\": \"list\" &#125;, children: [ &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item one\" &#125;, &#123; tagName: \"li\", attributes: &#123; \"class\": \"list__item\" &#125;, textContent: \"List item two\" &#125; ]&#125;; 这个复制出来的虚拟 dom 用来和原生 dom 进行比较，从而把比较出来的差异用创建的 diff 来保存。 diff 是像这个样子的： 1234567891011const diffs = [ &#123; newNode: &#123; /* new version of list item one */ &#125;, oldNode: &#123; /* original version of list item one */ &#125;, index: /* index of element in parent's list of child nodes */ &#125;, &#123; newNode: &#123; /* list item two */ &#125;, index: &#123; /* */ &#125; &#125;] 这个 diff 提供了一个结构，这个结构可以用来更新原生的 dom。一旦所有的 diff 检测完毕，我们可以对原生 dom 只进行一次更新操作即可。 在下面的例子中，我们对 diff 进行循环，不论是添加新的元素还是更新旧的元素，我们都可以像下面这样做： 123456789101112131415const domElement = document.getElementsByClassName(\"list\")[0];diffs.forEach((diff) =&gt; &#123; const newElement = document.createElement(diff.newNode.tagName); /* Add attributes ... */ if (diff.oldNode) &#123; // If there is an old version, replace it with the new version domElement.replaceChild(diff.newNode, diff.index); &#125; else &#123; // If no old version exists, create a new node domElement.appendChild(diff.newNode); &#125;&#125;) 总结 虚拟dom是让我们与dom交互更加高效的且性能更好一种方法 虚拟dom是一个js对象，它允许我们对js对象进行频繁的修改 所有的修改在虚拟dom中结束后，我们可以一次性对原生dom中需要改变的地方进行更新 附录：snabbdom实现 vdom 的库不多，snabbdom 算是佼佼者。vue 中集成了它的核心代码，在每次修改数据后，都会执行函数进行 diff。下面总结一下非框架下vdom的使用方法： 123456789&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;button id=\"btn-submit\"&gt;change&lt;/button&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/snabbdom/0.7.3/h.js\"&gt;&lt;/script&gt; 以上是html结构，引入不同的snabbdom文件是对应解析绑定的事件、属性等。首先使用 patch(c, vnode) 创建无序列表如下： 单击按钮再次调用 patch 函数即可生成： 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435const snabbdom = window.snabbdom // init snabbdom let patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners ]) //define h() let h = snabbdom.h let c = document.getElementById('container') let btn = document.getElementById('btn-submit') // create vnode let vnode = h('ul#list', &#123;&#125;, [ h('li.item', &#123;&#125;, 'item1'), h('li.item', &#123;&#125;, 'item2') ]) // first time create vdom and transform it to dom patch(c, vnode) btn.addEventListener('click', () =&gt; &#123; // define new node let newNode = h('ul#list', &#123;&#125;, [ h('li.item', &#123;&#125;, 'item1'), h('li.item', &#123;&#125;, 'item22'), h('li.item', &#123;&#125;, 'item3') ]) // find diffs , update diffs into original DOM patch(vnode, newNode) vnode = newNode &#125;) h 函数的作用是将传入的数据转化为vnode（vnode具体格式参照上述译文中的 copy），patch 函数先判断是否存在 vnode，不存在的话直接将 vnode，生成 dom，插入目标中；若存在进行 diff 算法，找出差异后对原生 dom 进行更新。 动手模拟 patch 实现过程patch 函数有俩种用法： patch(container, vnode) patch(vnode, newNode) 先来看第一种： 123456789101112131415&#123; tag: 'ul', attrs: &#123; id: 'list' &#125;, children: [ &#123; tag: 'li', attrs: &#123; classname: 'item' &#125;, children: ['item1'] &#125; ]&#125; 123&lt;ul id=\"list\"&gt; &lt;li class=\"item\"&gt;item 1&lt;/li&gt;&lt;/ul&gt; 首先得将vnode转化为html结构，才能加入到container种，那么如何将上述js对象（vnode）转化为 html 呢？ 1234567891011121314151617181920function createEl(vnode) &#123; let tag = vnode.tag let attrs = vnode.attrs || &#123;&#125; let children = vnode.children || [] if(!tag) return null; let el = document.createElement(tag) for(let attrName in attrs) &#123; if(attrs.hasOwnProperty(attrName))&#123; el.setAttribute(attrName, attrs[attrName]) &#125; &#125; children.forEach(v =&gt; &#123; el.append(createElement(v)) &#125;) return el;&#125; 大概就是这样，利用递归循环遍历 children，设置 !tag 为终止条件。 第二种： 12345678910111213141516171819202122&#123; tag: 'ul', attrs: &#123; id: 'list' &#125;, children: [ &#123; tag: 'li', attrs: &#123; classname: 'item' &#125;, children: ['item12'] &#125;, &#123; tag: 'li', attrs: &#123; classname: 'item' &#125;, children: ['item2'] &#125; ]&#125; 1234&lt;ul id=\"list\"&gt; &lt;li class=\"item\"&gt;item 12&lt;/li&gt; &lt;li class=\"item\"&gt;item 2&lt;/li&gt;&lt;/ul&gt; 这里我们想要将列表更新为上述结构，使用 patch(vnode, newNode) 方法，这个方法中肯定是要不断的去对比，不断的对比children肯定还会用到递归，模拟代码（只考虑最简单的情况）如下： 12345678910111213141516function updateEl(vnode, newNode) &#123; let children = vnode.children || [] let newChildren = newNode.children || [] children.forEach((child, idx) =&gt; &#123; let newChild = newChildren[idx] if(newChild === null) return ; if(child.tag === newChild.tag) &#123; // the same tag updateEl(child, newChild) &#125;else&#123; // the different tag replaceNode(child, newChild) &#125; &#125;)&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://i7eo.com/categories/Javascript/"}],"tags":[{"name":"虚拟Dom","slug":"虚拟Dom","permalink":"https://i7eo.com/tags/虚拟Dom/"}]},{"title":"Mac下利用Alfred与七牛搭建markdown图床","slug":"Mac下利用Alfred与七牛搭建markdown图床","date":"2017-11-03T12:57:58.000Z","updated":"2018-12-30T13:42:42.810Z","comments":true,"path":"2017/11/03/Mac下利用Alfred与七牛搭建markdown图床.html","link":"","permalink":"https://i7eo.com/2017/11/03/Mac下利用Alfred与七牛搭建markdown图床.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后）","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用hexo与gitpage完成个人博客搭建后，在写博客时想插入图片总是需要外链，感觉很繁琐。刚好在利用alfred的workflow后觉得能不能把整套手动获取图片外链的动作变成自动化的动作，来用热键触发。搜了下相关的文章自己踩了不少坑最终还是完成了，总结出来避免大家后面踩坑。 前期准备： 可以使用workflow的alfred（能支持正版最好不过我还是准备了链接，位置在文章最后） 七牛账号&amp;七牛自动化工具qshell 截图工具（这个也可以没有，可以利用电脑自带的截图功能，只要保证截图动作后的结果处于剪切板中即可） 第一部分：（七牛操作）第一步：注册成功登陆后，单击 管理控制台 -&gt; 对象存储 -&gt; 内容管理 找到外链默认域名，复制并保存。 第二步：返回首页，单击 服务与支持 -&gt; 开发者中心 -&gt; sdk与工具 -&gt; 开发者工具 -&gt; qshell 进入后按照提示下载并安装。 第三步：创建账户时，除了ak&amp;sk 现在还需要输入七牛账户名；配置upload.conf文件时需要注意如果本地新增文件七牛默认不会自动检查，你需要设置 rescan_local: true ;如果你在七牛空间（web页）中手动删除某个文件，再次上传该文件的时候七牛默认该文件已经存在空间中，不会再上传该文件，你需要配置 check_exists: true 。 第二部分：（alfred workflow操作）第一步： 点击 + ，创建blank workflow即可，注意bundle id必填一个唯一值，能够在alfred中标示你这个workflow即可，其余选项正常填写，category默认选项即可。 第二步： 创建热键hotkey，其余默认选项不变，完成后save。 创建热键触发后需要执行的脚本文件，当然run script创建的脚本是后台运行不需要先调出terminal（控制台），如果需要调出terminal（控制台），选择terminal command。根据脚本语言对应选择language，这里提供一个as版本代码：12345678910111213141516171819202122232425262728293031323334353637383940414243property fileTypes : &#123;¬ &#123;«class PNGf», \".png\"&#125;, ¬ &#123;JPEG picture, \".jpg\"&#125;&#125;on getType() --判断剪贴板中的数据类型，暂时只支持png和jpg，优先用png repeat with aType in fileTypes repeat with theInfo in (clipboard info) if (first item of theInfo) is equal to (first item of aType) then return aType end repeat end repeat return missing valueend getTypeset theType to getType()if theType is not missing value then set filePath to \"/Users/xxx/Documents/screenCaptures/\" --这里换成你自己放置图片的路径 set fileName to do shell script \"date \\\"+%Y%m%d%H%M%S\\\" | md5\" --用当前时间的md5值做文件名 set prefix to \"i7eo_\" -- 改成自己的前缀 if fileName does not end with (second item of theType) then set fileName to (fileName &amp; second item of theType as text) set markdownUrl to \"![截图](http://xxx.com/i7eo_\" &amp; fileName &amp; \")\" --这里如果没有用到图床，就把前面前缀去掉，用到的话换成你自己图床的url set filePath to filePath &amp; prefix &amp; fileName try set imageFile to (open for access filePath with write permission) set eof imageFile to 0 write (the clipboard as (first item of theType)) to imageFile -- as whatever close access imageFile set the clipboard to markdownUrl try tell application \"System Events\" keystroke \"v\" using command down end tell end try on error try close access imageFile end try return \"\" end tryelse return \"\"end if 把 http://xxx.com/改为之前从七牛默认外链处复制出来的地址。 第三步：再次创建一个blank workflow，热键自己设置；再次创建一个as脚本，具体代码如下：1do shell script \"/usr/local/bin/qshell qupload ~/.qshell/upload.conf\" 把qupload前的路径换成自己存放七牛qshell文件的位置。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法适合写博客时，把该篇博客需要的图片都存放在同一个文件下，写完后一次性上传至七牛空间。然后在把博客推至gitpage即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想每次插入一张图片就上传，可以使用插件 Mac 版本的 Markdown 一键贴图工具 alfred3 Powerpack","categories":[{"name":"自动化","slug":"自动化","permalink":"https://i7eo.com/categories/自动化/"}],"tags":[{"name":"Alfred3 workflow","slug":"Alfred3-workflow","permalink":"https://i7eo.com/tags/Alfred3-workflow/"},{"name":"图床","slug":"图床","permalink":"https://i7eo.com/tags/图床/"},{"name":"qshell","slug":"qshell","permalink":"https://i7eo.com/tags/qshell/"}]},{"title":"为git page开通https踩坑实录","slug":"为gitPages开通https踩坑实录","date":"2017-10-01T08:37:27.000Z","updated":"2018-12-28T18:56:19.680Z","comments":true,"path":"2017/10/01/为gitPages开通https踩坑实录.html","link":"","permalink":"https://i7eo.com/2017/10/01/为gitPages开通https踩坑实录.html","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用hexo与gitpage开通博客后，无论是pc&amp;mobile登陆时总会发现地址栏前有个感叹号。强迫症表示真的看不下去，所以就去了解了下https。 HTTPS的优点 了解到https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 最重要的一点，https可以避免dns挟持，就是可以避免在浏览网页时出现一些小广告弹窗！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合自己的代码发现引用的图片全是http协议下的，而且在input（即使type≠keyword）输入内容时感叹号变成了红字叉。我所用的是阿里的域名所以去网站查询https的信息，发现有免费的赛门铁克（Symantec）证书试用。果断申请后，发现： gitPages注意事项 git page自带https，在对应rep的设置中，点击 Enforce HTTPS 即可。 git page绑定自定义域名后无法添加ssl证书。这个时候有点懵了，不过检索多次相关关键字后，发现了cloudflare这个好东西。大概了解了下后就确定用它了，好处如下： 安利cloudflare的原因 有免费套 cloudflare的dns服务器风评还是不错的-cloudflare提供 Universal SSL 服务，简单来说就是让任意http站点支持https。 （具体原理指的是，用cloudflare的dns服务器，当你访问网页时，网页 -&gt; cloudflare 这个过程是加密的，而 cloudflare -&gt; git page这个过程是非加密（http）） 具体可参考官方文档： how Cloudflare’s servers connect to your origin for HTTPS requests cloudflare配置的具体步骤第一步：设置dns把自己对应的dns服务器改为cloudflare的，下面以阿里来举例。阿里云 -&gt; 域名 -&gt; 管理 -&gt; 修改dns，出现一下界面： 这是我已经修改后的，单击右边的修改dns服务器即可，把cloudflare给出的俩个dns地址换上来就好。cloudflare给出的dns地址位于：cloudflare -&gt; dns -&gt; Cloudflare Nameservers。 如何判断更换dns成功？回到cloudflare后，单击overview，如果成功会出现： 第二步：设置dns信息cloudflare -&gt; dns -&gt; DNS Records 如果这里没设置时有记录先删除，新增一条记录: 第三步：设置ssl&amp;强制跳转cloudflare -&gt; crypto -&gt; SSL 勾选flexible cloudflare -&gt; crypto -&gt; Always Use HTTPS 勾选on 第四步：坐等&amp;排错大概10mins - 30mins左右就会生效，可以在等待的时候使用ping命令来ping个人的域名查看ip。 如果你的博客出现以下情况： 检查gitpage的设置，取消掉勾选的Enforce HTTPS选项，这个设置是有缓存的 可以切换source或者theme chooser这样可以清理掉缓存的Enforce HTTPS选项信息。 参考文章： 使用Cloudflare为自定义域名的GithubPages实现HTTPS化 解决Cloudflare产生的“ERR_TOO_MANY_REDIRECTS”错误","categories":[{"name":"运维","slug":"运维","permalink":"https://i7eo.com/categories/运维/"}],"tags":[{"name":"cloudflare","slug":"cloudflare","permalink":"https://i7eo.com/tags/cloudflare/"},{"name":"https","slug":"https","permalink":"https://i7eo.com/tags/https/"}]}]}